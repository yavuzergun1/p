import {
  AES_CBC
} from "./chunk-K7QGI3Y5.js";
import {
  AbstractWalletPlugin,
  Canceled,
  WalletPluginMetadata
} from "./chunk-3YPWYDFE.js";
import {
  Bytes,
  Checksum256,
  Checksum512,
  PermissionLevel,
  PrivateKey,
  PublicKey,
  ResolvedSigningRequest,
  Serializer,
  Signature,
  SigningRequest,
  Struct,
  UInt64
} from "./chunk-5LFW4XHT.js";
import "./chunk-3NECCBKX.js";
import "./chunk-A4WGX5HS.js";
import {
  __commonJS,
  __publicField,
  __toESM
} from "./chunk-JEXKZRFY.js";

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__)
        prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events();
      else
        delete emitter._events[evt];
    }
    function EventEmitter2() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0)
        return names;
      for (name in events = this._events) {
        if (has.call(events, name))
          names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter2.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers)
        return [];
      if (handlers.fn)
        return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners)
        return 0;
      if (listeners.fn)
        return 1;
      return listeners.length;
    };
    EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once)
            this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args)
                for (j = 1, args = new Array(len - 1); j < len; j++) {
                  args[j - 1] = arguments[j];
                }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter2.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length)
          this._events[evt] = events.length === 1 ? events[0] : events;
        else
          clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix;
    EventEmitter2.EventEmitter = EventEmitter2;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter2;
    }
  }
});

// node_modules/@greymass/buoy/lib/buoy-client.m.js
var import_eventemitter3 = __toESM(require_eventemitter3());
var SocketError = class extends Error {
  constructor(event) {
    super("Socket error");
    __publicField(this, "event");
    __publicField(this, "code", "E_NETWORK");
    this.event = event;
  }
};
var MessageError = class extends Error {
  constructor(reason, underlyingError) {
    super(reason);
    __publicField(this, "reason");
    __publicField(this, "underlyingError");
    __publicField(this, "code", "E_MESSAGE");
    this.reason = reason;
    this.underlyingError = underlyingError;
  }
};
var global$1 = globalThis || window;
var ListenerEncoding;
(function(ListenerEncoding2) {
  ListenerEncoding2["binary"] = "binary";
  ListenerEncoding2["text"] = "text";
  ListenerEncoding2["json"] = "json";
})(ListenerEncoding || (ListenerEncoding = {}));
var Listener = class extends import_eventemitter3.default {
  constructor(options) {
    super();
    __publicField(this, "url");
    __publicField(this, "active", false);
    __publicField(this, "socket");
    __publicField(this, "timer");
    __publicField(this, "reconnectTimer");
    __publicField(this, "encoding");
    __publicField(this, "WebSocket");
    if (!options.service) {
      throw new Error("Options must include a service url");
    }
    if (!options.channel) {
      throw new Error("Options must include a channel name");
    }
    const baseUrl = options.service.replace(/^http/, "ws").replace(/\/$/, "");
    this.url = `${baseUrl}/${options.channel}?v=2`;
    this.encoding = options.encoding || ListenerEncoding.text;
    this.WebSocket = options.WebSocket || global$1.WebSocket;
    if (options.autoConnect !== false) {
      this.connect();
    }
  }
  connect() {
    if (this.active)
      return;
    this.active = true;
    let retries = 0;
    let pingTimer;
    const connect = () => {
      const socket = new this.WebSocket(this.url);
      socket.onmessage = (event) => {
        if (typeof Blob !== "undefined" && event.data instanceof Blob) {
          const reader = new FileReader();
          reader.onload = () => {
            this.handleMessage(new Uint8Array(reader.result));
          };
          reader.onerror = () => {
            this.emit("error", new MessageError("Could not read message"));
          };
          reader.readAsArrayBuffer(event.data);
        } else if (typeof event.data === "string") {
          this.handleMessage(new TextEncoder().encode(event.data));
        } else if (typeof global$1.Buffer !== "undefined" && (event.data instanceof global$1.Buffer || Array.isArray(event.data))) {
          let buffer = event.data;
          if (!global$1.Buffer.isBuffer(buffer)) {
            buffer = global$1.Buffer.concat(buffer);
          }
          this.handleMessage(new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength));
        } else if (event.data instanceof Uint8Array) {
          this.handleMessage(event.data);
        } else if (event.data instanceof ArrayBuffer) {
          this.handleMessage(new Uint8Array(event.data));
        } else {
          this.emit("error", new MessageError("Unhandled event data type"));
        }
      };
      socket.onerror = (event) => {
        if (this.socket === socket && this.active) {
          this.emit("error", new SocketError(event));
        }
      };
      socket.onopen = () => {
        retries = 0;
        this.emit("connect");
      };
      socket.onclose = () => {
        if (this.active) {
          clearTimeout(this.timer);
          this.timer = setTimeout(connect, backoff(retries++));
        }
        this.socket = void 0;
        clearTimeout(pingTimer);
        if (this.reconnectTimer) {
          clearInterval(this.reconnectTimer);
        }
        this.emit("disconnect");
      };
      this.setupReconnectionTimer();
      const nodeSocket = socket;
      if (typeof nodeSocket.on === "function" && typeof nodeSocket.terminate === "function") {
        nodeSocket.on("ping", () => {
          clearTimeout(pingTimer);
          pingTimer = setTimeout(() => {
            nodeSocket.terminate();
          }, 15 * 1e3);
        });
      }
      this.socket = socket;
    };
    connect();
  }
  disconnect() {
    this.active = false;
    if (this.socket && (this.socket.readyState === this.WebSocket.OPEN || this.socket.readyState === this.WebSocket.CONNECTING)) {
      this.socket.close(1e3);
    }
  }
  get isConnected() {
    var _a;
    return this.active && ((_a = this.socket) == null ? void 0 : _a.readyState) == this.WebSocket.OPEN;
  }
  handleMessage(bytes) {
    var _a;
    if (bytes[0] === 66 && bytes[1] === 66 && bytes[2] === 1) {
      (_a = this.socket) == null ? void 0 : _a.send(new Uint8Array([66, 66, 2, bytes[3]]));
      bytes = bytes.subarray(4);
    }
    let message;
    switch (this.encoding) {
      case ListenerEncoding.binary:
        message = bytes;
        break;
      case ListenerEncoding.text:
        message = new TextDecoder().decode(bytes);
        break;
      case ListenerEncoding.json: {
        try {
          message = JSON.parse(new TextDecoder().decode(bytes));
        } catch (error2) {
          this.emit("error", new MessageError("Unable to decode JSON", error2));
          return;
        }
      }
    }
    this.emit("message", message);
  }
  setupReconnectionTimer() {
    this.reconnectTimer = setInterval(() => {
      var _a;
      (_a = this.socket) == null ? void 0 : _a.close(1e3);
    }, 10 * 60 * 1e3);
  }
};
function backoff(tries) {
  return Math.min(Math.pow(tries * 7, 2), 5 * 1e3);
}
function receive(options, ctx) {
  return new Promise((resolve, reject) => {
    const listener = new Listener({ ...options, autoConnect: true });
    let timer;
    let lastError;
    const done = (error2, message) => {
      clearTimeout(timer);
      if (error2) {
        reject(error2);
      } else {
        resolve(message);
      }
      listener.disconnect();
    };
    if (ctx) {
      ctx.cancel = () => {
        done(new MessageError("Cancelled", lastError));
      };
    }
    if (options.timeout) {
      timer = setTimeout(() => {
        done(new MessageError("Timed out", lastError));
      }, options.timeout);
    }
    listener.on("error", (error2) => {
      if (!(error2 instanceof SocketError)) {
        done(error2);
      } else {
        lastError = error2;
      }
    });
    listener.once("message", (message) => {
      done(void 0, message);
    });
  });
}
var global2 = globalThis || window;
var SendResult;
(function(SendResult2) {
  SendResult2["buffered"] = "buffered";
  SendResult2["delivered"] = "delivered";
})(SendResult || (SendResult = {}));
async function send(message, options) {
  const fetch = options.fetch || global2.fetch;
  const baseUrl = options.service.replace(/^ws/, "http").replace(/\/$/, "");
  const url = `${baseUrl}/${options.channel}`;
  const headers = {};
  if (options.requireDelivery) {
    if (!options.timeout) {
      throw new Error("requireDelivery can only be used with timeout");
    }
    headers["X-Buoy-Wait"] = `${Math.ceil(options.timeout / 1e3)}`;
  } else if (options.timeout) {
    headers["X-Buoy-Soft-Wait"] = `${Math.ceil(options.timeout / 1e3)}`;
  }
  let body;
  if (typeof message === "string" || message instanceof Uint8Array) {
    body = message;
  } else {
    body = JSON.stringify(message);
  }
  const response = await fetch(url, { method: "POST", body, headers });
  if (Math.floor(response.status / 100) !== 2) {
    if (response.status === 408) {
      throw new Error("Unable to deliver message");
    } else if (response.status === 410) {
      throw new Error("Request cancelled");
    } else {
      throw new Error(`Unexpected status code ${response.status}`);
    }
  }
  return response.headers.get("X-Buoy-Delivery") || SendResult.buffered;
}

// node_modules/@wharfkit/wallet-plugin-anchor/node_modules/isomorphic-ws/browser.js
var ws = null;
if (typeof WebSocket !== "undefined") {
  ws = WebSocket;
} else if (typeof MozWebSocket !== "undefined") {
  ws = MozWebSocket;
} else if (typeof global !== "undefined") {
  ws = global.WebSocket || global.MozWebSocket;
} else if (typeof window !== "undefined") {
  ws = window.WebSocket || window.MozWebSocket;
} else if (typeof self !== "undefined") {
  ws = self.WebSocket || self.MozWebSocket;
}
var browser_default = ws;

// node_modules/@wharfkit/wallet-plugin-anchor/lib/wallet-plugin-anchor.m.js
function uuid() {
  let uuid2 = "", ii;
  const chars = "0123456789abcdef";
  for (ii = 0; ii < 36; ii += 1) {
    switch (ii) {
      case 8:
      case 13:
      case 18:
      case 23:
        uuid2 += "-";
        break;
      case 14:
        uuid2 += "4";
        break;
      case 19:
        uuid2 += chars[Math.random() * 4 | 0 + 8];
        break;
      default:
        uuid2 += chars[Math.random() * 16 | 0];
    }
  }
  return uuid2;
}
function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var BuoyMessage = class BuoyMessage2 extends Struct {
};
__decorate([
  Struct.field("public_key")
], BuoyMessage.prototype, "from", void 0);
__decorate([
  Struct.field("uint64")
], BuoyMessage.prototype, "nonce", void 0);
__decorate([
  Struct.field("bytes")
], BuoyMessage.prototype, "ciphertext", void 0);
__decorate([
  Struct.field("uint32")
], BuoyMessage.prototype, "checksum", void 0);
BuoyMessage = __decorate([
  Struct.type("buoy_message")
], BuoyMessage);
var BuoySession = class BuoySession2 extends Struct {
};
__decorate([
  Struct.field("name")
], BuoySession.prototype, "session_name", void 0);
__decorate([
  Struct.field("public_key")
], BuoySession.prototype, "request_key", void 0);
__decorate([
  Struct.field("string", { extension: true })
], BuoySession.prototype, "user_agent", void 0);
BuoySession = __decorate([
  Struct.type("buoy_session")
], BuoySession);
var BuoyInfo = class BuoyInfo2 extends Struct {
};
__decorate([
  Struct.field("time_point_sec")
], BuoyInfo.prototype, "expiration", void 0);
BuoyInfo = __decorate([
  Struct.type("buoy_info")
], BuoyInfo);
var SealedMessage = class SealedMessage2 extends Struct {
};
__decorate([
  Struct.field("public_key")
], SealedMessage.prototype, "from", void 0);
__decorate([
  Struct.field("uint64")
], SealedMessage.prototype, "nonce", void 0);
__decorate([
  Struct.field("bytes")
], SealedMessage.prototype, "ciphertext", void 0);
__decorate([
  Struct.field("uint32")
], SealedMessage.prototype, "checksum", void 0);
SealedMessage = __decorate([
  Struct.type("sealed_message")
], SealedMessage);
var LinkCreate = class LinkCreate2 extends Struct {
};
__decorate([
  Struct.field("name")
], LinkCreate.prototype, "session_name", void 0);
__decorate([
  Struct.field("public_key")
], LinkCreate.prototype, "request_key", void 0);
__decorate([
  Struct.field("string", { extension: true })
], LinkCreate.prototype, "user_agent", void 0);
LinkCreate = __decorate([
  Struct.type("link_create")
], LinkCreate);
var LinkInfo = class LinkInfo2 extends Struct {
};
__decorate([
  Struct.field("time_point_sec")
], LinkInfo.prototype, "expiration", void 0);
LinkInfo = __decorate([
  Struct.type("link_info")
], LinkInfo);
async function createIdentityRequest(context, buoyUrl) {
  var _a;
  const privateKey = PrivateKey.generate("K1");
  const requestKey = privateKey.toPublic();
  const createInfo = BuoySession.from({
    session_name: "Anchor Session",
    request_key: requestKey,
    user_agent: getUserAgent()
  });
  const isMultiChain = !(context.chain || context.chains.length === 1);
  const callbackChannel = prepareCallbackChannel(buoyUrl);
  const request = SigningRequest.identity({
    callback: prepareCallback(callbackChannel),
    scope: String(context.appName),
    chainId: isMultiChain ? null : (_a = context.chain) == null ? void 0 : _a.id,
    chainIds: isMultiChain ? context.chains.map((c) => c.id) : void 0,
    info: {
      link: createInfo,
      scope: String(context.appName)
    }
  }, context.esrOptions);
  return {
    callback: callbackChannel,
    request,
    requestKey,
    privateKey
  };
}
function setTransactionCallback(resolved, buoyUrl) {
  const callback = prepareCallbackChannel(buoyUrl);
  resolved.request.setCallback(`${callback.service}/${callback.channel}`, true);
  return callback;
}
function getUserAgent() {
  const version = "0.4.3";
  let agent = `@wharfkit/wallet-plugin-anchor ${version}`;
  if (typeof navigator !== "undefined") {
    agent += " " + navigator.userAgent;
  }
  return agent;
}
function prepareCallback(callbackChannel) {
  const { service, channel } = callbackChannel;
  return {
    url: `${service}/${channel}`,
    background: true
  };
}
function prepareCallbackChannel(buoyUrl) {
  return {
    service: buoyUrl,
    channel: uuid()
  };
}
function sealMessage(message, privateKey, publicKey, nonce) {
  const secret = privateKey.sharedSecret(publicKey);
  if (!nonce) {
    nonce = UInt64.random();
  }
  const key = Checksum512.hash(Serializer.encode({ object: nonce }).appending(secret.array));
  const cbc = new AES_CBC(key.array.slice(0, 32), key.array.slice(32, 48));
  const ciphertext = Bytes.from(cbc.encrypt(Bytes.from(message, "utf8").array));
  const checksumView = new DataView(Checksum256.hash(key.array).array.buffer);
  const checksum = checksumView.getUint32(0, true);
  return SealedMessage.from({
    from: privateKey.toPublic(),
    nonce,
    ciphertext,
    checksum
  });
}
async function verifyLoginCallbackResponse(callbackResponse, context) {
  if (!callbackResponse.sig || callbackResponse.sig.length === 0) {
    throw new Error("Invalid response, must have at least one signature");
  }
  let chain;
  if (!context.chain && context.chains.length > 1) {
    if (!callbackResponse.cid) {
      throw new Error("Multi chain response payload must specify resolved chain id (cid)");
    }
  } else {
    chain = context.chain || context.chains[0];
    if (callbackResponse.cid && String(chain.id) !== callbackResponse.cid) {
      throw new Error("Got response for wrong chain id");
    }
  }
}
function extractSignaturesFromCallback(payload) {
  const signatures = [];
  let index = 0;
  let sig = payload.sig;
  while (sig) {
    signatures.push(Signature.from(sig));
    sig = payload[`sig${index}`];
    index++;
  }
  return signatures;
}
function isCallback(object) {
  return "tx" in object;
}
var shared$1 = {
  preparing: "Preparing request for Anchor..."
};
var login = {
  title: "Login with Anchor",
  body: "Scan the QR-code with Anchor on another device or use the button to open it here.",
  link: "Open Anchor"
};
var transact = {
  title: "Sign transaction with Anchor",
  body: 'Please open the Anchor Wallet on "{{channelName}}" to review and sign the transaction.',
  label: "Sign manually or with another device",
  link: "Trigger Manually"
};
var error = {
  expired: "The request expired, please try again.",
  invalid_response: "Invalid response from Anchor, must contain link_ch, link_key, link_name and cid flags.",
  not_completed: "The request was not completed."
};
var en = {
  shared: shared$1,
  login,
  transact,
  error
};
var ko = {};
var shared = {
  preparing: "正在准备向Anchor发送请求..."
};
var zh_hans = {
  shared
};
var zh_hant = {};
var defaultTranslations = {
  en,
  ko,
  "zh-Hans": zh_hans,
  "zh-Hant": zh_hant
};
var WalletPluginAnchor = class extends AbstractWalletPlugin {
  constructor(options) {
    super();
    this.id = "anchor";
    this.translations = defaultTranslations;
    this.config = {
      // Should the user interface display a chain selector?
      requiresChainSelect: false,
      // Should the user interface display a permission selector?
      requiresPermissionSelect: false
    };
    this.metadata = WalletPluginMetadata.from({
      name: "Anchor",
      description: "",
      logo: {
        dark: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPHN2ZyB3aWR0aD0iMTYwIiBoZWlnaHQ9IjE2MCIgdmlld0JveD0iMCAwIDI1NiAyNTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CiAgPGcgdHJhbnNmb3JtPSJtYXRyaXgoMS40NCwgMCwgMCwgMS40NCwgLTguNTAxOTI1LCAtNTcuMDc0NTcpIiBzdHlsZT0iIj4KICAgIDx0aXRsZT5XaGl0ZTwvdGl0bGU+CiAgICA8Y2lyY2xlIGN4PSI5NC43OTMiIGN5PSIxMjguNTI0IiByPSI4MCIgZmlsbD0iI0ZCRkRGRiIvPgogICAgPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0gOTQuNzk5IDc4LjUyNCBDIDk3LjA5OCA3OC41MjQgOTkuMTk1IDc5LjgzNyAxMDAuMTk4IDgxLjkwNiBMIDEyNC4yMDQgMTMxLjQwNiBMIDEyNC43NDYgMTMyLjUyNCBMIDExMS40MDkgMTMyLjUyNCBMIDEwNy41MyAxMjQuNTI0IEwgODIuMDY5IDEyNC41MjQgTCA3OC4xODkgMTMyLjUyNCBMIDY0Ljg1MyAxMzIuNTI0IEwgNjUuMzk1IDEzMS40MDYgTCA4OS40MDEgODEuOTA2IEMgOTAuNDA0IDc5LjgzNyA5Mi41MDEgNzguNTI0IDk0Ljc5OSA3OC41MjQgWiBNIDg2LjkxOSAxMTQuNTI0IEwgMTAyLjY4IDExNC41MjQgTCA5NC43OTkgOTguMjc0IEwgODYuOTE5IDExNC41MjQgWiBNIDExMi43OTMgMTQ5LjUyNCBMIDEyNC43OTggMTQ5LjUyNCBDIDEyNC40MzcgMTY1LjY3NiAxMTEuMDY3IDE3OC41MjQgOTQuNzk5IDE3OC41MjQgQyA3OC41MzIgMTc4LjUyNCA2NS4xNjIgMTY1LjY3NiA2NC44MDEgMTQ5LjUyNCBMIDc2LjgwNiAxNDkuNTI0IEMgNzcuMDg3IDE1Ni44NzggODEuOTc0IDE2My4xNTUgODguNzkzIDE2NS41MiBMIDg4Ljc5MyAxNDEuNTI0IEMgODguNzkzIDEzOC4yMSA5MS40OCAxMzUuNTI0IDk0Ljc5MyAxMzUuNTI0IEMgOTguMTA3IDEzNS41MjQgMTAwLjc5MyAxMzguMjEgMTAwLjc5MyAxNDEuNTI0IEwgMTAwLjc5MyAxNjUuNTI0IEMgMTA3LjYyIDE2My4xNjIgMTEyLjUxMSAxNTYuODgzIDExMi43OTMgMTQ5LjUyNCBaIiBmaWxsPSIjMzY1MEEyIi8+CiAgPC9nPgo8L3N2Zz4=",
        light: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYwIiBoZWlnaHQ9IjE2MCIgdmlld0JveD0iMCAwIDE2MCAxNjAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxjaXJjbGUgY3g9IjgwIiBjeT0iODAiIHI9IjgwIiBmaWxsPSIjMzY1MEEyIi8+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNODAuMDA2MyAzMEM4Mi4zMDUxIDMwIDg0LjQwMTkgMzEuMzEzNCA4NS40MDUgMzMuMzgxOEwxMDkuNDExIDgyLjg4MjJMMTA5Ljk1MyA4NEg5Ni42MTYzTDkyLjczNjYgNzZINjcuMjc1OUw2My4zOTYxIDg0SDUwLjA1OTRMNTAuNjAxNyA4Mi44ODE4TDc0LjYwNzcgMzMuMzgxOEM3NS42MTA4IDMxLjMxMzQgNzcuNzA3NSAzMCA4MC4wMDYzIDMwWk03Mi4xMjU2IDY2SDg3Ljg4N0w4MC4wMDYzIDQ5Ljc1MDFMNzIuMTI1NiA2NlpNOTcuOTk5NSAxMDFIMTEwLjAwNUMxMDkuNjQ0IDExNy4xNTIgOTYuMjczOCAxMzAgODAuMDA2MyAxMzBDNjMuNzM4OCAxMzAgNTAuMzY4NiAxMTcuMTUyIDUwLjAwNzggMTAxSDYyLjAxMzFDNjIuMjk0MSAxMDguMzU0IDY3LjE4MDQgMTE0LjYzMSA3NC4wMDAzIDExNi45OTZWOTNDNzQuMDAwMyA4OS42ODYzIDc2LjY4NjYgODcgODAuMDAwMyA4N0M4My4zMTQgODcgODYuMDAwMyA4OS42ODYzIDg2LjAwMDMgOTNWMTE3QzkyLjgyNjUgMTE0LjYzOCA5Ny43MTgzIDEwOC4zNTkgOTcuOTk5NSAxMDFaIiBmaWxsPSJ3aGl0ZSIvPgo8L3N2Zz4K"
      },
      homepage: "https://greymass.com/anchor",
      download: "https://greymass.com/anchor/download"
    });
    this.buoyUrl = (options == null ? void 0 : options.buoyUrl) || "https://cb.anchor.link";
    this.buoyWs = options == null ? void 0 : options.buoyWs;
  }
  /**
   * Performs the wallet logic required to login and return the chain and permission level to use.
   *
   * @param options WalletPluginLoginOptions
   * @returns Promise<WalletPluginLoginResponse>
   */
  login(context) {
    return new Promise((resolve, reject) => {
      this.handleLogin(context).then((response) => {
        resolve(response);
      }).catch((error2) => {
        reject(error2);
      });
    });
  }
  async handleLogin(context) {
    var _a, _b;
    if (!context.ui) {
      throw new Error("No UI available");
    }
    const t = context.ui.getTranslate(this.id);
    (_a = context.ui) == null ? void 0 : _a.status(t("login.preparing", { default: "Preparing request for Anchor..." }));
    const { callback, request, requestKey, privateKey } = await createIdentityRequest(context, this.buoyUrl);
    const promptResponse = (_b = context.ui) == null ? void 0 : _b.prompt({
      title: t("login.preparing", { default: "Login with Anchor" }),
      body: t("login.preparing", {
        default: "Scan the QR-code with Anchor on another device or use the button to open it here."
      }),
      elements: [
        {
          type: "qr",
          data: request.encode(true, false, "esr:")
        },
        {
          type: "link",
          label: t("login.link", { default: "Open Anchor" }),
          data: {
            href: request.encode(true, false, "esr:"),
            label: t("login.link", { default: "Open Anchor" }),
            variant: "primary"
          }
        }
      ]
    });
    promptResponse.catch((error2) => {
      if (error2 instanceof Canceled) {
        throw error2;
      }
    });
    const callbackResponse = await waitForCallback(callback, this.buoyWs, t);
    if (callbackResponse.link_ch && callbackResponse.link_key && callbackResponse.link_name && callbackResponse.cid) {
      verifyLoginCallbackResponse(callbackResponse, context);
      this.data.requestKey = requestKey;
      this.data.privateKey = privateKey;
      this.data.signerKey = callbackResponse.link_key && PublicKey.from(callbackResponse.link_key);
      this.data.channelUrl = callbackResponse.link_ch;
      this.data.channelName = callbackResponse.link_name;
      return {
        chain: Checksum256.from(callbackResponse.cid),
        permissionLevel: PermissionLevel.from({
          actor: callbackResponse.sa,
          permission: callbackResponse.sp
        })
      };
    } else {
      promptResponse.cancel("Invalid response from Anchor.");
      throw new Error(t("error.invalid_response", {
        default: "Invalid response from Anchor, must contain link_ch, link_key, link_name and cid flags."
      }));
    }
  }
  /**
   * Performs the wallet logic required to sign a transaction and return the signature.
   *
   * @param chain ChainDefinition
   * @param resolved ResolvedSigningRequest
   * @returns Promise<Signature>
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  sign(resolved, context) {
    return this.handleSignatureRequest(resolved, context);
  }
  async handleSignatureRequest(resolved, context) {
    var _a;
    if (!context.ui) {
      throw new Error("No UI available");
    }
    const t = context.ui.getTranslate(this.id);
    (_a = context.ui) == null ? void 0 : _a.status(t("shared.preparing", { default: "Preparing request for Anchor..." }));
    const expiration = resolved.transaction.expiration.toDate();
    const now = /* @__PURE__ */ new Date();
    const expiresIn = Math.floor(expiration.getTime() - now.getTime());
    const callback = setTransactionCallback(resolved, this.buoyUrl);
    const promptPromise = context.ui.prompt({
      title: t("transact.title", { default: "Sign" }),
      body: t("shared.body", {
        channelName: this.data.channelName,
        default: `Please open the Anchor Wallet on "${this.data.channelName}" to review and sign the transaction.`
      }),
      elements: [
        {
          type: "countdown",
          data: expiration.toISOString()
        },
        {
          type: "link",
          label: t("shared.label", { default: "Sign manually or with another device" }),
          data: {
            href: resolved.request.encode(true, false, "esr:"),
            label: t("shared.link", { default: "Trigger Manually" })
          }
        }
      ]
    });
    const timer = setTimeout(() => {
      if (!context.ui) {
        throw new Error("No UI available");
      }
      promptPromise.cancel(t("error.expired", { default: "The request expired, please try again." }));
    }, expiresIn);
    promptPromise.catch(() => clearTimeout(timer));
    resolved.request.setInfoKey("link", LinkInfo.from({
      expiration
    }));
    const callbackPromise = waitForCallback(callback, this.buoyWs, t);
    const service = new URL(this.data.channelUrl).origin;
    const channel = new URL(this.data.channelUrl).pathname.substring(1);
    const sealedMessage = sealMessage(resolved.request.encode(true, false, "esr:"), PrivateKey.from(this.data.privateKey), PublicKey.from(this.data.signerKey));
    send(Serializer.encode({ object: sealedMessage }).array, {
      service,
      channel
    });
    const callbackResponse = await Promise.race([callbackPromise, promptPromise]).finally(() => {
      clearTimeout(timer);
    });
    const wasSuccessful = isCallback(callbackResponse) && extractSignaturesFromCallback(callbackResponse).length > 0;
    if (wasSuccessful) {
      const resolvedRequest = await ResolvedSigningRequest.fromPayload(callbackResponse, context.esrOptions);
      const newRequest = await SigningRequest.create({
        transaction: resolvedRequest.transaction
      }, context.esrOptions);
      return {
        signatures: extractSignaturesFromCallback(callbackResponse),
        request: newRequest
      };
    }
    const errorString = t("error.not_completed", { default: "The request was not completed." });
    promptPromise.cancel(errorString);
    throw new Error(errorString);
  }
};
async function waitForCallback(callbackArgs, buoyWs, t) {
  const callbackResponse = await receive({ ...callbackArgs, WebSocket: buoyWs || browser_default });
  if (!callbackResponse) {
    throw new Error(callbackResponse.rejected);
  }
  if (typeof callbackResponse.rejected === "string") {
    throw new Error(callbackResponse.rejected);
  }
  const payload = JSON.parse(callbackResponse);
  if (payload.sa === void 0 || payload.sp === void 0 || payload.cid === void 0) {
    throw new Error(t("error.cancelled", { default: "The request was cancelled from Anchor." }));
  }
  return payload;
}
export {
  WalletPluginAnchor
};
/*! Bundled license information:

@greymass/buoy/lib/buoy-client.m.js:
  (**
   * @greymass/buoy v1.0.3
   * https://github.com/greymass/buoy-client
   *
   * @license
   * Copyright (c) 2021 FFF00 Agents AB & Greymass Inc. All Rights Reserved.
   * 
   * Redistribution and use in source and binary forms, with or without modification,
   * are permitted provided that the following conditions are met:
   * 
   *  1. Redistribution of source code must retain the above copyright notice, this
   *     list of conditions and the following disclaimer.
   * 
   *  2. Redistribution in binary form must reproduce the above copyright notice,
   *     this list of conditions and the following disclaimer in the documentation
   *     and/or other materials provided with the distribution.
   * 
   *  3. Neither the name of the copyright holder nor the names of its contributors
   *     may be used to endorse or promote products derived from this software without
   *     specific prior written permission.
   * 
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
   * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
   * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
   * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
   * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
   * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
   * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
   * OF THE POSSIBILITY OF SUCH DAMAGE.
   * 
   * YOU ACKNOWLEDGE THAT THIS SOFTWARE IS NOT DESIGNED, LICENSED OR INTENDED FOR USE
   * IN THE DESIGN, CONSTRUCTION, OPERATION OR MAINTENANCE OF ANY MILITARY FACILITY.
   *)

@wharfkit/wallet-plugin-anchor/lib/wallet-plugin-anchor.m.js:
  (**
   * @wharfkit/wallet-plugin-anchor v0.4.3
   * https://github.com/wharfkit/wallet-plugin-anchor
   *
   * @license
   * Copyright (c) 2023 Greymass Inc. All Rights Reserved.
   * 
   * Redistribution and use in source and binary forms, with or without modification,
   * are permitted provided that the following conditions are met:
   * 
   * 1.  Redistribution of source code must retain the above copyright notice, this
   *     list of conditions and the following disclaimer.
   * 
   * 2.  Redistribution in binary form must reproduce the above copyright notice,
   *     this list of conditions and the following disclaimer in the documentation
   *     and/or other materials provided with the distribution.
   * 
   * 3.  Neither the name of the copyright holder nor the names of its contributors
   *     may be used to endorse or promote products derived from this software without
   *     specific prior written permission.
   * 
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
   * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
   * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
   * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
   * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
   * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
   * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
   * OF THE POSSIBILITY OF SUCH DAMAGE.
   * 
   * YOU ACKNOWLEDGE THAT THIS SOFTWARE IS NOT DESIGNED, LICENSED OR INTENDED FOR USE
   * IN THE DESIGN, CONSTRUCTION, OPERATION OR MAINTENANCE OF ANY MILITARY FACILITY.
   *)
*/
//# sourceMappingURL=@wharfkit_wallet-plugin-anchor.js.map
