import {
  AbstractWalletPlugin,
  WalletPluginMetadata,
  cancelable
} from "./chunk-AVHVDXBM.js";
import {
  Asset,
  Name,
  PermissionLevel,
  Serializer,
  SigningRequest,
  Struct,
  Transaction,
  UInt32
} from "./chunk-ASC2VICD.js";
import "./chunk-M7NDEZ3U.js";
import "./chunk-YSRTV47A.js";
import "./chunk-GKWPUQBP.js";

// node_modules/@wharfkit/wallet-plugin-cloudwallet/lib/wallet-plugin-cloudwallet.m.js
function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var Buyrambytes = class Buyrambytes2 extends Struct {
};
__decorate([
  Struct.field(Name)
], Buyrambytes.prototype, "payer", void 0);
__decorate([
  Struct.field(Name)
], Buyrambytes.prototype, "receiver", void 0);
__decorate([
  Struct.field(UInt32)
], Buyrambytes.prototype, "bytes", void 0);
Buyrambytes = __decorate([
  Struct.type("buyrambytes")
], Buyrambytes);
var Transfer = class Transfer2 extends Struct {
};
__decorate([
  Struct.field(Name)
], Transfer.prototype, "from", void 0);
__decorate([
  Struct.field(Name)
], Transfer.prototype, "to", void 0);
__decorate([
  Struct.field(Asset)
], Transfer.prototype, "quantity", void 0);
__decorate([
  Struct.field("string")
], Transfer.prototype, "memo", void 0);
Transfer = __decorate([
  Struct.type("transfer")
], Transfer);
function validateModifications(original, modified) {
  const originalsExist = original.actions.every((action) => modified.actions.some((modifiedAction) => action.equals(modifiedAction)));
  if (!originalsExist) {
    throw new Error("The modified transaction does not contain all the original actions.");
  }
  const newActions = modified.actions.filter((action) => {
    return !original.actions.some((originalAction) => action.equals(originalAction));
  });
  for (const newAction of newActions) {
    const authByUser = newAction.authorization.find((auth) => {
      return auth.actor === original.actions[0].authorization[0].actor;
    });
    if (authByUser) {
      const isTokenTransfer = newAction.account.equals("eosio.token") && newAction.name.equals("transfer");
      if (isTokenTransfer) {
        const data = Transfer.from(newAction.data);
        if (data.to.equals("txfee.wam") && data.memo.startsWith("WAX fee for")) {
          continue;
        }
      }
      const isRAMPurchase = newAction.account.equals("eosio") && newAction.name.equals("buyrambytes");
      if (isRAMPurchase) {
        const data = Buyrambytes.from(newAction.data);
        if (data.receiver.equals(original.actions[0].authorization[0].actor)) {
          continue;
        }
      }
      throw new Error("The modified transaction contains one or more actions that are not allowed.");
    }
  }
}
function registerCloseListener(t, popup, reject) {
  const closeListener = setInterval(() => {
    if (popup.closed) {
      clearInterval(closeListener);
      reject(t("error.closed", {
        default: "The Cloud Wallet was closed before the request was completed"
      }));
    }
  }, 500);
  return closeListener;
}
function getCurrentTime() {
  return Math.floor((/* @__PURE__ */ new Date()).getTime());
}
function isValidEvent(event, url, window2) {
  const eventOrigin = new URL(event.origin);
  const validOrigin = eventOrigin.origin === url.origin;
  const validSource = event.source === window2;
  const validObject = typeof event.data === "object";
  if (!validObject || !validOrigin || !validSource) {
    return false;
  }
  return true;
}
async function autoLogin(t, urlString) {
  const url = new URL(urlString);
  const response = await fetch(String(url), {
    credentials: "include",
    method: "get"
  });
  if (!response.ok) {
    throw new Error(t("error.endpoint", {
      default: `Login Endpoint Error {{status}} - {{statusText}}`,
      status: response.status,
      statusText: response.statusText
    }));
  }
  const data = await response.json();
  return data;
}
async function popupLogin(t, urlString, timeout = 3e5) {
  const url = new URL(urlString);
  const popup = await window.open(url, "WalletPluginCloudWalletPopup", "height=800,width=600");
  if (!popup) {
    throw new Error(t("error.popup", {
      default: "Unable to open the popup window. Check your browser settings and try again."
    }));
  }
  return new Promise((resolve, reject) => {
    const closeListener = registerCloseListener(t, popup, reject);
    const handleEvent = (event) => {
      if (!isValidEvent(event, url, popup)) {
        return;
      }
      try {
        resolve(event.data);
      } catch (e) {
        reject(e);
      } finally {
        window.removeEventListener("message", handleEvent);
        clearTimeout(autoCancel);
        clearInterval(closeListener);
      }
    };
    const autoCancel = setTimeout(() => {
      popup.close();
      window.removeEventListener("message", handleEvent);
      reject(new Error(t("error.timeout", {
        default: "The request has timed out after {{timeout}} seconds. Please try again.",
        timeout: timeout / 1e3
      })));
    }, timeout);
    window.addEventListener("message", handleEvent);
  });
}
function allowAutosign(request, data) {
  const ua = navigator.userAgent.toLowerCase();
  if (ua.search("chrome") === -1 && ua.search("safari") >= 0) {
    return false;
  }
  try {
    if (!data)
      return false;
    const whitelist = data.whitelist;
    const { actions } = request.resolvedTransaction;
    return actions.every((action) => {
      return whitelist.find((entry) => {
        if (action.account.equals(entry.contract)) {
          if (action.account.equals("eosio.token") && action.name && action.name.equals("transfer")) {
            return entry.recipients.includes(String(action.data.to));
          }
          return true;
        }
      });
    });
  } catch (e) {
  }
  return false;
}
async function autoSign(t, urlString, request) {
  const url = new URL(urlString);
  const controller = new AbortController();
  setTimeout(() => controller.abort(), 5e3);
  const response = await fetch(url, {
    body: JSON.stringify({
      feeFallback: true,
      freeBandwidth: true,
      transaction: request.serializedTransaction
    }),
    credentials: "include",
    headers: { "Content-Type": "application/json" },
    method: "POST",
    signal: controller.signal
  });
  if (!response.ok) {
    throw new Error(t("error.endpoint", {
      default: `Login Endpoint Error {{status}} - {{statusText}}`,
      status: response.status,
      statusText: response.statusText
    }));
  }
  const data = await response.json();
  if (data.processed && data.processed.except) {
    throw new Error(t("error.exception", {
      default: "Signing exception occurred: {{exception}}",
      exception: JSON.stringify(data)
    }));
  }
  return data;
}
async function popupTransact(t, urlString, request, timeout = 3e5) {
  const url = new URL(urlString);
  const popup = await window.open(url, "WalletPluginCloudWalletPopup", "height=800,width=600");
  if (!popup) {
    throw new Error(t("error.popup", {
      default: "Unable to open the popup window. Check your browser settings and try again."
    }));
  }
  return new Promise((resolve, reject) => {
    const closeListener = registerCloseListener(t, popup, reject);
    const handleEvent = (event) => {
      if (!isValidEvent(event, url, popup)) {
        return;
      }
      popup == null ? void 0 : popup.postMessage({
        feeFallback: true,
        freeBandwidth: true,
        startTime: getCurrentTime(),
        transaction: request.serializedTransaction,
        type: "TRANSACTION"
      }, String(urlString));
      const handleSigning = (signingEvent) => {
        if (!isValidEvent(signingEvent, url, popup)) {
          return;
        }
        try {
          resolve(signingEvent.data);
        } catch (e) {
          reject(e);
        } finally {
          window.removeEventListener("message", handleEvent);
          window.removeEventListener("message", handleSigning);
          clearTimeout(autoCancel);
          clearInterval(closeListener);
        }
      };
      window.addEventListener("message", handleSigning);
    };
    const autoCancel = setTimeout(() => {
      popup.close();
      window.removeEventListener("message", handleEvent);
      reject(new Error(t("error.timeout", {
        default: "The request has timed out after {{timeout}} seconds. Please try again.",
        timeout: timeout / 1e3
      })));
    }, timeout);
    window.addEventListener("message", handleEvent);
  });
}
var connecting$3 = "Connecting to Cloud Wallet";
var error$3 = {
  closed: "The Cloud Wallet was closed before the request was completed",
  endpoint: "Login Endpoint Error {{status}} - {{statusText}}",
  exception: "Signing exception occurred: {{exception}}",
  popup: "Unable to open the popup window. Check your browser settings and try again.",
  response: "The Cloud Wallet failed to respond.",
  timeout: "The request has timed out after {{timeout}} seconds. Please try again."
};
var login$3 = {
  popup: "Login with the Cloud Wallet popup window"
};
var transact$3 = {
  popup: "Sign with the Cloud Wallet popup window"
};
var en = {
  connecting: connecting$3,
  error: error$3,
  login: login$3,
  transact: transact$3
};
var connecting$2 = "클라우드 지갑에 연결";
var error$2 = {
  closed: "요청이 완료되기 전에 클라우드 지갑이 닫혔습니다.",
  endpoint: "로그인 엔드포인트 오류 {{status}} - {{statusText}}",
  exception: "서명 예외가 발생했습니다: {{exception}}",
  popup: "팝업 창을 열 수 없습니다. 브라우저 설정을 확인하고 다시 시도하십시오.",
  response: "클라우드 지갑이 응답하지 못했습니다.",
  timeout: "{{timeout}}초 후에 요청 시간이 초과되었습니다. 다시 시도하십시오."
};
var login$2 = {
  popup: "클라우드 지갑 팝업 창으로 로그인"
};
var transact$2 = {
  popup: "클라우드 지갑 팝업 창으로 서명"
};
var ko = {
  connecting: connecting$2,
  error: error$2,
  login: login$2,
  transact: transact$2
};
var connecting$1 = "正在连接到云钱包";
var error$1 = {
  closed: "云钱包在请求完成之前已关闭",
  endpoint: "登录端点错误 {{status}} - {{statusText}}",
  exception: "发生签名异常：{{exception}}",
  popup: "无法打开弹出窗口。请检查您的浏览器设置，然后重试。",
  response: "云钱包响应失败",
  timeout: "请求在 {{timeout}} 秒后超时。请重试。"
};
var login$1 = {
  popup: "使用云钱包弹出窗口登录"
};
var transact$1 = {
  popup: "使用云钱包弹出窗口签名"
};
var zh_hans = {
  connecting: connecting$1,
  error: error$1,
  login: login$1,
  transact: transact$1
};
var connecting = "正在連接到雲錢包";
var error = {
  closed: "雲錢包在請求完成之前已關閉",
  endpoint: "登錄端點錯誤 {{status}} - {{statusText}}",
  exception: "發生簽名異常：{{exception}}",
  popup: "無法打開彈出窗口。 請檢查您的瀏覽器設置，然後重試。",
  response: "雲錢包響應失敗",
  timeout: "請求在 {{timeout}} 秒後超時。請重試。"
};
var login = {
  popup: "使用雲錢包彈出窗口登錄"
};
var transact = {
  popup: "使用雲錢包彈出窗口簽名"
};
var zh_hant = {
  connecting,
  error,
  login,
  transact
};
var defaultTranslations = {
  en,
  ko,
  "zh-Hans": zh_hans,
  "zh-Hant": zh_hant
};
var WalletPluginCloudWallet = class extends AbstractWalletPlugin {
  /**
   * Constructor to allow overriding of plugin configuration.
   */
  constructor(options) {
    super();
    this.id = "cloudwallet";
    this.translations = defaultTranslations;
    this.config = {
      // Should the user interface display a chain selector?
      requiresChainSelect: true,
      // Should the user interface display a permission selector?
      requiresPermissionSelect: false,
      // The blockchains this WalletPlugin supports
      supportedChains: [
        "1064487b3cd1a897ce03ae5b6a865651747e2e152090f99c1d19d44e01aea5a4"
        // WAX (Mainnet)
        // 'f16b1833c747c43682f4386fca9cbb327929334a762755ebec17f6f23c9b8a12', // NYI - WAX (Testnet)
      ]
    };
    this.metadata = WalletPluginMetadata.from({
      name: "Cloud Wallet",
      description: "",
      logo: "PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTcuOTQ5NDMgMTkuMjU4MkM2LjE0OTM2IDE3LjQ1ODIgNi4xNDkzNiAxNC41NDE4IDcuOTQ5NDMgMTIuNzQxOEwxMi43NDE2IDcuOTVDMTQuNTQxNyA2LjE1MDA2IDE3LjQ1ODMgNi4xNTAwNiAxOS4yNTg0IDcuOTVMMjAuOTQ2NSA5LjYzNzk0TDI1LjYxNDEgNC45NzA2OEwyMy45MjYgMy4yODI3NEMxOS41NDg3IC0xLjA5NDI1IDEyLjQ1MTMgLTEuMDk0MjUgOC4wNzQgMy4yODI3NEwzLjI4Mjk3IDguMDc0NTdDLTEuMDk0MzIgMTIuNDUxNiAtMS4wOTQzMiAxOS41NDg0IDMuMjgyOTcgMjMuOTI1NEw0Ljk2MzAzIDI1LjYwNTRMOS42MzA2MyAyMC45MzgxTDcuOTUwNTcgMTkuMjU4Mkg3Ljk0OTQzWiIgZmlsbD0idXJsKCNwYWludDBfcmFkaWFsXzE4NDRfNTA4MikiLz4KPHBhdGggZD0iTTI4LjcxNjcgOC4wNzQ1N0wyNy4wMjg2IDYuMzg2NjNMMjIuMzYxIDExLjA1MzlMMjQuMDQ5MSAxMi43NDE4QzI1Ljg0OTIgMTQuNTQxOCAyNS44NDkyIDE3LjQ1ODIgMjQuMDQ5MSAxOS4yNTgyTDE4LjI3NzUgMTMuNDg2OUMxNi45ODgzIDEyLjE5NzggMTQuODk5MSAxMi4xOTc4IDEzLjYwOTkgMTMuNDg2OUMxMi4zMjA3IDE0Ljc3NiAxMi4zMjA3IDE2Ljg2NTEgMTMuNjA5OSAxOC4xNTQyTDE5LjM4MTUgMjMuOTI1NEwxOS4yNTY5IDI0LjA1QzE3LjQ1NjkgMjUuODQ5OSAxNC41NDAyIDI1Ljg0OTkgMTIuNzQwMSAyNC4wNUwxMS4wNDQxIDIyLjM1NDFMNi4zNzY0NiAyNy4wMjEzTDguMDcyNTMgMjguNzE3MkMxMi40NDk4IDMzLjA5NDIgMTkuNTQ3MiAzMy4wOTQyIDIzLjkyNDUgMjguNzE3MkwyNC4wNDkxIDI4LjU5MjdMMjguNzE2NyAyMy45MjU0QzMzLjA5NCAxOS41NDg0IDMzLjA5NCAxMi40NTE2IDI4LjcxNjcgOC4wNzQ1N1oiIGZpbGw9InVybCgjcGFpbnQxX3JhZGlhbF8xODQ0XzUwODIpIi8+CjxkZWZzPgo8cmFkaWFsR3JhZGllbnQgaWQ9InBhaW50MF9yYWRpYWxfMTg0NF81MDgyIiBjeD0iMCIgY3k9IjAiIHI9IjEiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiBncmFkaWVudFRyYW5zZm9ybT0idHJhbnNsYXRlKDEyLjc5OTkgNC4yMjg5OSkgcm90YXRlKDkwKSBzY2FsZSgxNy44ODUxIDE3Ljg5MTEpIj4KPHN0b3Agc3RvcC1jb2xvcj0iIzY2RkVGMiIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiMwMENGREMiLz4KPC9yYWRpYWxHcmFkaWVudD4KPHJhZGlhbEdyYWRpZW50IGlkPSJwYWludDFfcmFkaWFsXzE4NDRfNTA4MiIgY3g9IjAiIGN5PSIwIiByPSIxIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgZ3JhZGllbnRUcmFuc2Zvcm09InRyYW5zbGF0ZSgxOS4xODgxIDE5LjE5MzMpIHJvdGF0ZSg5MCkgc2NhbGUoMTIuODA2NyAxMi44MTE2KSI+CjxzdG9wIHN0b3AtY29sb3I9IiNDN0E1RUEiLz4KPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjN0Q0QkEzIi8+CjwvcmFkaWFsR3JhZGllbnQ+CjwvZGVmcz4KPC9zdmc+Cg==",
      homepage: "https://www.mycloudwallet.com",
      download: "https://www.mycloudwallet.com"
    });
    this.url = "https://www.mycloudwallet.com";
    this.autoUrl = "https://idm-api.mycloudwallet.com/v1/accounts/auto-accept";
    this.loginTimeout = 3e5;
    if (options == null ? void 0 : options.supportedChains) {
      this.config.supportedChains = options.supportedChains;
    }
    if (options == null ? void 0 : options.url) {
      this.url = options.url;
    }
    if (options == null ? void 0 : options.autoUrl) {
      this.autoUrl = options.autoUrl;
    }
    if (options == null ? void 0 : options.loginTimeout) {
      this.loginTimeout = options.loginTimeout;
    }
  }
  /**
   * Performs the wallet logic required to login and return the chain and permission level to use.
   *
   * @param options WalletPluginLoginOptions
   * @returns Promise<WalletPluginLoginResponse>
   */
  login(context) {
    const promise = this.waxLogin(context);
    return cancelable(promise, (canceled) => {
      throw canceled;
    });
  }
  async waxLogin(context) {
    if (!context.chain) {
      throw new Error("A chain must be selected to login with.");
    }
    const t = context.ui.getTranslate(this.id);
    let response;
    try {
      context.ui.status(t("connecting", { default: "Connecting to Cloud Wallet" }));
      response = await autoLogin(t, `${this.autoUrl}/login`);
    } catch (e) {
      context.ui.status(t("login.popup", { default: "Login with the Cloud Wallet popup window" }));
      response = await popupLogin(t, `${this.url}/cloud-wallet/login/`);
    }
    if (!response) {
      throw new Error(t("login.error.response", { default: "Cloud Wallet failed to respond" }));
    }
    if (!response.verified) {
      throw new Error(t("error.closed", {
        default: "Cloud Wallet closed before the login was completed"
      }));
    }
    this.data.whitelist = response.whitelistedContracts;
    return new Promise((resolve) => {
      if (!context.chain) {
        throw new Error("A chain must be selected to login with.");
      }
      resolve({
        chain: context.chain.id,
        permissionLevel: PermissionLevel.from({
          actor: response.userAccount,
          permission: "active"
        })
      });
    });
  }
  /**
   * Performs the wallet logic required to sign a transaction and return the signature.
   *
   * @param chain ChainDefinition
   * @param resolved ResolvedSigningRequest
   * @returns Promise<Signature>
   */
  sign(resolved, context) {
    const promise = this.waxSign(resolved, context);
    return cancelable(promise, (canceled) => {
      throw canceled;
    });
  }
  async waxSign(resolved, context) {
    if (!context.ui) {
      throw new Error("A UserInterface must be defined to sign transactions.");
    }
    const t = context.ui.getTranslate(this.id);
    const expiration = resolved.transaction.expiration.toDate();
    const now = /* @__PURE__ */ new Date();
    const timeout = Math.floor(expiration.getTime() - now.getTime());
    const callbackPromise = this.getWalletResponse(resolved, context, t, timeout);
    const promptPromise = context.ui.prompt({
      title: "Sign",
      body: `Please complete the transaction using the Cloud Wallet popup window.`,
      elements: [
        {
          type: "countdown",
          data: expiration.toISOString()
        }
      ]
    });
    const timer = setTimeout(() => {
      if (!context.ui) {
        throw new Error("No UI defined");
      }
      promptPromise.cancel("The request expired, please try again.");
    }, timeout);
    promptPromise.catch(() => clearTimeout(timer));
    const callbackResponse = await Promise.race([callbackPromise, promptPromise]).finally(() => {
      clearTimeout(timer);
    });
    if (isCallback(callbackResponse)) {
      const hasFees = callbackResponse.waxFee || callbackResponse.ramFee;
      if (hasFees) {
        throw new Error("The transaction requires a fee, and the fee interface is not yet implemented.");
      }
      const result = {
        signatures: callbackResponse.signatures
      };
      if (callbackResponse.serializedTransaction) {
        const responseTransaction = Serializer.decode({
          data: callbackResponse.serializedTransaction,
          type: Transaction
        });
        if (!responseTransaction.equals(resolved.transaction)) {
          validateModifications(resolved.transaction, responseTransaction);
          result.request = await SigningRequest.create({
            transaction: responseTransaction
          }, context.esrOptions);
        }
      }
      return new Promise((resolve) => resolve(result));
    }
    throw new Error("The Cloud Wallet failed to respond");
  }
  async getWalletResponse(resolved, context, t, timeout = 3e5) {
    let response;
    if (!context.ui) {
      throw new Error("The Cloud Wallet requires a UI to sign transactions.");
    }
    if (allowAutosign(resolved, this.data)) {
      try {
        context.ui.status(t("connecting", { default: "Connecting to Cloud Wallet" }));
        response = await autoSign(t, `${this.autoUrl}/signing`, resolved);
      } catch (e) {
        context.ui.status(t("transact.popup", { default: "Sign with the Cloud Wallet popup window" }));
        response = await popupTransact(t, `${this.url}/cloud-wallet/signing/`, resolved, timeout);
      }
    } else {
      context.ui.status(t("transact.popup", { default: "Sign with the Cloud Wallet popup window" }));
      response = await popupTransact(t, `${this.url}/cloud-wallet/signing/`, resolved, timeout);
    }
    if (!response) {
      throw new Error(t("login.error.response", { default: "Cloud Wallet failed to respond" }));
    }
    if (!response.verified) {
      throw new Error(t("error.closed", {
        default: "The Cloud Wallet was closed before the request was completed"
      }));
    }
    this.data.whitelist = response.whitelistedContracts;
    return response;
  }
};
function isCallback(object) {
  return "serializedTransaction" in object;
}
export {
  WalletPluginCloudWallet
};
/*! Bundled license information:

@wharfkit/wallet-plugin-cloudwallet/lib/wallet-plugin-cloudwallet.m.js:
  (**
   * @wharfkit/wallet-plugin-cloudwallet v0.4.1
   * https://github.com/wharfkit/wallet-plugin-cloudwallet
   *
   * @license
   * Copyright (c) 2023 Greymass Inc. All Rights Reserved.
   * 
   * Redistribution and use in source and binary forms, with or without modification,
   * are permitted provided that the following conditions are met:
   * 
   * 1.  Redistribution of source code must retain the above copyright notice, this
   *     list of conditions and the following disclaimer.
   * 
   * 2.  Redistribution in binary form must reproduce the above copyright notice,
   *     this list of conditions and the following disclaimer in the documentation
   *     and/or other materials provided with the distribution.
   * 
   * 3.  Neither the name of the copyright holder nor the names of its contributors
   *     may be used to endorse or promote products derived from this software without
   *     specific prior written permission.
   * 
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
   * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
   * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
   * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
   * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
   * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
   * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
   * OF THE POSSIBILITY OF SUCH DAMAGE.
   * 
   * YOU ACKNOWLEDGE THAT THIS SOFTWARE IS NOT DESIGNED, LICENSED OR INTENDED FOR USE
   * IN THE DESIGN, CONSTRUCTION, OPERATION OR MAINTENANCE OF ANY MILITARY FACILITY.
   *)
*/
//# sourceMappingURL=@wharfkit_wallet-plugin-cloudwallet.js.map
