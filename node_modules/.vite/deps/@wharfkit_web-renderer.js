import {
  AbstractUserInterface,
  Canceled,
  cancelable
} from "./chunk-AVHVDXBM.js";
import {
  Name,
  PermissionLevel,
  PublicKey,
  Struct,
  UInt32,
  Weight
} from "./chunk-ASC2VICD.js";
import "./chunk-M7NDEZ3U.js";
import "./chunk-YSRTV47A.js";
import "./chunk-GKWPUQBP.js";

// node_modules/@wharfkit/web-renderer/lib/web-renderer.m.js
function noop() {
}
var identity = (x) => x;
function assign(tar, src) {
  for (const k2 in src)
    tar[k2] = src[k2];
  return tar;
}
function run(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
var src_url_equal_anchor;
function src_url_equal(element_src, url) {
  if (!src_url_equal_anchor) {
    src_url_equal_anchor = document.createElement("a");
  }
  src_url_equal_anchor.href = url;
  return element_src === src_url_equal_anchor.href;
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function subscribe(store, ...callbacks) {
  if (store == null) {
    return noop;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function get_store_value(store) {
  let value;
  subscribe(store, (_2) => value = _2)();
  return value;
}
function component_subscribe(component, store, callback) {
  component.$$.on_destroy.push(subscribe(store, callback));
}
function create_slot(definition, ctx, $$scope, fn) {
  if (definition) {
    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
    return definition[0](slot_ctx);
  }
}
function get_slot_context(definition, ctx, $$scope, fn) {
  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn) {
  if (definition[2] && fn) {
    const lets = definition[2](fn(dirty));
    if ($$scope.dirty === void 0) {
      return lets;
    }
    if (typeof lets === "object") {
      const merged = [];
      const len = Math.max($$scope.dirty.length, lets.length);
      for (let i2 = 0; i2 < len; i2 += 1) {
        merged[i2] = $$scope.dirty[i2] | lets[i2];
      }
      return merged;
    }
    return $$scope.dirty | lets;
  }
  return $$scope.dirty;
}
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
  if (slot_changes) {
    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
    slot.p(slot_context, slot_changes);
  }
}
function get_all_dirty_from_scope($$scope) {
  if ($$scope.ctx.length > 32) {
    const dirty = [];
    const length = $$scope.ctx.length / 32;
    for (let i2 = 0; i2 < length; i2++) {
      dirty[i2] = -1;
    }
    return dirty;
  }
  return -1;
}
function exclude_internal_props(props2) {
  const result = {};
  for (const k2 in props2)
    if (k2[0] !== "$")
      result[k2] = props2[k2];
  return result;
}
function set_store_value(store, ret, value) {
  store.set(value);
  return ret;
}
var is_client = typeof window !== "undefined";
var now = is_client ? () => window.performance.now() : () => Date.now();
var raf = is_client ? (cb) => requestAnimationFrame(cb) : noop;
var tasks = /* @__PURE__ */ new Set();
function run_tasks(now2) {
  tasks.forEach((task) => {
    if (!task.c(now2)) {
      tasks.delete(task);
      task.f();
    }
  });
  if (tasks.size !== 0)
    raf(run_tasks);
}
function loop(callback) {
  let task;
  if (tasks.size === 0)
    raf(run_tasks);
  return {
    promise: new Promise((fulfill) => {
      tasks.add(task = { c: callback, f: fulfill });
    }),
    abort() {
      tasks.delete(task);
    }
  };
}
function append(target, node) {
  target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
  const append_styles_to = get_root_for_style(target);
  if (!append_styles_to.getElementById(style_sheet_id)) {
    const style = element("style");
    style.id = style_sheet_id;
    style.textContent = styles;
    append_stylesheet(append_styles_to, style);
  }
}
function get_root_for_style(node) {
  if (!node)
    return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && root.host) {
    return root;
  }
  return node.ownerDocument;
}
function append_empty_stylesheet(node) {
  const style_element = element("style");
  append_stylesheet(get_root_for_style(node), style_element);
  return style_element.sheet;
}
function append_stylesheet(node, style) {
  append(node.head || node, style);
  return style.sheet;
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function destroy_each(iterations, detaching) {
  for (let i2 = 0; i2 < iterations.length; i2 += 1) {
    if (iterations[i2])
      iterations[i2].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function svg_element(name) {
  return document.createElementNS("http://www.w3.org/2000/svg", name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function prevent_default(fn) {
  return function(event) {
    event.preventDefault();
    return fn.call(this, event);
  };
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.wholeText !== data)
    text2.data = data;
}
function set_input_value(input, value) {
  input.value = value == null ? "" : value;
}
function set_style(node, key, value, important) {
  if (value === null) {
    node.style.removeProperty(key);
  } else {
    node.style.setProperty(key, value, important ? "important" : "");
  }
}
function toggle_class(element2, name, toggle) {
  element2.classList[toggle ? "add" : "remove"](name);
}
function custom_event(type, detail, { bubbles = false, cancelable: cancelable2 = false } = {}) {
  const e = document.createEvent("CustomEvent");
  e.initCustomEvent(type, bubbles, cancelable2, detail);
  return e;
}
function construct_svelte_component(component, props2) {
  return new component(props2);
}
var managed_styles = /* @__PURE__ */ new Map();
var active$1 = 0;
function hash(str) {
  let hash2 = 5381;
  let i2 = str.length;
  while (i2--)
    hash2 = (hash2 << 5) - hash2 ^ str.charCodeAt(i2);
  return hash2 >>> 0;
}
function create_style_information(doc, node) {
  const info = { stylesheet: append_empty_stylesheet(node), rules: {} };
  managed_styles.set(doc, info);
  return info;
}
function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
  const step = 16.666 / duration;
  let keyframes = "{\n";
  for (let p2 = 0; p2 <= 1; p2 += step) {
    const t2 = a + (b - a) * ease(p2);
    keyframes += p2 * 100 + `%{${fn(t2, 1 - t2)}}
`;
  }
  const rule = keyframes + `100% {${fn(b, 1 - b)}}
}`;
  const name = `__svelte_${hash(rule)}_${uid}`;
  const doc = get_root_for_style(node);
  const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);
  if (!rules[name]) {
    rules[name] = true;
    stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
  }
  const animation = node.style.animation || "";
  node.style.animation = `${animation ? `${animation}, ` : ""}${name} ${duration}ms linear ${delay}ms 1 both`;
  active$1 += 1;
  return name;
}
function delete_rule(node, name) {
  const previous = (node.style.animation || "").split(", ");
  const next = previous.filter(
    name ? (anim) => anim.indexOf(name) < 0 : (anim) => anim.indexOf("__svelte") === -1
    // remove all Svelte animations
  );
  const deleted = previous.length - next.length;
  if (deleted) {
    node.style.animation = next.join(", ");
    active$1 -= deleted;
    if (!active$1)
      clear_rules();
  }
}
function clear_rules() {
  raf(() => {
    if (active$1)
      return;
    managed_styles.forEach((info) => {
      const { ownerNode } = info.stylesheet;
      if (ownerNode)
        detach(ownerNode);
    });
    managed_styles.clear();
  });
}
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}
function onDestroy(fn) {
  get_current_component().$$.on_destroy.push(fn);
}
function createEventDispatcher() {
  const component = get_current_component();
  return (type, detail, { cancelable: cancelable2 = false } = {}) => {
    const callbacks = component.$$.callbacks[type];
    if (callbacks) {
      const event = custom_event(type, detail, { cancelable: cancelable2 });
      callbacks.slice().forEach((fn) => {
        fn.call(component, event);
      });
      return !event.defaultPrevented;
    }
    return true;
  };
}
function setContext(key, context) {
  get_current_component().$$.context.set(key, context);
  return context;
}
function getContext(key) {
  return get_current_component().$$.context.get(key);
}
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
function add_flush_callback(fn) {
  flush_callbacks.push(fn);
}
var seen_callbacks = /* @__PURE__ */ new Set();
var flushidx = 0;
function flush() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i2 = 0; i2 < render_callbacks.length; i2 += 1) {
      const callback = render_callbacks[i2];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
var promise;
function wait() {
  if (!promise) {
    promise = Promise.resolve();
    promise.then(() => {
      promise = null;
    });
  }
  return promise;
}
function dispatch(node, direction, kind) {
  node.dispatchEvent(custom_event(`${direction ? "intro" : "outro"}${kind}`));
}
var outroing = /* @__PURE__ */ new Set();
var outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
    // parent group
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  } else if (callback) {
    callback();
  }
}
var null_transition = { duration: 0 };
function create_in_transition(node, fn, params) {
  const options = { direction: "in" };
  let config2 = fn(node, params, options);
  let running = false;
  let animation_name;
  let task;
  let uid = 0;
  function cleanup() {
    if (animation_name)
      delete_rule(node, animation_name);
  }
  function go() {
    const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config2 || null_transition;
    if (css)
      animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
    tick(0, 1);
    const start_time = now() + delay;
    const end_time = start_time + duration;
    if (task)
      task.abort();
    running = true;
    add_render_callback(() => dispatch(node, true, "start"));
    task = loop((now2) => {
      if (running) {
        if (now2 >= end_time) {
          tick(1, 0);
          dispatch(node, true, "end");
          cleanup();
          return running = false;
        }
        if (now2 >= start_time) {
          const t2 = easing((now2 - start_time) / duration);
          tick(t2, 1 - t2);
        }
      }
      return running;
    });
  }
  let started = false;
  return {
    start() {
      if (started)
        return;
      started = true;
      delete_rule(node);
      if (is_function(config2)) {
        config2 = config2(options);
        wait().then(go);
      } else {
        go();
      }
    },
    invalidate() {
      started = false;
    },
    end() {
      if (running) {
        cleanup();
        running = false;
      }
    }
  };
}
function create_bidirectional_transition(node, fn, params, intro) {
  const options = { direction: "both" };
  let config2 = fn(node, params, options);
  let t2 = intro ? 0 : 1;
  let running_program = null;
  let pending_program = null;
  let animation_name = null;
  function clear_animation() {
    if (animation_name)
      delete_rule(node, animation_name);
  }
  function init2(program, duration) {
    const d2 = program.b - t2;
    duration *= Math.abs(d2);
    return {
      a: t2,
      b: program.b,
      d: d2,
      duration,
      start: program.start,
      end: program.start + duration,
      group: program.group
    };
  }
  function go(b) {
    const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config2 || null_transition;
    const program = {
      start: now() + delay,
      b
    };
    if (!b) {
      program.group = outros;
      outros.r += 1;
    }
    if (running_program || pending_program) {
      pending_program = program;
    } else {
      if (css) {
        clear_animation();
        animation_name = create_rule(node, t2, b, duration, delay, easing, css);
      }
      if (b)
        tick(0, 1);
      running_program = init2(program, duration);
      add_render_callback(() => dispatch(node, b, "start"));
      loop((now2) => {
        if (pending_program && now2 > pending_program.start) {
          running_program = init2(pending_program, duration);
          pending_program = null;
          dispatch(node, running_program.b, "start");
          if (css) {
            clear_animation();
            animation_name = create_rule(node, t2, running_program.b, running_program.duration, 0, easing, config2.css);
          }
        }
        if (running_program) {
          if (now2 >= running_program.end) {
            tick(t2 = running_program.b, 1 - t2);
            dispatch(node, running_program.b, "end");
            if (!pending_program) {
              if (running_program.b) {
                clear_animation();
              } else {
                if (!--running_program.group.r)
                  run_all(running_program.group.c);
              }
            }
            running_program = null;
          } else if (now2 >= running_program.start) {
            const p2 = now2 - running_program.start;
            t2 = running_program.a + running_program.d * easing(p2 / running_program.duration);
            tick(t2, 1 - t2);
          }
        }
        return !!(running_program || pending_program);
      });
    }
  }
  return {
    run(b) {
      if (is_function(config2)) {
        wait().then(() => {
          config2 = config2(options);
          go(b);
        });
      } else {
        go(b);
      }
    },
    end() {
      clear_animation();
      running_program = pending_program = null;
    }
  };
}
function get_spread_update(levels, updates) {
  const update2 = {};
  const to_null_out = {};
  const accounted_for = { $$scope: 1 };
  let i2 = levels.length;
  while (i2--) {
    const o = levels[i2];
    const n2 = updates[i2];
    if (n2) {
      for (const key in o) {
        if (!(key in n2))
          to_null_out[key] = 1;
      }
      for (const key in n2) {
        if (!accounted_for[key]) {
          update2[key] = n2[key];
          accounted_for[key] = 1;
        }
      }
      levels[i2] = n2;
    } else {
      for (const key in o) {
        accounted_for[key] = 1;
      }
    }
  }
  for (const key in to_null_out) {
    if (!(key in update2))
      update2[key] = void 0;
  }
  return update2;
}
function get_spread_object(spread_props) {
  return typeof spread_props === "object" && spread_props !== null ? spread_props : {};
}
function bind(component, name, callback) {
  const index = component.$$.props[name];
  if (index !== void 0) {
    component.$$.bound[index] = callback;
    callback(component.$$.ctx[index]);
  }
}
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor, customElement) {
  const { fragment, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  if (!customElement) {
    add_render_callback(() => {
      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
      if (component.$$.on_destroy) {
        component.$$.on_destroy.push(...new_on_destroy);
      } else {
        run_all(new_on_destroy);
      }
      component.$$.on_mount = [];
    });
  }
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i2) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i2 / 31 | 0] |= 1 << i2 % 31;
}
function init(component, options, instance2, create_fragment2, not_equal, props2, append_styles2, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    // state
    props: props2,
    update: noop,
    not_equal,
    bound: blank_object(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    // everything else
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles2 && append_styles2($$.root);
  let ready = false;
  $$.ctx = instance2 ? instance2(component, options.props || {}, (i2, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i2], $$.ctx[i2] = value)) {
      if (!$$.skip_bound && $$.bound[i2])
        $$.bound[i2](value);
      if (ready)
        make_dirty(component, i2);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment2 ? create_fragment2($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor, options.customElement);
    flush();
  }
  set_current_component(parent_component);
}
var SvelteComponent = class {
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  $on(type, callback) {
    if (!is_function(callback)) {
      return noop;
    }
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  $set($$props) {
    if (this.$$set && !is_empty($$props)) {
      this.$$.skip_bound = true;
      this.$$set($$props);
      this.$$.skip_bound = false;
    }
  }
};
var subscriber_queue = [];
function readable(value, start) {
  return {
    subscribe: writable(value, start).subscribe
  };
}
function writable(value, start = noop) {
  let stop;
  const subscribers = /* @__PURE__ */ new Set();
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i2 = 0; i2 < subscriber_queue.length; i2 += 2) {
            subscriber_queue[i2][0](subscriber_queue[i2 + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn) {
    set(fn(value));
  }
  function subscribe2(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set) || noop;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update: update2, subscribe: subscribe2 };
}
function derived(stores, fn, initial_value) {
  const single = !Array.isArray(stores);
  const stores_array = single ? [stores] : stores;
  const auto = fn.length < 2;
  return readable(initial_value, (set) => {
    let inited = false;
    const values = [];
    let pending = 0;
    let cleanup = noop;
    const sync = () => {
      if (pending) {
        return;
      }
      cleanup();
      const result = fn(single ? values[0] : values, set);
      if (auto) {
        set(result);
      } else {
        cleanup = is_function(result) ? result : noop;
      }
    };
    const unsubscribers = stores_array.map((store, i2) => subscribe(store, (value) => {
      values[i2] = value;
      pending &= ~(1 << i2);
      if (inited) {
        sync();
      }
    }, () => {
      pending |= 1 << i2;
    }));
    inited = true;
    sync();
    return function stop() {
      run_all(unsubscribers);
      cleanup();
    };
  });
}
var q$1 = Object.defineProperty;
var B$1 = Object.defineProperties;
var G$1 = Object.getOwnPropertyDescriptors;
var S$1 = Object.getOwnPropertySymbols;
var N$1 = Object.prototype.hasOwnProperty;
var A$1 = Object.prototype.propertyIsEnumerable;
var j = (s2, e, t2) => e in s2 ? q$1(s2, e, { enumerable: true, configurable: true, writable: true, value: t2 }) : s2[e] = t2;
var n$1 = (s2, e) => {
  for (var t2 in e || (e = {}))
    N$1.call(e, t2) && j(s2, t2, e[t2]);
  if (S$1)
    for (var t2 of S$1(e))
      A$1.call(e, t2) && j(s2, t2, e[t2]);
  return s2;
};
var d$2 = (s2, e) => B$1(s2, G$1(e));
var m$1 = (s2, e) => {
  var t2 = {};
  for (var r in s2)
    N$1.call(s2, r) && e.indexOf(r) < 0 && (t2[r] = s2[r]);
  if (s2 != null && S$1)
    for (var r of S$1(s2))
      e.indexOf(r) < 0 && A$1.call(s2, r) && (t2[r] = s2[r]);
  return t2;
};
var R$1 = ["error", "warn", "debug"];
var F = ({ logger: s2 = console, level: e = R$1[1], prefix: t2 = "[i18n]: " }) => R$1.reduce((r, a, o) => d$2(n$1({}, r), { [a]: (i2) => R$1.indexOf(e) >= o && s2[a](`${t2}${i2}`) }), {});
var l$1 = F({});
var E$1 = (s2) => {
  l$1 = s2;
};
var O$1 = (g) => {
  var u2 = g, { parser: s2, key: e, params: t2, translations: r, locale: a, fallbackLocale: o } = u2, i2 = m$1(u2, ["parser", "key", "params", "translations", "locale", "fallbackLocale"]);
  if (!(e && a))
    return l$1.warn("No translation key or locale provided. Skipping translation..."), "";
  let p2 = (r[a] || {})[e];
  return o && p2 === void 0 && (p2 = (r[o] || {})[e]), i2.hasOwnProperty("fallbackValue") && p2 === void 0 ? i2.fallbackValue : s2.parse(p2, t2, a, e);
};
var f$1 = (...s2) => s2.length ? s2.filter((e) => !!e).map((e) => {
  let t2 = `${e}`.toLowerCase();
  try {
    let [r] = Intl.Collator.supportedLocalesOf(e);
    if (!r)
      throw new Error(`'${e}' is non-standard.`);
    t2 = r;
  } catch {
    l$1.warn(`Non-standard locale provided: '${e}'. Check your 'translations' and 'loaders' in i18n config...`);
  }
  return t2;
}) : [];
var w$1 = (s2, e) => Object.keys(s2 || {}).reduce((t2, r) => {
  let a = s2[r], o = e ? `${e}.${r}` : `${r}`;
  return a && typeof a == "object" ? n$1(n$1({}, t2), w$1(a, o)) : d$2(n$1({}, t2), { [o]: a });
}, {});
var W$1 = async (s2) => {
  try {
    return (await Promise.all(s2.map((a) => {
      var o = a, { loader: t2 } = o, r = m$1(o, ["loader"]);
      return new Promise(async (i2) => {
        let g;
        try {
          g = await t2();
        } catch (u2) {
          l$1.error(`Failed to load translation. Verify your '${r.locale}' > '${r.key}' Loader.`), l$1.error(u2);
        }
        i2(d$2(n$1({ loader: t2 }, r), { data: g }));
      });
    }))).reduce((t2, { key: r, data: a, locale: o }) => {
      if (!a)
        return t2;
      let [i2] = f$1(o);
      return d$2(n$1({}, t2), { [i2]: w$1(d$2(n$1({}, t2[i2] || {}), { [r]: a })) });
    }, {});
  } catch (e) {
    l$1.error(e);
  }
  return {};
};
var D$1 = (s2) => (e) => {
  try {
    if (typeof e == "string")
      return e === s2;
    if (typeof e == "object")
      return e.test(s2);
  } catch {
    l$1.error("Invalid route config!");
  }
  return false;
};
var I = (s2, e) => {
  let t2 = true;
  try {
    t2 = Object.keys(s2).filter((r) => s2[r] !== void 0).every((r) => s2[r] === e[r]);
  } catch {
  }
  return t2;
};
var H$1 = 1e3 * 60 * 60 * 24;
var z$1 = class {
  constructor(e) {
    this.cachedAt = 0;
    this.loadedKeys = {};
    this.currentRoute = writable();
    this.config = writable();
    this.isLoading = writable(false);
    this.promises = /* @__PURE__ */ new Set();
    this.loading = { subscribe: this.isLoading.subscribe, toPromise: (e2, t2) => {
      let r = Array.from(this.promises).filter((a) => I({ locale: f$1(e2)[0], route: t2 }, a)).map(({ promise: a }) => a);
      return Promise.all(r);
    }, get: () => get_store_value(this.isLoading) };
    this.privateTranslations = writable({});
    this.translations = { subscribe: this.privateTranslations.subscribe, get: () => get_store_value(this.translations) };
    this.locales = d$2(n$1({}, derived([this.config, this.privateTranslations], ([e2, t2]) => {
      if (!e2)
        return [];
      let { loaders: r = [] } = e2, a = r.map(({ locale: i2 }) => i2), o = Object.keys(t2).map((i2) => i2);
      return Array.from(/* @__PURE__ */ new Set([...f$1(...a), ...f$1(...o)]));
    }, [])), { get: () => get_store_value(this.locales) });
    this.internalLocale = writable();
    this.loaderTrigger = derived([this.internalLocale, this.currentRoute], ([e2, t2], r) => {
      var a, o;
      e2 !== void 0 && t2 !== void 0 && !(e2 === ((a = get_store_value(this.loaderTrigger)) == null ? void 0 : a[0]) && t2 === ((o = get_store_value(this.loaderTrigger)) == null ? void 0 : o[1])) && (l$1.debug("Triggering translation load..."), r([e2, t2]));
    }, []);
    this.localeHelper = writable();
    this.locale = { subscribe: this.localeHelper.subscribe, forceSet: this.localeHelper.set, set: this.internalLocale.set, update: this.internalLocale.update, get: () => get_store_value(this.locale) };
    this.initialized = derived([this.locale, this.currentRoute, this.privateTranslations], ([e2, t2, r], a) => {
      get_store_value(this.initialized) || a(e2 !== void 0 && t2 !== void 0 && !!Object.keys(r).length);
    });
    this.translation = derived([this.privateTranslations, this.locale, this.isLoading], ([e2, t2, r], a) => {
      let o = e2[t2];
      o && Object.keys(o).length && !r && a(o);
    }, {});
    this.t = d$2(n$1({}, derived([this.config, this.translation], (a) => {
      var [o] = a, i2 = o, { parser: e2, fallbackLocale: t2 } = i2, r = m$1(i2, ["parser", "fallbackLocale"]);
      return (g, ...u2) => O$1(n$1({ parser: e2, key: g, params: u2, translations: this.translations.get(), locale: this.locale.get(), fallbackLocale: t2 }, r.hasOwnProperty("fallbackValue") ? { fallbackValue: r.fallbackValue } : {}));
    })), { get: (e2, ...t2) => get_store_value(this.t)(e2, ...t2) });
    this.l = d$2(n$1({}, derived([this.config, this.translations], (o) => {
      var [i2, ...g] = o, u2 = i2, { parser: e2, fallbackLocale: t2 } = u2, r = m$1(u2, ["parser", "fallbackLocale"]), [a] = g;
      return (p2, v2, ...k2) => O$1(n$1({ parser: e2, key: v2, params: k2, translations: a, locale: p2, fallbackLocale: t2 }, r.hasOwnProperty("fallbackValue") ? { fallbackValue: r.fallbackValue } : {}));
    })), { get: (e2, t2, ...r) => get_store_value(this.l)(e2, t2, ...r) });
    this.getLocale = (e2) => {
      let { fallbackLocale: t2 = "" } = get_store_value(this.config) || {}, r = e2 || t2;
      if (!r)
        return "";
      let a = this.locales.get();
      return a.find((i2) => f$1(r).includes(i2)) || a.find((i2) => f$1(t2).includes(i2)) || "";
    };
    this.setLocale = (e2) => {
      if (!!e2 && e2 !== get_store_value(this.internalLocale))
        return l$1.debug(`Setting '${e2}' locale.`), this.internalLocale.set(e2), this.loading.toPromise(e2, get_store_value(this.currentRoute));
    };
    this.setRoute = (e2) => {
      if (e2 !== get_store_value(this.currentRoute)) {
        l$1.debug(`Setting '${e2}' route.`), this.currentRoute.set(e2);
        let t2 = get_store_value(this.internalLocale);
        return this.loading.toPromise(t2, e2);
      }
    };
    this.loadConfig = async (e2) => {
      await this.configLoader(e2);
    };
    this.getTranslationProps = async (e2 = this.locale.get(), t2 = get_store_value(this.currentRoute)) => {
      let r = get_store_value(this.config);
      if (!r || !e2)
        return [];
      let a = this.translations.get(), { loaders: o, fallbackLocale: i2 = "", cache: g = H$1 } = r || {}, u2 = Number.isNaN(+g) ? H$1 : +g;
      this.cachedAt ? Date.now() > u2 + this.cachedAt && (l$1.debug("Refreshing cache."), this.loadedKeys = {}, this.cachedAt = 0) : (l$1.debug("Setting cache timestamp."), this.cachedAt = Date.now());
      let [p2, v2] = f$1(e2, i2), k2 = a[p2], M2 = a[v2], C2 = (o || []).map((K) => {
        var L = K, { locale: h2 } = L, b = m$1(L, ["locale"]);
        return d$2(n$1({}, b), { locale: f$1(h2)[0] });
      }).filter(({ routes: h2 }) => !h2 || (h2 || []).some(D$1(t2))).filter(({ key: h2, locale: b }) => b === p2 && (!k2 || !(this.loadedKeys[p2] || []).includes(h2)) || i2 && b === v2 && (!M2 || !(this.loadedKeys[v2] || []).includes(h2)));
      if (C2.length) {
        this.isLoading.set(true), l$1.debug("Fetching translations...");
        let h2 = await W$1(C2);
        this.isLoading.set(false);
        let b = Object.keys(h2).reduce((L, y) => d$2(n$1({}, L), { [y]: Object.keys(h2[y]) }), {}), K = C2.filter(({ key: L, locale: y }) => (b[y] || []).some((x) => `${x}`.startsWith(L))).reduce((L, { key: y, locale: x }) => d$2(n$1({}, L), { [x]: [...L[x] || [], y] }), {});
        return [h2, K];
      }
      return [];
    };
    this.addTranslations = (e2, t2) => {
      if (!e2)
        return;
      l$1.debug("Adding translations...");
      let r = Object.keys(e2 || {});
      this.privateTranslations.update((a) => r.reduce((o, i2) => d$2(n$1({}, o), { [i2]: n$1(n$1({}, o[i2] || {}), w$1(e2[i2])) }), a)), r.forEach((a) => {
        let o = Object.keys(e2[a]).map((i2) => `${i2}`.split(".")[0]);
        t2 && (o = t2[a]), this.loadedKeys[a] = Array.from(/* @__PURE__ */ new Set([...this.loadedKeys[a] || [], ...o || []]));
      });
    };
    this.loader = async ([e2, t2]) => {
      let r = this.getLocale(e2);
      l$1.debug(`Adding loader promise for '${r}' locale and '${t2}' route.`);
      let a = (async () => {
        let o = await this.getTranslationProps(r, t2);
        o.length && this.addTranslations(...o);
      })();
      this.promises.add({ locale: r, route: t2, promise: a }), a.then(() => {
        r && this.locale.get() !== r && this.locale.forceSet(r);
      });
    };
    this.loadTranslations = (e2, t2 = get_store_value(this.currentRoute) || "") => {
      let r = this.getLocale(e2);
      if (!!r)
        return this.setRoute(t2), this.setLocale(r), this.loading.toPromise(r, t2);
    };
    this.loaderTrigger.subscribe(this.loader), this.isLoading.subscribe(async (t2) => {
      t2 && this.promises.size && (await this.loading.toPromise(), this.promises.clear(), l$1.debug("Loader promises have been purged."));
    }), e && this.loadConfig(e);
  }
  async configLoader(e) {
    if (!e)
      return l$1.error("No config provided!");
    let g = e, { initLocale: t2, fallbackLocale: r, translations: a, log: o } = g, i2 = m$1(g, ["initLocale", "fallbackLocale", "translations", "log"]);
    o && E$1(F(o)), [t2] = f$1(t2), [r] = f$1(r), l$1.debug("Setting config."), this.config.set(n$1({ initLocale: t2, fallbackLocale: r, translations: a }, i2)), a && this.addTranslations(a), await this.loadTranslations(t2);
  }
};
var R = Object.defineProperty;
var E = Object.defineProperties;
var v$1 = Object.getOwnPropertyDescriptors;
var k = Object.getOwnPropertySymbols;
var C = Object.prototype.hasOwnProperty;
var O = Object.prototype.propertyIsEnumerable;
var w = (t2, e, r) => e in t2 ? R(t2, e, { enumerable: true, configurable: true, writable: true, value: r }) : t2[e] = r;
var u$1 = (t2, e) => {
  for (var r in e || (e = {}))
    C.call(e, r) && w(t2, r, e[r]);
  if (k)
    for (var r of k(e))
      O.call(e, r) && w(t2, r, e[r]);
  return t2;
};
var $ = (t2, e) => E(t2, v$1(e));
var d$1 = (t2, e) => {
  var r = {};
  for (var i2 in t2)
    C.call(t2, i2) && e.indexOf(i2) < 0 && (r[i2] = t2[i2]);
  if (t2 != null && k)
    for (var i2 of k(t2))
      e.indexOf(i2) < 0 && O.call(t2, i2) && (r[i2] = t2[i2]);
  return r;
};
var z = (t2, e) => {
  for (var r in e)
    R(t2, r, { get: e[r], enumerable: true });
};
var h = {};
z(h, { ago: () => X, date: () => Q, eq: () => p$1, gt: () => q, gte: () => H, lt: () => U, lte: () => G, ne: () => B, number: () => J });
var T = (t2, e) => {
  let { modifierDefaults: r } = e || {}, { [t2]: i2 } = r || {};
  return i2 || {};
};
var p$1 = ({ value: t2, options: e = [], defaultValue: r = "" }) => (e.find(({ key: i2 }) => `${i2}`.toLowerCase() === `${t2}`.toLowerCase()) || {}).value || r;
var B = ({ value: t2, options: e = [], defaultValue: r = "" }) => (e.find(({ key: i2 }) => `${i2}`.toLowerCase() !== `${t2}`.toLowerCase()) || {}).value || r;
var U = ({ value: t2, options: e = [], defaultValue: r = "" }) => (e.sort((o, n2) => +o.key - +n2.key).find(({ key: o }) => +t2 < +o) || {}).value || r;
var q = ({ value: t2, options: e = [], defaultValue: r = "" }) => (e.sort((o, n2) => +n2.key - +o.key).find(({ key: o }) => +t2 > +o) || {}).value || r;
var G = ({ value: t2, options: e = [], defaultValue: r = "" }) => p$1({ value: t2, options: e, defaultValue: U({ value: t2, options: e, defaultValue: r }) });
var H = ({ value: t2, options: e = [], defaultValue: r = "" }) => p$1({ value: t2, options: e, defaultValue: q({ value: t2, options: e, defaultValue: r }) });
var J = ({ value: t2, props: e, defaultValue: r = "", locale: i2 = "", parserOptions: o }) => {
  if (!i2)
    return "";
  let s2 = T("number", o), { maximumFractionDigits: n2 } = s2, m2 = d$1(s2, ["maximumFractionDigits"]), c = (e == null ? void 0 : e.number) || {}, { maximumFractionDigits: f2 = n2 || 2 } = c, a = d$1(c, ["maximumFractionDigits"]);
  return new Intl.NumberFormat(i2, u$1($(u$1({}, m2), { maximumFractionDigits: f2 }), a)).format(+t2 || +r);
};
var Q = ({ value: t2, props: e, defaultValue: r = "", locale: i2 = "", parserOptions: o }) => {
  if (!i2)
    return "";
  let n2 = d$1(T("date", o), []), m2 = d$1((e == null ? void 0 : e.date) || {}, []);
  return new Intl.DateTimeFormat(i2, u$1(u$1({}, n2), m2)).format(+t2 || +r);
};
var P$1 = [{ key: "second", multiplier: 1e3 }, { key: "minute", multiplier: 60 }, { key: "hour", multiplier: 60 }, { key: "day", multiplier: 24 }, { key: "week", multiplier: 7 }, { key: "month", multiplier: 13 / 3 }, { key: "year", multiplier: 12 }];
var N = (t2 = "", e = "") => new RegExp(`^${t2}s?$`).test(e);
var S = (t2) => P$1.indexOf(P$1.find(({ key: e }) => N(e, t2)));
var W = (t2, e) => P$1.reduce(([r, i2], { key: o, multiplier: n2 }, m2) => {
  if (N(i2, e))
    return [r, i2];
  if (!i2 || m2 === S(i2) + 1) {
    let f2 = Math.round(r / n2);
    if (!i2 || Math.abs(f2) >= 1 || e !== "auto")
      return [f2, o];
  }
  return [r, i2];
}, [t2, ""]);
var X = ({ value: t2, defaultValue: e = "", locale: r = "", props: i2, parserOptions: o }) => {
  if (!r)
    return "";
  let g = T("ago", o), { format: n2, numeric: m2 } = g, f2 = d$1(g, ["format", "numeric"]), l2 = (i2 == null ? void 0 : i2.ago) || {}, { format: a = n2 || "auto", numeric: s2 = m2 || "auto" } = l2, c = d$1(l2, ["format", "numeric"]), x = +t2 || +e, M2 = W(x, a);
  return new Intl.RelativeTimeFormat(r, u$1($(u$1({}, f2), { numeric: s2 }), c)).format(...M2);
};
var Y = (t2) => typeof t2 == "string" && /{{(?:(?!{{|}}).)+}}/.test(t2);
var D = (t2) => typeof t2 == "string" ? t2.replace(/\\(?=:|;|{|})/g, "") : t2;
var Z = ({ value: t2, props: e, payload: r, parserOptions: i2, locale: o }) => `${t2}`.replace(/{{\s*(?:(?!{{|}}).)+\s*}}/g, (n2) => {
  let m2 = D(`${n2.match(/(?!{|\s).+?(?!\\[:;]).(?=\s*(?:[:;]|}}$))/)}`), f2 = r == null ? void 0 : r[m2], [, a = ""] = n2.match(/.+?(?!\\;).;\s*default\s*:\s*([^\s:;].+?(?:\\[:;]|[^;\s}])*)(?=\s*(?:;|}}$))/i) || [];
  a = a || (r == null ? void 0 : r.default) || "";
  let [, s2 = ""] = n2.match(/{{\s*(?:[^;]|(?:\\;))+\s*(?:(?!\\:).[:])\s*(?!\s)((?:\\;|[^;])+?)(?=\s*(?:[;]|}}$))/i) || [];
  if (f2 === void 0 && s2 !== "ne")
    return a;
  let c = !!s2, { customModifiers: x } = i2 || {}, M2 = u$1(u$1({}, h), x || {});
  s2 = Object.keys(M2).includes(s2) ? s2 : "eq";
  let g = M2[s2], l2 = (n2.match(/[^\s:;{](?:[^;]|\\[;])+[^\s:;}]/gi) || []).reduce((F2, b, j2) => {
    if (j2 > 0) {
      let y = D(`${b.match(/(?:(?:\\:)|[^:])+/)}`.trim()), I2 = `${b.match(/(?:(?:\\:)|[^:])+$/)}`.trim();
      if (y && y !== "default" && I2)
        return [...F2, { key: y, value: I2 }];
    }
    return F2;
  }, []);
  return !c && !l2.length ? f2 : g({ value: f2, options: l2, props: e, defaultValue: a, locale: o, parserOptions: i2 });
});
var A = ({ value: t2, props: e, payload: r, parserOptions: i2, locale: o }) => {
  if (Y(t2)) {
    let n2 = Z({ value: t2, payload: r, props: e, parserOptions: i2, locale: o });
    return A({ value: n2, payload: r, props: e, parserOptions: i2, locale: o });
  } else
    return D(t2);
};
var _ = (t2) => ({ parse: (e, [r, i2], o, n2) => ((r == null ? void 0 : r.default) && e === void 0 && (e = `${r.default}`), e === void 0 && (e = `${n2}`), A({ value: e, payload: r, props: i2, parserOptions: t2, locale: o })) });
var rt = _;
var n = Object.defineProperty;
var M = Object.defineProperties;
var u = Object.getOwnPropertyDescriptors;
var s = Object.getOwnPropertySymbols;
var f = Object.prototype.hasOwnProperty;
var P = Object.prototype.propertyIsEnumerable;
var i = (r, o, e) => o in r ? n(r, o, { enumerable: true, configurable: true, writable: true, value: e }) : r[o] = e;
var p = (r, o) => {
  for (var e in o || (o = {}))
    f.call(o, e) && i(r, e, o[e]);
  if (s)
    for (var e of s(o))
      P.call(o, e) && i(r, e, o[e]);
  return r;
};
var d = (r, o) => M(r, u(o));
var l = (r, o) => {
  var e = {};
  for (var a in r)
    f.call(r, a) && o.indexOf(a) < 0 && (e[a] = r[a]);
  if (r != null && s)
    for (var a of s(r))
      o.indexOf(a) < 0 && P.call(r, a) && (e[a] = r[a]);
  return e;
};
var m = (e) => {
  var a = e, { parserOptions: r = {} } = a, o = l(a, ["parserOptions"]);
  return d(p({}, o), { parser: rt(r) });
};
var t = class extends z$1 {
  constructor(e) {
    super(e && m(e));
    this.loadConfig = (e2) => super.configLoader(m(e2));
  }
};
var v = t;
var en$1 = "English";
var kr = "한국어";
var zh = "中文";
var lang = {
  en: en$1,
  kr,
  zh,
  "zh-Hans": "中文简体",
  "zh-Hant": "中文繁体"
};
var accept$3 = "Accept";
var cancel$3 = "Cancel";
var close$3 = "Close";
var decline$3 = "Decline";
var error$3 = {
  title: "Error",
  subtitle: "An Error happened."
};
var loading$3 = "Loading...";
var login$3 = {
  complete: "Complete the login using your selected wallet.",
  enter: {
    account: "Enter account name",
    lookup: "Lookup Account",
    not_found: "Unable to find account"
  },
  select: {
    account: "Select an Account",
    blockchain: "Select a Blockchain",
    wallet: "Select a Wallet",
    no_match: "No accounts found matching {{publicKey}}"
  },
  title: "Login",
  subtitle: "Please login to continue",
  "title-app": "{{appName}}"
};
var transact$3 = {
  title: "Transact",
  subtitle: " ",
  processing: "Processing transaction...",
  signing: "Signing transaction",
  signed: "Transaction signed",
  broadcasting: "Broadcasting transaction",
  broadcasted: "Transaction broadcasted!"
};
var en = {
  accept: accept$3,
  cancel: cancel$3,
  close: close$3,
  decline: decline$3,
  error: error$3,
  loading: loading$3,
  login: login$3,
  transact: transact$3
};
var accept$2 = "받아들이다";
var cancel$2 = "취소";
var close$2 = "닫다";
var decline$2 = "거절하다";
var error$2 = {
  title: "오류",
  subtitle: "오류가 발생했습니다."
};
var loading$2 = "로드...";
var login$2 = {
  complete: "선택한 지갑을 사용하여 로그인을 완료합니다.",
  enter: {
    account: "Enter account name",
    lookup: "Lookup Account",
    not_found: "Unable to find account"
  },
  select: {
    account: "계정 선택",
    blockchain: "블록체인 선택",
    wallet: "지갑 선택",
    no_match: "{{publicKey}}와 일치하는 계정을 찾을 수 없습니다."
  },
  title: "로그인",
  subtitle: "계속하려면 로그인하십시오",
  "title-app": "{{appName}}에 로그인"
};
var transact$2 = {
  title: "거래하다",
  subtitle: " ",
  processing: "Processing transaction...",
  signing: "서명 트랜잭션",
  signed: "트랜잭션 서명",
  broadcasting: "방송 거래",
  broadcasted: "거래 방송"
};
var ko = {
  accept: accept$2,
  cancel: cancel$2,
  close: close$2,
  decline: decline$2,
  error: error$2,
  loading: loading$2,
  login: login$2,
  transact: transact$2
};
var accept$1 = "接受";
var cancel$1 = "取消";
var close$1 = "关闭";
var decline$1 = "下降";
var error$1 = {
  title: "错误",
  subtitle: "发生错误。"
};
var loading$1 = "加载中。。。";
var login$1 = {
  complete: "使用您选择的钱包完成登陆。",
  enter: {
    account: "Enter account name",
    lookup: "Lookup Account",
    not_found: "Unable to find account"
  },
  select: {
    account: "选择一个帐户",
    blockchain: "选择一个区块链",
    wallet: "选择一个钱包",
    no_match: "未找到与 {{publicKey}} 匹配的帐户。"
  },
  title: "登陆",
  subtitle: "请登陆以继续",
  "title-app": "登陆到 {{appName}}"
};
var transact$1 = {
  title: "办理",
  subtitle: " ",
  processing: "Processing transaction...",
  signing: "签署交易",
  signed: "交易已签署",
  broadcasting: "广播交易",
  broadcasted: "交易广播"
};
var zh_hans = {
  accept: accept$1,
  cancel: cancel$1,
  close: close$1,
  decline: decline$1,
  error: error$1,
  loading: loading$1,
  login: login$1,
  transact: transact$1
};
var accept = "接受";
var cancel = "取消";
var close = "關閉";
var decline = "下降";
var error = {
  title: "錯誤",
  subtitle: "發生錯誤。"
};
var loading = "裝載。。。";
var login = {
  complete: "使用您選擇的錢包完成登錄。",
  enter: {
    account: "Enter account name",
    lookup: "Lookup Account",
    not_found: "Unable to find account"
  },
  select: {
    account: "選擇一個帳戶",
    blockchain: "選擇一個區塊鏈",
    wallet: "選擇一個錢包",
    no_match: "未找到與 {{publicKey}} 匹配的帳戶。"
  },
  title: "登錄",
  subtitle: "請登錄以繼續",
  "title-app": "登錄到 {{appName}}"
};
var transact = {
  title: "辦理",
  subtitle: "",
  processing: "Processing transaction...",
  signing: "簽署交易",
  signed: "交易已簽署",
  broadcasting: "廣播交易",
  broadcasted: "交易廣播"
};
var zh_hant = {
  accept,
  cancel,
  close,
  decline,
  error,
  loading,
  login,
  transact
};
var translations = {
  en: { ...lang, ...en },
  ko: { ...lang, ...ko },
  zh: { ...lang, ...zh_hans },
  "zh-Hans": { ...lang, ...zh_hans },
  "zh-Hant": { ...lang, ...zh_hant }
};
var config = {
  initLocale: "en",
  translations
};
var makeLocalization = (options = {}) => {
  const params = {
    ...config,
    ...options
  };
  return new v(params);
};
new v(config);
function add_css$l(target) {
  append_styles(target, "svelte-1odcxqq", "div.svelte-1odcxqq{display:flex;flex-direction:column;align-items:center;gap:var(--space-s);text-align:center;color:var(--body-text-color);margin-block:var(--space-s)}svg.svelte-1odcxqq{--size:var(--space-3xl);width:var(--size);height:var(--size);stroke:var(--color-error-2)}h2.svelte-1odcxqq{color:var(--body-text-color);font-size:var(--fs-3);font-weight:600;margin:0}p.svelte-1odcxqq{color:var(--body-text-color);font-size:var(--fs-1);font-weight:400;margin:0;max-width:var(--measure)}");
}
function create_fragment$D(ctx) {
  let div;
  let svg;
  let polygon;
  let line0;
  let line1;
  let t0;
  let h2;
  let t1;
  let t2;
  let p2;
  let t3;
  return {
    c() {
      div = element("div");
      svg = svg_element("svg");
      polygon = svg_element("polygon");
      line0 = svg_element("line");
      line1 = svg_element("line");
      t0 = space();
      h2 = element("h2");
      t1 = text(
        /*title*/
        ctx[0]
      );
      t2 = space();
      p2 = element("p");
      t3 = text(
        /*details*/
        ctx[1]
      );
      attr(polygon, "points", "7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2");
      attr(line0, "x1", "15");
      attr(line0, "y1", "9");
      attr(line0, "x2", "9");
      attr(line0, "y2", "15");
      attr(line1, "x1", "9");
      attr(line1, "y1", "9");
      attr(line1, "x2", "15");
      attr(line1, "y2", "15");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "fill", "none");
      attr(svg, "stroke", "currentColor");
      attr(svg, "stroke-width", "2");
      attr(svg, "stroke-linecap", "round");
      attr(svg, "stroke-linejoin", "round");
      attr(svg, "class", "svelte-1odcxqq");
      attr(h2, "class", "svelte-1odcxqq");
      attr(p2, "class", "svelte-1odcxqq");
      attr(div, "class", "svelte-1odcxqq");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, svg);
      append(svg, polygon);
      append(svg, line0);
      append(svg, line1);
      append(div, t0);
      append(div, h2);
      append(h2, t1);
      append(div, t2);
      append(div, p2);
      append(p2, t3);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*title*/
      1)
        set_data(
          t1,
          /*title*/
          ctx2[0]
        );
      if (dirty & /*details*/
      2)
        set_data(
          t3,
          /*details*/
          ctx2[1]
        );
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function instance$u($$self, $$props, $$invalidate) {
  let { title } = $$props;
  let { details } = $$props;
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
    if ("details" in $$props2)
      $$invalidate(1, details = $$props2.details);
  };
  return [title, details];
}
var ErrorMessage = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$u, create_fragment$D, safe_not_equal, { title: 0, details: 1 }, add_css$l);
  }
};
function isUrlImage(str) {
  return str.startsWith("http://") || str.startsWith("https://");
}
function isBase64Image(str) {
  return str.startsWith("data:image/");
}
function getThemedLogo(metadata) {
  var _a, _b;
  const { name, logo } = metadata;
  const theme = get_store_value(colorScheme);
  const oppositeColorScheme = theme === "light" ? "dark" : "light";
  if (!logo) {
    if ("getLogo" in metadata) {
      return ((_a = metadata.getLogo()) == null ? void 0 : _a[theme]) ?? ((_b = metadata.getLogo()) == null ? void 0 : _b[oppositeColorScheme]);
    }
    console.warn(`${name} does not have a logo.`);
    return;
  }
  if (!isUrlImage(logo.toString()) && !isBase64Image(logo.toString())) {
    console.warn(`${name} ${theme} logo is not a supported image format.`);
    return;
  }
  return logo[theme] ?? logo[oppositeColorScheme];
}
function getStoredColorScheme() {
  return localStorage.getItem("colorScheme");
}
function resetState() {
  active.set(false);
  props.set({ ...defaultUserInterfaceProps });
  router.set({ ...defaultUserInterfaceRouter });
  prompt.reset();
  cancelablePromises.set([]);
  transactContext.set(void 0);
  loginContext.set(void 0);
  loginPromise.set(void 0);
  loginResponse.set({ ...defaultLoginResponse });
  errorDetails.set(void 0);
  backAction.set(void 0);
}
var active = writable(false);
var defaultUserInterfaceProps = {
  language: "en",
  subtitle: "Status Message",
  title: "Wharf"
};
var props = writable(defaultUserInterfaceProps);
var defaultUserInterfaceRouter = {
  path: "",
  history: []
};
var initRouter = () => {
  const { set, subscribe: subscribe2, update: update2 } = writable(defaultUserInterfaceRouter);
  return {
    // Method to go one back in history
    back: () => update2((current) => ({
      ...current,
      path: current.history[current.history.length - 1],
      history: current.history.slice(0, -1)
    })),
    // Push a new path on to history
    push: (path) => update2((current) => ({
      ...current,
      path,
      history: [...current.history, current.path]
    })),
    set,
    subscribe: subscribe2,
    update: update2
  };
};
var router = initRouter();
var cancelablePromises = writable([]);
var transactContext = writable(void 0);
var initPrompt = () => {
  const { set, subscribe: subscribe2, update: update2 } = writable(void 0);
  return {
    reset: () => set(void 0),
    set,
    subscribe: subscribe2,
    update: update2
  };
};
var prompt = initPrompt();
var defaultLoginResponse = {
  chainId: void 0,
  permissionLevel: void 0,
  walletPluginIndex: void 0
};
var loginContext = writable(void 0);
var loginPromise = writable(void 0);
var loginResponse = writable({ ...defaultLoginResponse });
var errorDetails = writable(void 0);
var backAction = writable(void 0);
var colorScheme = writable(getStoredColorScheme());
colorScheme.subscribe((value) => {
  if (value)
    localStorage.setItem("colorScheme", value);
});
function create_if_block$c(ctx) {
  let errormessage;
  let current;
  errormessage = new ErrorMessage({
    props: {
      title: (
        /*$t*/
        ctx[1]("error.title", { default: "Error" })
      ),
      details: (
        /*$errorDetails*/
        ctx[0]
      )
    }
  });
  return {
    c() {
      create_component(errormessage.$$.fragment);
    },
    m(target, anchor) {
      mount_component(errormessage, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const errormessage_changes = {};
      if (dirty & /*$t*/
      2)
        errormessage_changes.title = /*$t*/
        ctx2[1]("error.title", { default: "Error" });
      if (dirty & /*$errorDetails*/
      1)
        errormessage_changes.details = /*$errorDetails*/
        ctx2[0];
      errormessage.$set(errormessage_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(errormessage.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(errormessage.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(errormessage, detaching);
    }
  };
}
function create_fragment$C(ctx) {
  let div;
  let current;
  let if_block = (
    /*$errorDetails*/
    ctx[0] && create_if_block$c(ctx)
  );
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      attr(div, "class", "error");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*$errorDetails*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$errorDetails*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$c(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block)
        if_block.d();
    }
  };
}
function instance$t($$self, $$props, $$invalidate) {
  let $errorDetails;
  let $t;
  component_subscribe($$self, errorDetails, ($$value) => $$invalidate(0, $errorDetails = $$value));
  const { t: t2 } = getContext("i18n");
  component_subscribe($$self, t2, (value) => $$invalidate(1, $t = value));
  return [$errorDetails, $t, t2];
}
var Error$1 = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$t, create_fragment$C, safe_not_equal, {});
  }
};
function create_fragment$B(ctx) {
  let svg;
  let rect;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      rect = svg_element("rect");
      path = svg_element("path");
      attr(rect, "x", "9");
      attr(rect, "y", "9");
      attr(rect, "width", "13");
      attr(rect, "height", "13");
      attr(rect, "rx", "2");
      attr(rect, "ry", "2");
      attr(path, "d", "M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "width", "24");
      attr(svg, "height", "24");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "fill", "none");
      attr(svg, "stroke", "currentColor");
      attr(svg, "stroke-width", "2");
      attr(svg, "stroke-linecap", "round");
      attr(svg, "stroke-linejoin", "round");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, rect);
      append(svg, path);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
var Copy = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$B, safe_not_equal, {});
  }
};
function create_fragment$A(ctx) {
  let svg;
  let polyline;
  return {
    c() {
      svg = svg_element("svg");
      polyline = svg_element("polyline");
      attr(polyline, "points", "20 6 9 17 4 12");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "width", "24");
      attr(svg, "height", "24");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "fill", "none");
      attr(svg, "stroke", "currentColor");
      attr(svg, "stroke-width", "2");
      attr(svg, "stroke-linecap", "round");
      attr(svg, "stroke-linejoin", "round");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, polyline);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
var Check = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$A, safe_not_equal, {});
  }
};
function create_fragment$z(ctx) {
  let svg;
  let line0;
  let line1;
  return {
    c() {
      svg = svg_element("svg");
      line0 = svg_element("line");
      line1 = svg_element("line");
      attr(line0, "x1", "18");
      attr(line0, "y1", "6");
      attr(line0, "x2", "6");
      attr(line0, "y2", "18");
      attr(line1, "x1", "6");
      attr(line1, "y1", "6");
      attr(line1, "x2", "18");
      attr(line1, "y2", "18");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "width", "24");
      attr(svg, "height", "24");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "fill", "none");
      attr(svg, "stroke", "currentColor");
      attr(svg, "stroke-width", "2");
      attr(svg, "stroke-linecap", "round");
      attr(svg, "stroke-linejoin", "round");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, line0);
      append(svg, line1);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
var CloseIcon = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$z, safe_not_equal, {});
  }
};
function create_fragment$y(ctx) {
  let svg;
  let path0;
  let polyline;
  let path1;
  let path2;
  return {
    c() {
      svg = svg_element("svg");
      path0 = svg_element("path");
      polyline = svg_element("polyline");
      path1 = svg_element("path");
      path2 = svg_element("path");
      attr(path0, "d", "M4 22h14a2 2 0 0 0 2-2V7.5L14.5 2H6a2 2 0 0 0-2 2v4");
      attr(polyline, "points", "14 2 14 8 20 8");
      attr(path1, "d", "m9 18 3-3-3-3");
      attr(path2, "d", "m5 12-3 3 3 3");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "width", "24");
      attr(svg, "height", "24");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "fill", "none");
      attr(svg, "stroke", "currentColor");
      attr(svg, "stroke-width", "2");
      attr(svg, "stroke-linecap", "round");
      attr(svg, "stroke-linejoin", "round");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path0);
      append(svg, polyline);
      append(svg, path1);
      append(svg, path2);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
var FileCode = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$y, safe_not_equal, {});
  }
};
function create_fragment$x(ctx) {
  let svg;
  let path0;
  let path1;
  let path2;
  let path3;
  let path4;
  return {
    c() {
      svg = svg_element("svg");
      path0 = svg_element("path");
      path1 = svg_element("path");
      path2 = svg_element("path");
      path3 = svg_element("path");
      path4 = svg_element("path");
      attr(path0, "d", "M35.54 18.77c-.019.989-.673 1.676-1.319 2.048l-1.388.802c-.663.383-1.438.531-2.132.531-.695 0-1.47-.148-2.132-.531l-1.362-.802v2.722c0 1.008-.664 1.711-1.318 2.089l-1.389.801c-.663.383-1.437.531-2.132.531-.694 0-1.469-.148-2.131-.53l-2.035-1.175-2.034 1.174c-.663.383-1.438.531-2.132.531-.694 0-1.469-.148-2.131-.53l-9.722-5.613c-.645-.372-1.3-1.06-1.317-2.049v-.061 3.626c.018.989.672 1.676 1.317 2.049l9.722 5.612c.662.382 1.437.53 2.131.53.694 0 1.47-.148 2.132-.53l2.034-1.175 2.035 1.175c.662.382 1.437.53 2.131.53.695 0 1.47-.148 2.132-.53l1.389-.802c.654-.378 1.318-1.08 1.318-2.088v-2.722l1.362.801c.663.383 1.437.531 2.132.531.694 0 1.469-.148 2.132-.53l1.388-.802c.646-.373 1.3-1.06 1.318-2.05V18.77Z");
      attr(path0, "fill", "#7BE7CE");
      attr(path1, "d", "M.874 15.362a1.5 1.5 0 0 0-.009.161v3.246c.019.99.673 1.677 1.318 2.05l9.722 5.612c.662.382 1.437.53 2.131.53.694 0 1.47-.148 2.132-.53l2.034-1.175 2.035 1.175c.662.382 1.437.53 2.131.53.695 0 1.47-.148 2.132-.53l1.389-.802c.654-.378 1.318-1.08 1.318-2.089V20.82l1.362.801c.663.383 1.437.531 2.132.531.694 0 1.469-.148 2.132-.53l1.388-.802c.646-.373 1.3-1.06 1.318-2.05v-3.564c-.018.99-.672 1.677-1.318 2.049l-1.388.802c-.663.382-1.438.53-2.132.53-.695 0-1.47-.148-2.132-.53l-1.388-.802a2.943 2.943 0 0 1-.067-.04 2.168 2.168 0 0 1 .085.834c.005.05.008.101.008.152v1.776c0 1.008-.664 1.71-1.318 2.088l-1.389.802c-.663.383-1.437.531-2.132.531-.694 0-1.469-.148-2.131-.53l-2.035-1.175-2.034 1.174c-.663.383-1.438.531-2.132.531-.694 0-1.469-.148-2.131-.53l-9.722-5.613c-.61-.352-1.229-.987-1.31-1.892ZM17.54 5.749l.004.043c.07.6.368 1.074.74 1.424a4.94 4.94 0 0 0-.75.045V5.875c0-.043.002-.085.006-.126Z");
      attr(path1, "fill", "#B2F2E1");
      attr(path2, "d", "m3.573 10.152-1.389.801c-.618.358-1.246 1.006-1.312 1.928a1.364 1.364 0 0 0-.007.136V15.204c.019.99.673 1.677 1.318 2.05l9.722 5.611c.662.383 1.437.532 2.131.532.694 0 1.47-.149 2.132-.532l2.034-1.174 2.035 1.174c.662.383 1.437.532 2.131.532.695 0 1.47-.149 2.132-.532l1.389-.801c.654-.378 1.318-1.08 1.318-2.089v-1.775c0-.052-.003-.102-.008-.153a2.25 2.25 0 0 0-.085-.833l.067.04 1.388.801c.663.383 1.437.531 2.132.531.694 0 1.469-.148 2.132-.53l1.388-.802c.646-.373 1.3-1.06 1.318-2.05v-2.092a2.359 2.359 0 0 0 0-.142V8.29l.001-.058c0-1.009-.664-1.711-1.318-2.089L24.501.531C23.838.15 23.064 0 22.369 0c-.694 0-1.469.149-2.131.531l-1.389.802c-.654.377-1.318 1.08-1.318 2.088 0 .048.001.095.004.14v1.847a2.069 2.069 0 0 0 .01.385c.069.6.367 1.073.739 1.423h-.08c-.695 0-1.47.148-2.133.53l-1.388.802c-.654.378-1.318 1.08-1.318 2.089 0 .065.002.13.008.193a1.485 1.485 0 0 0-.002.073v1.682l-.003.041-.002.045a2.298 2.298 0 0 0 .021.405c.017.112.041.22.072.322l-5.623-3.246C7.174 9.769 6.4 9.62 5.705 9.62c-.695 0-1.47.148-2.132.53Z");
      attr(path2, "fill", "#F4FAF4");
      attr(path3, "d", "M23.758 1.818c-.767-.442-2.01-.442-2.778 0l-1.389.802c-.766.443-.766 1.16 0 1.604l9.553 5.514c.369.213.575.501.575.802v.195c0 .3-.207.589-.575.801l-1.22.705c-.767.443-.767 1.16 0 1.603l1.389.802c.767.443 2.01.443 2.777 0l1.389-.802c.767-.443.767-1.16 0-1.603l-1.22-.705c-.369-.212-.576-.5-.576-.801v-.195c0-.3.207-.59.576-.802l1.22-.704c.767-.443.767-1.16 0-1.604l-9.721-5.612ZM7.093 11.439c-.767-.443-2.01-.443-2.777 0l-1.39.802c-.766.443-.766 1.16 0 1.603l9.722 5.612c.767.443 2.01.443 2.777 0l2.778-1.603-11.11-6.414Z");
      attr(path3, "fill", "#494E62");
      attr(path4, "d", "M23.351 15.545c0 .3.207.589.575.801l1.22.705c.767.443.767 1.16 0 1.603l-1.388.802c-.767.443-2.01.443-2.778 0l-2.777-1.603 2.609-1.507c.368-.212.575-.5.575-.801v-.195c0-.3-.207-.589-.575-.801l-5.387-3.11c-.767-.443-.767-1.16 0-1.603l1.39-.802c.766-.443 2.01-.443 2.776 0l5.555 3.207c.767.443.767 1.16 0 1.603l-1.22.705c-.368.212-.575.5-.575.801v.195Z");
      attr(path4, "fill", "#494E62");
      attr(svg, "width", "36");
      attr(svg, "height", "31");
      attr(svg, "fill", "none");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path0);
      append(svg, path1);
      append(svg, path2);
      append(svg, path3);
      append(svg, path4);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance$s($$self, $$props, $$invalidate) {
  let { size = "36px" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
  };
  return [size];
}
var Wharf = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$s, create_fragment$x, safe_not_equal, { size: 0 });
  }
};
function create_fragment$w(ctx) {
  let svg;
  let path;
  let polyline;
  let line;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      polyline = svg_element("polyline");
      line = svg_element("line");
      attr(path, "d", "M15 3h4a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-4");
      attr(polyline, "points", "10 17 15 12 10 7");
      attr(line, "x1", "15");
      attr(line, "y1", "12");
      attr(line, "x2", "3");
      attr(line, "y2", "12");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "width", "24");
      attr(svg, "height", "24");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "fill", "none");
      attr(svg, "stroke", "currentColor");
      attr(svg, "stroke-width", "2");
      attr(svg, "stroke-linecap", "round");
      attr(svg, "stroke-linejoin", "round");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
      append(svg, polyline);
      append(svg, line);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
var LogIn = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$w, safe_not_equal, {});
  }
};
function create_fragment$v(ctx) {
  let svg;
  let polyline;
  return {
    c() {
      svg = svg_element("svg");
      polyline = svg_element("polyline");
      attr(polyline, "points", "9 18 15 12 9 6");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "width", "24");
      attr(svg, "height", "24");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "fill", "none");
      attr(svg, "stroke", "currentColor");
      attr(svg, "stroke-width", "2");
      attr(svg, "stroke-linecap", "round");
      attr(svg, "stroke-linejoin", "round");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, polyline);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
var ChevronRight = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$v, safe_not_equal, {});
  }
};
function create_fragment$u(ctx) {
  let svg;
  let polyline;
  return {
    c() {
      svg = svg_element("svg");
      polyline = svg_element("polyline");
      attr(polyline, "points", "15 18 9 12 15 6");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "width", "24");
      attr(svg, "height", "24");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "fill", "none");
      attr(svg, "stroke", "currentColor");
      attr(svg, "stroke-width", "2");
      attr(svg, "stroke-linecap", "round");
      attr(svg, "stroke-linejoin", "round");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, polyline);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
var ChevronLeft = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$u, safe_not_equal, {});
  }
};
function create_fragment$t(ctx) {
  let svg;
  let path0;
  let path1;
  let path2;
  return {
    c() {
      svg = svg_element("svg");
      path0 = svg_element("path");
      path1 = svg_element("path");
      path2 = svg_element("path");
      attr(path0, "d", "M20 12V8H6a2 2 0 0 1-2-2c0-1.1.9-2 2-2h12v4");
      attr(path1, "d", "M4 6v12c0 1.1.9 2 2 2h14v-4");
      attr(path2, "d", "M18 12a2 2 0 0 0-2 2c0 1.1.9 2 2 2h4v-4h-4z");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "width", "24");
      attr(svg, "height", "24");
      attr(svg, "fill", "none");
      attr(svg, "stroke", "currentColor");
      attr(svg, "stroke-width", "2");
      attr(svg, "stroke-linecap", "round");
      attr(svg, "stroke-linejoin", "round");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path0);
      append(svg, path1);
      append(svg, path2);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
var Wallet$1 = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$t, safe_not_equal, {});
  }
};
function create_fragment$s(ctx) {
  let svg;
  let polyline0;
  let polyline1;
  let line0;
  let line1;
  return {
    c() {
      svg = svg_element("svg");
      polyline0 = svg_element("polyline");
      polyline1 = svg_element("polyline");
      line0 = svg_element("line");
      line1 = svg_element("line");
      attr(polyline0, "points", "15 3 21 3 21 9");
      attr(polyline1, "points", "9 21 3 21 3 15");
      attr(line0, "x1", "21");
      attr(line0, "y1", "3");
      attr(line0, "x2", "14");
      attr(line0, "y2", "10");
      attr(line1, "x1", "3");
      attr(line1, "y1", "21");
      attr(line1, "x2", "10");
      attr(line1, "y2", "14");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "width", "24");
      attr(svg, "height", "24");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "fill", "none");
      attr(svg, "stroke", "currentColor");
      attr(svg, "stroke-width", "2");
      attr(svg, "stroke-linecap", "round");
      attr(svg, "stroke-linejoin", "round");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, polyline0);
      append(svg, polyline1);
      append(svg, line0);
      append(svg, line1);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
var Expand = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$s, safe_not_equal, {});
  }
};
var icons = {
  copy: Copy,
  check: Check,
  close: CloseIcon,
  "file-code": FileCode,
  wharf: Wharf,
  login: LogIn,
  "chevron-right": ChevronRight,
  "chevron-left": ChevronLeft,
  wallet: Wallet$1,
  expand: Expand
};
function create_fragment$r(ctx) {
  let div;
  let switch_instance;
  let current;
  const switch_instance_spread_levels = [
    /*$$props*/
    ctx[2]
  ];
  var switch_value = icons[
    /*name*/
    ctx[0]
  ];
  function switch_props(ctx2) {
    let switch_instance_props = {};
    for (let i2 = 0; i2 < switch_instance_spread_levels.length; i2 += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i2]);
    }
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props());
  }
  return {
    c() {
      div = element("div");
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      set_style(div, "width", "var(" + /*size*/
      ctx[1] + ")");
      set_style(div, "display", "grid");
      set_style(div, "place-content", "center");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (switch_instance)
        mount_component(switch_instance, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const switch_instance_changes = dirty & /*$$props*/
      4 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(
        /*$$props*/
        ctx2[2]
      )]) : {};
      if (switch_value !== (switch_value = icons[
        /*name*/
        ctx2[0]
      ])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props());
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div, null);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
      if (!current || dirty & /*size*/
      2) {
        set_style(div, "width", "var(" + /*size*/
        ctx2[1] + ")");
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (switch_instance)
        destroy_component(switch_instance);
    }
  };
}
function instance$r($$self, $$props, $$invalidate) {
  let { name } = $$props;
  let { size = "--space-l" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(2, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("name" in $$new_props)
      $$invalidate(0, name = $$new_props.name);
    if ("size" in $$new_props)
      $$invalidate(1, size = $$new_props.size);
  };
  $$props = exclude_internal_props($$props);
  return [name, size, $$props];
}
var Icon = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$r, create_fragment$r, safe_not_equal, { name: 0, size: 1 });
  }
};
function add_css$k(target) {
  append_styles(target, "svelte-hwtk1p", ".button.svelte-hwtk1p{--button-height:var(--space-2xl);cursor:pointer;display:flex;justify-content:center;align-items:center;gap:var(--space-2xs);height:var(--button-height);line-height:var(--button-height);text-decoration:none;text-align:center;border-radius:var(--border-radius-inner);font-size:var(--fs-1);font-weight:600;color:var(--button-color, var(--button-text-color));background:var(--button-background, var(--button-primary-background));border:none;box-shadow:var(--button-outline);flex:1}.button.svelte-hwtk1p:hover{background:var(--button-background-hover, var(--button-primary-background-hover));box-shadow:var(--button-outline-hover, var(--button-primary-outline-hover))}.button.svelte-hwtk1p:active{background:var(--button-background-active, var(--button-primary-background-active));box-shadow:var(--button-outline-active);color:var(--button-text-color-active)}.secondary.svelte-hwtk1p{--button-background:var(--button-secondary-background);--button-background-hover:var(--button-secondary-background-hover);--button-background-active:var(--button-secondary-background-active);--button-outline-hover:var(--button-secondary-outline-hover)}.outlined.svelte-hwtk1p{--button-background:transparent;--button-background-hover:transparent;--button-background-active:var(--button-outlined-background-active);--button-outline:var(--button-outlined-outline);--button-outline-hover:var(--button-outlined-outline-hover)}");
}
function create_if_block$b(ctx) {
  let icon_1;
  let current;
  icon_1 = new Icon({ props: { name: (
    /*icon*/
    ctx[2]
  ) } });
  return {
    c() {
      create_component(icon_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon_1, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(icon_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon_1, detaching);
    }
  };
}
function create_fragment$q(ctx) {
  let button;
  let t0;
  let span;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*icon*/
    ctx[2] && create_if_block$b(ctx)
  );
  return {
    c() {
      button = element("button");
      if (if_block)
        if_block.c();
      t0 = space();
      span = element("span");
      span.textContent = `${/*label*/
      ctx[1]}`;
      attr(button, "class", "button " + /*variant*/
      ctx[4] + " svelte-hwtk1p");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (if_block)
        if_block.m(button, null);
      append(button, t0);
      append(button, span);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            button,
            "click",
            /*onClick*/
            ctx[3]
          ),
          listen(button, "keydown", function() {
            if (is_function(
              /*onKeydown*/
              ctx[0]
            ))
              ctx[0].apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (
        /*icon*/
        ctx[2]
      )
        if_block.p(ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(button);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$q($$self, $$props, $$invalidate) {
  let onKeydown;
  let { data } = $$props;
  const { label, icon, onClick, variant = "primary" } = data;
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(5, data = $$props2.data);
  };
  $$invalidate(0, onKeydown = onClick);
  return [onKeydown, label, icon, onClick, variant, data];
}
var Button = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$q, create_fragment$q, safe_not_equal, { data: 5 }, add_css$k);
  }
};
function add_css$j(target) {
  append_styles(target, "svelte-1m2zvm", "div.svelte-1m2zvm{flex:1;display:flex;justify-content:space-between;gap:var(--space-xs)}");
}
function create_fragment$p(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "class", "svelte-1m2zvm");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance$p($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var ButtonGroup = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$p, create_fragment$p, safe_not_equal, {}, add_css$j);
  }
};
function create_default_slot$7(ctx) {
  let button0;
  let t_1;
  let button1;
  let current;
  button0 = new Button({
    props: {
      data: {
        variant: "outlined",
        label: (
          /*$t*/
          ctx[0]("decline", { default: "Decline" })
        ),
        onClick: (
          /*func*/
          ctx[3]
        ),
        icon: "close"
      }
    }
  });
  button1 = new Button({
    props: {
      data: {
        variant: "primary",
        label: (
          /*$t*/
          ctx[0]("accept", { default: "Accept" })
        ),
        onClick: (
          /*func_1*/
          ctx[4]
        ),
        icon: "check"
      }
    }
  });
  return {
    c() {
      create_component(button0.$$.fragment);
      t_1 = space();
      create_component(button1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(button0, target, anchor);
      insert(target, t_1, anchor);
      mount_component(button1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const button0_changes = {};
      if (dirty & /*$t*/
      1)
        button0_changes.data = {
          variant: "outlined",
          label: (
            /*$t*/
            ctx2[0]("decline", { default: "Decline" })
          ),
          onClick: (
            /*func*/
            ctx2[3]
          ),
          icon: "close"
        };
      button0.$set(button0_changes);
      const button1_changes = {};
      if (dirty & /*$t*/
      1)
        button1_changes.data = {
          variant: "primary",
          label: (
            /*$t*/
            ctx2[0]("accept", { default: "Accept" })
          ),
          onClick: (
            /*func_1*/
            ctx2[4]
          ),
          icon: "check"
        };
      button1.$set(button1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button0.$$.fragment, local);
      transition_in(button1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button0.$$.fragment, local);
      transition_out(button1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button0, detaching);
      if (detaching)
        detach(t_1);
      destroy_component(button1, detaching);
    }
  };
}
function create_fragment$o(ctx) {
  let buttongroup;
  let current;
  buttongroup = new ButtonGroup({
    props: {
      $$slots: { default: [create_default_slot$7] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(buttongroup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(buttongroup, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const buttongroup_changes = {};
      if (dirty & /*$$scope, $t*/
      33) {
        buttongroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      buttongroup.$set(buttongroup_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(buttongroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(buttongroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(buttongroup, detaching);
    }
  };
}
function instance$o($$self, $$props, $$invalidate) {
  let $t;
  const { t: t2 } = getContext("i18n");
  component_subscribe($$self, t2, (value) => $$invalidate(0, $t = value));
  const dispatch2 = createEventDispatcher();
  const func = () => dispatch2("cancel");
  const func_1 = () => dispatch2("complete");
  return [$t, t2, dispatch2, func, func_1];
}
var Accept = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$o, create_fragment$o, safe_not_equal, {});
  }
};
function add_css$i(target) {
  append_styles(target, "svelte-1lmgxnd", ".asset.svelte-1lmgxnd.svelte-1lmgxnd{text-align:center}.asset.svelte-1lmgxnd>.svelte-1lmgxnd{margin:0;line-height:1.5}.value.svelte-1lmgxnd.svelte-1lmgxnd{font-size:var(--fs-2);font-weight:600;color:var(--body-text-color)}.label.svelte-1lmgxnd.svelte-1lmgxnd{font-size:var(--fs-0);font-weight:400;color:var(--body-text-color-variant)}");
}
function create_if_block$a(ctx) {
  let div;
  let p0;
  let t0_value = (
    /*data*/
    ctx[0].value + ""
  );
  let t0;
  let t1;
  let p1;
  let t2_value = (
    /*data*/
    ctx[0].label + ""
  );
  let t2;
  return {
    c() {
      div = element("div");
      p0 = element("p");
      t0 = text(t0_value);
      t1 = space();
      p1 = element("p");
      t2 = text(t2_value);
      attr(p0, "class", "value svelte-1lmgxnd");
      attr(p1, "class", "label svelte-1lmgxnd");
      attr(div, "class", "asset svelte-1lmgxnd");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, p0);
      append(p0, t0);
      append(div, t1);
      append(div, p1);
      append(p1, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*data*/
      1 && t0_value !== (t0_value = /*data*/
      ctx2[0].value + ""))
        set_data(t0, t0_value);
      if (dirty & /*data*/
      1 && t2_value !== (t2_value = /*data*/
      ctx2[0].label + ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment$n(ctx) {
  let if_block_anchor;
  let if_block = (
    /*data*/
    ctx[0] && create_if_block$a(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (
        /*data*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$a(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$n($$self, $$props, $$invalidate) {
  let { data = {
    label: "[[Unknown Label]]",
    value: "[[Unknown Value]]"
  } } = $$props;
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(0, data = $$props2.data);
  };
  return [data];
}
var Asset = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$n, create_fragment$n, safe_not_equal, { data: 0 }, add_css$i);
  }
};
function add_css$h(target) {
  append_styles(target, "svelte-1bils14", "button.svelte-1bils14{cursor:pointer;display:block;width:300px;height:65px;border-radius:12px;font-size:16px;font-weight:600;color:var(--button-text-color);background-color:var(--button-tertiary-color);border:none;box-shadow:none;margin:27px auto 0}");
}
function create_fragment$m(ctx) {
  let button;
  let t_1_value = (
    /*$t*/
    ctx[0]("close", { default: "Close" }) + ""
  );
  let t_1;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      t_1 = text(t_1_value);
      attr(button, "class", "svelte-1bils14");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t_1);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[3]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$t*/
      1 && t_1_value !== (t_1_value = /*$t*/
      ctx2[0]("close", { default: "Close" }) + ""))
        set_data(t_1, t_1_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function instance$m($$self, $$props, $$invalidate) {
  let $t;
  const { t: t2 } = getContext("i18n");
  component_subscribe($$self, t2, (value) => $$invalidate(0, $t = value));
  const dispatch2 = createEventDispatcher();
  const click_handler = () => dispatch2("complete");
  return [$t, t2, dispatch2, click_handler];
}
var Close = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$m, create_fragment$m, safe_not_equal, {}, add_css$h);
  }
};
function add_css$g(target) {
  append_styles(target, "svelte-785ja0", ".button.svelte-785ja0{--button-height:var(--space-2xl);cursor:pointer;display:flex;justify-content:center;align-items:center;gap:var(--space-2xs);height:var(--button-height);line-height:var(--button-height);text-decoration:none;text-align:center;border-radius:var(--border-radius-inner);font-size:var(--fs-1);font-weight:600;color:var(--button-color, var(--button-text-color));background:var(--button-background, var(--button-primary-background));border:none;box-shadow:var(--button-outline);flex:1}.button.svelte-785ja0:hover{background:var(--button-background-hover, var(--button-primary-background-hover));box-shadow:var(--button-outline-hover, var(--button-primary-outline-hover))}.button.svelte-785ja0:active{background:var(--button-background-active, var(--button-primary-background-active));box-shadow:var(--button-outline-active);color:var(--button-text-color-active)}.outlined.svelte-785ja0{--button-background:transparent;--button-background-hover:transparent;--button-background-active:var(--button-outlined-background-active);--button-outline:var(--button-outlined-outline);--button-outline-hover:var(--button-outlined-outline-hover)}a.svelte-785ja0{align-self:stretch}");
}
function create_if_block$9(ctx) {
  let icon_1;
  let current;
  icon_1 = new Icon({ props: { name: (
    /*icon*/
    ctx[3]
  ) } });
  return {
    c() {
      create_component(icon_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon_1, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(icon_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon_1, detaching);
    }
  };
}
function create_fragment$l(ctx) {
  let a;
  let t0;
  let span;
  let current;
  let if_block = (
    /*icon*/
    ctx[3] && create_if_block$9(ctx)
  );
  return {
    c() {
      a = element("a");
      if (if_block)
        if_block.c();
      t0 = space();
      span = element("span");
      span.textContent = `${/*label*/
      ctx[2]}`;
      attr(a, "class", "outlined svelte-785ja0");
      attr(
        a,
        "href",
        /*href*/
        ctx[1]
      );
      attr(a, "target", "_blank");
      attr(a, "rel", "noreferrer");
      toggle_class(
        a,
        "button",
        /*button*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert(target, a, anchor);
      if (if_block)
        if_block.m(a, null);
      append(a, t0);
      append(a, span);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*icon*/
        ctx2[3]
      )
        if_block.p(ctx2, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(a);
      if (if_block)
        if_block.d();
    }
  };
}
function instance$l($$self, $$props, $$invalidate) {
  let { data } = $$props;
  let { button = true, href, label, icon } = data;
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(4, data = $$props2.data);
  };
  return [button, href, label, icon, data];
}
var Link = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$l, create_fragment$l, safe_not_equal, { data: 4 }, add_css$g);
  }
};
function create_if_block$8(ctx) {
  let previous_key = (
    /*remaining*/
    ctx[1]
  );
  let key_block_anchor;
  let key_block = create_key_block(ctx);
  return {
    c() {
      key_block.c();
      key_block_anchor = empty();
    },
    m(target, anchor) {
      key_block.m(target, anchor);
      insert(target, key_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*remaining*/
      2 && safe_not_equal(previous_key, previous_key = /*remaining*/
      ctx2[1])) {
        key_block.d(1);
        key_block = create_key_block(ctx2);
        key_block.c();
        key_block.m(key_block_anchor.parentNode, key_block_anchor);
      } else {
        key_block.p(ctx2, dirty);
      }
    },
    d(detaching) {
      if (detaching)
        detach(key_block_anchor);
      key_block.d(detaching);
    }
  };
}
function create_key_block(ctx) {
  let t_value = countdownFormat(
    /*deadline*/
    ctx[0]
  ) + "";
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*deadline*/
      1 && t_value !== (t_value = countdownFormat(
        /*deadline*/
        ctx2[0]
      ) + ""))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t2);
    }
  };
}
function create_fragment$k(ctx) {
  let if_block_anchor;
  let if_block = (
    /*deadline*/
    ctx[0] && create_if_block$8(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (
        /*deadline*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$8(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function countdownFormat(date) {
  const timeLeft = date.getTime() - Date.now();
  if (timeLeft > 0) {
    return new Date(timeLeft).toISOString().substr(14, 5);
  }
  return "00:00";
}
function instance$k($$self, $$props, $$invalidate) {
  let { data = "" } = $$props;
  let deadline;
  let remaining;
  let timer;
  onDestroy(() => {
    if (timer) {
      clearInterval(timer);
    }
  });
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(2, data = $$props2.data);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*timer, data, deadline, remaining*/
    15) {
      {
        if (timer) {
          clearInterval(timer);
        }
        $$invalidate(0, deadline = new Date(data));
        $$invalidate(3, timer = setInterval(
          () => {
            $$invalidate(1, remaining = deadline - Date.now());
            if (remaining <= 0) {
              clearInterval(timer);
            }
          },
          200
        ));
      }
    }
  };
  return [deadline, remaining, data, timer];
}
var Countdown = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$k, create_fragment$k, safe_not_equal, { data: 2 });
  }
};
var ErrorCorrectLevel = {
  L: 1,
  M: 0,
  Q: 3,
  H: 2
};
var Mode = {
  MODE_NUMBER: 1 << 0,
  MODE_ALPHA_NUM: 1 << 1,
  MODE_8BIT_BYTE: 1 << 2,
  MODE_KANJI: 1 << 3
};
var QR8bitByte = class {
  constructor(data) {
    this.mode = Mode.MODE_8BIT_BYTE;
    this.data = data;
  }
  getLength() {
    return this.data.length;
  }
  write(buffer) {
    for (let i2 = 0; i2 < this.data.length; i2++) {
      buffer.put(this.data.charCodeAt(i2), 8);
    }
  }
};
var QRBitBuffer = class {
  constructor() {
    this.buffer = [];
    this.length = 0;
  }
  get(index) {
    const bufIndex = Math.floor(index / 8);
    return (this.buffer[bufIndex] >>> 7 - index % 8 & 1) == 1;
  }
  put(num, length) {
    for (let i2 = 0; i2 < length; i2++) {
      this.putBit((num >>> length - i2 - 1 & 1) == 1);
    }
  }
  getLengthInBits() {
    return this.length;
  }
  putBit(bit) {
    const bufIndex = Math.floor(this.length / 8);
    if (this.buffer.length <= bufIndex) {
      this.buffer.push(0);
    }
    if (bit) {
      this.buffer[bufIndex] |= 128 >>> this.length % 8;
    }
    this.length++;
  }
};
var QRMath = {
  glog: function(n2) {
    if (n2 < 1) {
      throw new Error("glog(" + n2 + ")");
    }
    return QRMath.LOG_TABLE[n2];
  },
  gexp: function(n2) {
    while (n2 < 0) {
      n2 += 255;
    }
    while (n2 >= 256) {
      n2 -= 255;
    }
    return QRMath.EXP_TABLE[n2];
  },
  EXP_TABLE: new Array(256),
  LOG_TABLE: new Array(256)
};
for (let i2 = 0; i2 < 8; i2++) {
  QRMath.EXP_TABLE[i2] = 1 << i2;
}
for (let i2 = 8; i2 < 256; i2++) {
  QRMath.EXP_TABLE[i2] = QRMath.EXP_TABLE[i2 - 4] ^ QRMath.EXP_TABLE[i2 - 5] ^ QRMath.EXP_TABLE[i2 - 6] ^ QRMath.EXP_TABLE[i2 - 8];
}
for (let i2 = 0; i2 < 255; i2++) {
  QRMath.LOG_TABLE[QRMath.EXP_TABLE[i2]] = i2;
}
var QRPolynomial = class {
  constructor(num, shift) {
    if (num.length == void 0) {
      throw new Error(num.length + "/" + shift);
    }
    let offset = 0;
    while (offset < num.length && num[offset] == 0) {
      offset++;
    }
    this.num = new Array(num.length - offset + shift);
    for (let i2 = 0; i2 < num.length - offset; i2++) {
      this.num[i2] = num[i2 + offset];
    }
  }
  get(index) {
    return this.num[index];
  }
  getLength() {
    return this.num.length;
  }
  multiply(e) {
    const num = new Array(this.getLength() + e.getLength() - 1);
    for (let i2 = 0; i2 < this.getLength(); i2++) {
      for (let j2 = 0; j2 < e.getLength(); j2++) {
        num[i2 + j2] ^= QRMath.gexp(QRMath.glog(this.get(i2)) + QRMath.glog(e.get(j2)));
      }
    }
    return new QRPolynomial(num, 0);
  }
  mod(e) {
    if (this.getLength() - e.getLength() < 0) {
      return this;
    }
    const ratio = QRMath.glog(this.get(0)) - QRMath.glog(e.get(0));
    const num = new Array(this.getLength());
    for (let i2 = 0; i2 < this.getLength(); i2++) {
      num[i2] = this.get(i2);
    }
    for (let i2 = 0; i2 < e.getLength(); i2++) {
      num[i2] ^= QRMath.gexp(QRMath.glog(e.get(i2)) + ratio);
    }
    return new QRPolynomial(num, 0).mod(e);
  }
};
var QRRSBlock = class {
  constructor(totalCount, dataCount) {
    this.totalCount = totalCount;
    this.dataCount = dataCount;
  }
  static getRSBlocks(typeNumber, errorCorrectLevel) {
    const rsBlock = QRRSBlock.getRsBlockTable(typeNumber, errorCorrectLevel);
    if (rsBlock == void 0) {
      throw new Error("bad rs block @ typeNumber:" + typeNumber + "/errorCorrectLevel:" + errorCorrectLevel);
    }
    const length = rsBlock.length / 3;
    const list = [];
    for (let i2 = 0; i2 < length; i2++) {
      const count = rsBlock[i2 * 3 + 0];
      const totalCount = rsBlock[i2 * 3 + 1];
      const dataCount = rsBlock[i2 * 3 + 2];
      for (let j2 = 0; j2 < count; j2++) {
        list.push(new QRRSBlock(totalCount, dataCount));
      }
    }
    return list;
  }
  static getRsBlockTable(typeNumber, errorCorrectLevel) {
    switch (errorCorrectLevel) {
      case ErrorCorrectLevel.L:
        return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 0];
      case ErrorCorrectLevel.M:
        return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 1];
      case ErrorCorrectLevel.Q:
        return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 2];
      case ErrorCorrectLevel.H:
        return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 3];
      default:
        return void 0;
    }
  }
};
QRRSBlock.RS_BLOCK_TABLE = [
  // L
  // M
  // Q
  // H
  // 1
  [1, 26, 19],
  [1, 26, 16],
  [1, 26, 13],
  [1, 26, 9],
  // 2
  [1, 44, 34],
  [1, 44, 28],
  [1, 44, 22],
  [1, 44, 16],
  // 3
  [1, 70, 55],
  [1, 70, 44],
  [2, 35, 17],
  [2, 35, 13],
  // 4
  [1, 100, 80],
  [2, 50, 32],
  [2, 50, 24],
  [4, 25, 9],
  // 5
  [1, 134, 108],
  [2, 67, 43],
  [2, 33, 15, 2, 34, 16],
  [2, 33, 11, 2, 34, 12],
  // 6
  [2, 86, 68],
  [4, 43, 27],
  [4, 43, 19],
  [4, 43, 15],
  // 7
  [2, 98, 78],
  [4, 49, 31],
  [2, 32, 14, 4, 33, 15],
  [4, 39, 13, 1, 40, 14],
  // 8
  [2, 121, 97],
  [2, 60, 38, 2, 61, 39],
  [4, 40, 18, 2, 41, 19],
  [4, 40, 14, 2, 41, 15],
  // 9
  [2, 146, 116],
  [3, 58, 36, 2, 59, 37],
  [4, 36, 16, 4, 37, 17],
  [4, 36, 12, 4, 37, 13],
  // 10
  [2, 86, 68, 2, 87, 69],
  [4, 69, 43, 1, 70, 44],
  [6, 43, 19, 2, 44, 20],
  [6, 43, 15, 2, 44, 16],
  // 11
  [4, 101, 81],
  [1, 80, 50, 4, 81, 51],
  [4, 50, 22, 4, 51, 23],
  [3, 36, 12, 8, 37, 13],
  // 12
  [2, 116, 92, 2, 117, 93],
  [6, 58, 36, 2, 59, 37],
  [4, 46, 20, 6, 47, 21],
  [7, 42, 14, 4, 43, 15],
  // 13
  [4, 133, 107],
  [8, 59, 37, 1, 60, 38],
  [8, 44, 20, 4, 45, 21],
  [12, 33, 11, 4, 34, 12],
  // 14
  [3, 145, 115, 1, 146, 116],
  [4, 64, 40, 5, 65, 41],
  [11, 36, 16, 5, 37, 17],
  [11, 36, 12, 5, 37, 13],
  // 15
  [5, 109, 87, 1, 110, 88],
  [5, 65, 41, 5, 66, 42],
  [5, 54, 24, 7, 55, 25],
  [11, 36, 12],
  // 16
  [5, 122, 98, 1, 123, 99],
  [7, 73, 45, 3, 74, 46],
  [15, 43, 19, 2, 44, 20],
  [3, 45, 15, 13, 46, 16],
  // 17
  [1, 135, 107, 5, 136, 108],
  [10, 74, 46, 1, 75, 47],
  [1, 50, 22, 15, 51, 23],
  [2, 42, 14, 17, 43, 15],
  // 18
  [5, 150, 120, 1, 151, 121],
  [9, 69, 43, 4, 70, 44],
  [17, 50, 22, 1, 51, 23],
  [2, 42, 14, 19, 43, 15],
  // 19
  [3, 141, 113, 4, 142, 114],
  [3, 70, 44, 11, 71, 45],
  [17, 47, 21, 4, 48, 22],
  [9, 39, 13, 16, 40, 14],
  // 20
  [3, 135, 107, 5, 136, 108],
  [3, 67, 41, 13, 68, 42],
  [15, 54, 24, 5, 55, 25],
  [15, 43, 15, 10, 44, 16],
  // 21
  [4, 144, 116, 4, 145, 117],
  [17, 68, 42],
  [17, 50, 22, 6, 51, 23],
  [19, 46, 16, 6, 47, 17],
  // 22
  [2, 139, 111, 7, 140, 112],
  [17, 74, 46],
  [7, 54, 24, 16, 55, 25],
  [34, 37, 13],
  // 23
  [4, 151, 121, 5, 152, 122],
  [4, 75, 47, 14, 76, 48],
  [11, 54, 24, 14, 55, 25],
  [16, 45, 15, 14, 46, 16],
  // 24
  [6, 147, 117, 4, 148, 118],
  [6, 73, 45, 14, 74, 46],
  [11, 54, 24, 16, 55, 25],
  [30, 46, 16, 2, 47, 17],
  // 25
  [8, 132, 106, 4, 133, 107],
  [8, 75, 47, 13, 76, 48],
  [7, 54, 24, 22, 55, 25],
  [22, 45, 15, 13, 46, 16],
  // 26
  [10, 142, 114, 2, 143, 115],
  [19, 74, 46, 4, 75, 47],
  [28, 50, 22, 6, 51, 23],
  [33, 46, 16, 4, 47, 17],
  // 27
  [8, 152, 122, 4, 153, 123],
  [22, 73, 45, 3, 74, 46],
  [8, 53, 23, 26, 54, 24],
  [12, 45, 15, 28, 46, 16],
  // 28
  [3, 147, 117, 10, 148, 118],
  [3, 73, 45, 23, 74, 46],
  [4, 54, 24, 31, 55, 25],
  [11, 45, 15, 31, 46, 16],
  // 29
  [7, 146, 116, 7, 147, 117],
  [21, 73, 45, 7, 74, 46],
  [1, 53, 23, 37, 54, 24],
  [19, 45, 15, 26, 46, 16],
  // 30
  [5, 145, 115, 10, 146, 116],
  [19, 75, 47, 10, 76, 48],
  [15, 54, 24, 25, 55, 25],
  [23, 45, 15, 25, 46, 16],
  // 31
  [13, 145, 115, 3, 146, 116],
  [2, 74, 46, 29, 75, 47],
  [42, 54, 24, 1, 55, 25],
  [23, 45, 15, 28, 46, 16],
  // 32
  [17, 145, 115],
  [10, 74, 46, 23, 75, 47],
  [10, 54, 24, 35, 55, 25],
  [19, 45, 15, 35, 46, 16],
  // 33
  [17, 145, 115, 1, 146, 116],
  [14, 74, 46, 21, 75, 47],
  [29, 54, 24, 19, 55, 25],
  [11, 45, 15, 46, 46, 16],
  // 34
  [13, 145, 115, 6, 146, 116],
  [14, 74, 46, 23, 75, 47],
  [44, 54, 24, 7, 55, 25],
  [59, 46, 16, 1, 47, 17],
  // 35
  [12, 151, 121, 7, 152, 122],
  [12, 75, 47, 26, 76, 48],
  [39, 54, 24, 14, 55, 25],
  [22, 45, 15, 41, 46, 16],
  // 36
  [6, 151, 121, 14, 152, 122],
  [6, 75, 47, 34, 76, 48],
  [46, 54, 24, 10, 55, 25],
  [2, 45, 15, 64, 46, 16],
  // 37
  [17, 152, 122, 4, 153, 123],
  [29, 74, 46, 14, 75, 47],
  [49, 54, 24, 10, 55, 25],
  [24, 45, 15, 46, 46, 16],
  // 38
  [4, 152, 122, 18, 153, 123],
  [13, 74, 46, 32, 75, 47],
  [48, 54, 24, 14, 55, 25],
  [42, 45, 15, 32, 46, 16],
  // 39
  [20, 147, 117, 4, 148, 118],
  [40, 75, 47, 7, 76, 48],
  [43, 54, 24, 22, 55, 25],
  [10, 45, 15, 67, 46, 16],
  // 40
  [19, 148, 118, 6, 149, 119],
  [18, 75, 47, 31, 76, 48],
  [34, 54, 24, 34, 55, 25],
  [20, 45, 15, 61, 46, 16]
];
var QRMaskPattern = {
  PATTERN000: 0,
  PATTERN001: 1,
  PATTERN010: 2,
  PATTERN011: 3,
  PATTERN100: 4,
  PATTERN101: 5,
  PATTERN110: 6,
  PATTERN111: 7
};
var QRUtil = {
  PATTERN_POSITION_TABLE: [
    [],
    [6, 18],
    [6, 22],
    [6, 26],
    [6, 30],
    [6, 34],
    [6, 22, 38],
    [6, 24, 42],
    [6, 26, 46],
    [6, 28, 50],
    [6, 30, 54],
    [6, 32, 58],
    [6, 34, 62],
    [6, 26, 46, 66],
    [6, 26, 48, 70],
    [6, 26, 50, 74],
    [6, 30, 54, 78],
    [6, 30, 56, 82],
    [6, 30, 58, 86],
    [6, 34, 62, 90],
    [6, 28, 50, 72, 94],
    [6, 26, 50, 74, 98],
    [6, 30, 54, 78, 102],
    [6, 28, 54, 80, 106],
    [6, 32, 58, 84, 110],
    [6, 30, 58, 86, 114],
    [6, 34, 62, 90, 118],
    [6, 26, 50, 74, 98, 122],
    [6, 30, 54, 78, 102, 126],
    [6, 26, 52, 78, 104, 130],
    [6, 30, 56, 82, 108, 134],
    [6, 34, 60, 86, 112, 138],
    [6, 30, 58, 86, 114, 142],
    [6, 34, 62, 90, 118, 146],
    [6, 30, 54, 78, 102, 126, 150],
    [6, 24, 50, 76, 102, 128, 154],
    [6, 28, 54, 80, 106, 132, 158],
    [6, 32, 58, 84, 110, 136, 162],
    [6, 26, 54, 82, 110, 138, 166],
    [6, 30, 58, 86, 114, 142, 170]
  ],
  G15: 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0,
  G18: 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0,
  G15_MASK: 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1,
  getBCHTypeInfo: function(data) {
    let d2 = data << 10;
    while (QRUtil.getBCHDigit(d2) - QRUtil.getBCHDigit(QRUtil.G15) >= 0) {
      d2 ^= QRUtil.G15 << QRUtil.getBCHDigit(d2) - QRUtil.getBCHDigit(QRUtil.G15);
    }
    return (data << 10 | d2) ^ QRUtil.G15_MASK;
  },
  getBCHTypeNumber: function(data) {
    let d2 = data << 12;
    while (QRUtil.getBCHDigit(d2) - QRUtil.getBCHDigit(QRUtil.G18) >= 0) {
      d2 ^= QRUtil.G18 << QRUtil.getBCHDigit(d2) - QRUtil.getBCHDigit(QRUtil.G18);
    }
    return data << 12 | d2;
  },
  getBCHDigit: function(data) {
    let digit = 0;
    while (data != 0) {
      digit++;
      data >>>= 1;
    }
    return digit;
  },
  getPatternPosition: function(typeNumber) {
    return QRUtil.PATTERN_POSITION_TABLE[typeNumber - 1];
  },
  getMask: function(maskPattern, i2, j2) {
    switch (maskPattern) {
      case QRMaskPattern.PATTERN000:
        return (i2 + j2) % 2 == 0;
      case QRMaskPattern.PATTERN001:
        return i2 % 2 == 0;
      case QRMaskPattern.PATTERN010:
        return j2 % 3 == 0;
      case QRMaskPattern.PATTERN011:
        return (i2 + j2) % 3 == 0;
      case QRMaskPattern.PATTERN100:
        return (Math.floor(i2 / 2) + Math.floor(j2 / 3)) % 2 == 0;
      case QRMaskPattern.PATTERN101:
        return i2 * j2 % 2 + i2 * j2 % 3 == 0;
      case QRMaskPattern.PATTERN110:
        return (i2 * j2 % 2 + i2 * j2 % 3) % 2 == 0;
      case QRMaskPattern.PATTERN111:
        return (i2 * j2 % 3 + (i2 + j2) % 2) % 2 == 0;
      default:
        throw new Error("bad maskPattern:" + maskPattern);
    }
  },
  getErrorCorrectPolynomial: function(errorCorrectLength) {
    let a = new QRPolynomial([1], 0);
    for (let i2 = 0; i2 < errorCorrectLength; i2++) {
      a = a.multiply(new QRPolynomial([1, QRMath.gexp(i2)], 0));
    }
    return a;
  },
  getLengthInBits: function(mode, type) {
    if (1 <= type && type < 10) {
      switch (mode) {
        case Mode.MODE_NUMBER:
          return 10;
        case Mode.MODE_ALPHA_NUM:
          return 9;
        case Mode.MODE_8BIT_BYTE:
          return 8;
        case Mode.MODE_KANJI:
          return 8;
        default:
          throw new Error("mode:" + mode);
      }
    } else if (type < 27) {
      switch (mode) {
        case Mode.MODE_NUMBER:
          return 12;
        case Mode.MODE_ALPHA_NUM:
          return 11;
        case Mode.MODE_8BIT_BYTE:
          return 16;
        case Mode.MODE_KANJI:
          return 10;
        default:
          throw new Error("mode:" + mode);
      }
    } else if (type < 41) {
      switch (mode) {
        case Mode.MODE_NUMBER:
          return 14;
        case Mode.MODE_ALPHA_NUM:
          return 13;
        case Mode.MODE_8BIT_BYTE:
          return 16;
        case Mode.MODE_KANJI:
          return 12;
        default:
          throw new Error("mode:" + mode);
      }
    } else {
      throw new Error("type:" + type);
    }
  },
  getLostPoint: function(qrCode) {
    const moduleCount = qrCode.getModuleCount();
    let lostPoint = 0;
    for (let row = 0; row < moduleCount; row++) {
      for (let col = 0; col < moduleCount; col++) {
        let sameCount = 0;
        const dark = qrCode.isDark(row, col);
        for (let r = -1; r <= 1; r++) {
          if (row + r < 0 || moduleCount <= row + r) {
            continue;
          }
          for (let c = -1; c <= 1; c++) {
            if (col + c < 0 || moduleCount <= col + c) {
              continue;
            }
            if (r == 0 && c == 0) {
              continue;
            }
            if (dark == qrCode.isDark(row + r, col + c)) {
              sameCount++;
            }
          }
        }
        if (sameCount > 5) {
          lostPoint += 3 + sameCount - 5;
        }
      }
    }
    for (let row = 0; row < moduleCount - 1; row++) {
      for (let col = 0; col < moduleCount - 1; col++) {
        let count = 0;
        if (qrCode.isDark(row, col))
          count++;
        if (qrCode.isDark(row + 1, col))
          count++;
        if (qrCode.isDark(row, col + 1))
          count++;
        if (qrCode.isDark(row + 1, col + 1))
          count++;
        if (count == 0 || count == 4) {
          lostPoint += 3;
        }
      }
    }
    for (let row = 0; row < moduleCount; row++) {
      for (let col = 0; col < moduleCount - 6; col++) {
        if (qrCode.isDark(row, col) && !qrCode.isDark(row, col + 1) && qrCode.isDark(row, col + 2) && qrCode.isDark(row, col + 3) && qrCode.isDark(row, col + 4) && !qrCode.isDark(row, col + 5) && qrCode.isDark(row, col + 6)) {
          lostPoint += 40;
        }
      }
    }
    for (let col = 0; col < moduleCount; col++) {
      for (let row = 0; row < moduleCount - 6; row++) {
        if (qrCode.isDark(row, col) && !qrCode.isDark(row + 1, col) && qrCode.isDark(row + 2, col) && qrCode.isDark(row + 3, col) && qrCode.isDark(row + 4, col) && !qrCode.isDark(row + 5, col) && qrCode.isDark(row + 6, col)) {
          lostPoint += 40;
        }
      }
    }
    let darkCount = 0;
    for (let col = 0; col < moduleCount; col++) {
      for (let row = 0; row < moduleCount; row++) {
        if (qrCode.isDark(row, col)) {
          darkCount++;
        }
      }
    }
    const ratio = Math.abs(100 * darkCount / moduleCount / moduleCount - 50) / 5;
    lostPoint += ratio * 10;
    return lostPoint;
  }
};
var QRCode = class {
  constructor(typeNumber, errorCorrectLevel) {
    this.typeNumber = typeNumber;
    this.errorCorrectLevel = errorCorrectLevel;
    this.modules = null;
    this.moduleCount = 0;
    this.dataCache = null;
    this.dataList = [];
  }
  addData(data) {
    const newData = new QR8bitByte(data);
    this.dataList.push(newData);
    this.dataCache = null;
  }
  isDark(row, col) {
    if (row < 0 || this.moduleCount <= row || col < 0 || this.moduleCount <= col) {
      throw new Error(row + "," + col);
    }
    return this.modules[row][col];
  }
  getModuleCount() {
    return this.moduleCount;
  }
  make() {
    if (this.typeNumber < 1) {
      let typeNumber = 1;
      for (typeNumber = 1; typeNumber < 40; typeNumber++) {
        const rsBlocks = QRRSBlock.getRSBlocks(typeNumber, this.errorCorrectLevel);
        const buffer = new QRBitBuffer();
        let totalDataCount = 0;
        for (let i2 = 0; i2 < rsBlocks.length; i2++) {
          totalDataCount += rsBlocks[i2].dataCount;
        }
        for (let i2 = 0; i2 < this.dataList.length; i2++) {
          const data = this.dataList[i2];
          buffer.put(data.mode, 4);
          buffer.put(data.getLength(), QRUtil.getLengthInBits(data.mode, typeNumber));
          data.write(buffer);
        }
        if (buffer.getLengthInBits() <= totalDataCount * 8)
          break;
      }
      this.typeNumber = typeNumber;
    }
    this.makeImpl(false, this.getBestMaskPattern());
  }
  makeImpl(test, maskPattern) {
    this.moduleCount = this.typeNumber * 4 + 17;
    this.modules = new Array(this.moduleCount);
    for (let row = 0; row < this.moduleCount; row++) {
      this.modules[row] = new Array(this.moduleCount);
      for (let col = 0; col < this.moduleCount; col++) {
        this.modules[row][col] = null;
      }
    }
    this.setupPositionProbePattern(0, 0);
    this.setupPositionProbePattern(this.moduleCount - 7, 0);
    this.setupPositionProbePattern(0, this.moduleCount - 7);
    this.setupPositionAdjustPattern();
    this.setupTimingPattern();
    this.setupTypeInfo(test, maskPattern);
    if (this.typeNumber >= 7) {
      this.setupTypeNumber(test);
    }
    if (this.dataCache == null) {
      this.dataCache = QRCode.createData(this.typeNumber, this.errorCorrectLevel, this.dataList);
    }
    this.mapData(this.dataCache, maskPattern);
  }
  setupPositionProbePattern(row, col) {
    for (let r = -1; r <= 7; r++) {
      if (row + r <= -1 || this.moduleCount <= row + r)
        continue;
      for (let c = -1; c <= 7; c++) {
        if (col + c <= -1 || this.moduleCount <= col + c)
          continue;
        if (0 <= r && r <= 6 && (c == 0 || c == 6) || 0 <= c && c <= 6 && (r == 0 || r == 6) || 2 <= r && r <= 4 && 2 <= c && c <= 4) {
          this.modules[row + r][col + c] = true;
        } else {
          this.modules[row + r][col + c] = false;
        }
      }
    }
  }
  getBestMaskPattern() {
    let minLostPoint = 0;
    let pattern = 0;
    for (let i2 = 0; i2 < 8; i2++) {
      this.makeImpl(true, i2);
      const lostPoint = QRUtil.getLostPoint(this);
      if (i2 == 0 || minLostPoint > lostPoint) {
        minLostPoint = lostPoint;
        pattern = i2;
      }
    }
    return pattern;
  }
  setupTimingPattern() {
    for (let r = 8; r < this.moduleCount - 8; r++) {
      if (this.modules[r][6] != null) {
        continue;
      }
      this.modules[r][6] = r % 2 == 0;
    }
    for (let c = 8; c < this.moduleCount - 8; c++) {
      if (this.modules[6][c] != null) {
        continue;
      }
      this.modules[6][c] = c % 2 == 0;
    }
  }
  setupPositionAdjustPattern() {
    const pos = QRUtil.getPatternPosition(this.typeNumber);
    for (let i2 = 0; i2 < pos.length; i2++) {
      for (let j2 = 0; j2 < pos.length; j2++) {
        const row = pos[i2];
        const col = pos[j2];
        if (this.modules[row][col] != null) {
          continue;
        }
        for (let r = -2; r <= 2; r++) {
          for (let c = -2; c <= 2; c++) {
            if (r == -2 || r == 2 || c == -2 || c == 2 || r == 0 && c == 0) {
              this.modules[row + r][col + c] = true;
            } else {
              this.modules[row + r][col + c] = false;
            }
          }
        }
      }
    }
  }
  setupTypeNumber(test) {
    const bits = QRUtil.getBCHTypeNumber(this.typeNumber);
    for (let i2 = 0; i2 < 18; i2++) {
      const mod = !test && (bits >> i2 & 1) == 1;
      this.modules[Math.floor(i2 / 3)][i2 % 3 + this.moduleCount - 8 - 3] = mod;
    }
    for (let i2 = 0; i2 < 18; i2++) {
      const mod = !test && (bits >> i2 & 1) == 1;
      this.modules[i2 % 3 + this.moduleCount - 8 - 3][Math.floor(i2 / 3)] = mod;
    }
  }
  setupTypeInfo(test, maskPattern) {
    const data = this.errorCorrectLevel << 3 | maskPattern;
    const bits = QRUtil.getBCHTypeInfo(data);
    for (let i2 = 0; i2 < 15; i2++) {
      const mod = !test && (bits >> i2 & 1) == 1;
      if (i2 < 6) {
        this.modules[i2][8] = mod;
      } else if (i2 < 8) {
        this.modules[i2 + 1][8] = mod;
      } else {
        this.modules[this.moduleCount - 15 + i2][8] = mod;
      }
    }
    for (let i2 = 0; i2 < 15; i2++) {
      const mod = !test && (bits >> i2 & 1) == 1;
      if (i2 < 8) {
        this.modules[8][this.moduleCount - i2 - 1] = mod;
      } else if (i2 < 9) {
        this.modules[8][15 - i2 - 1 + 1] = mod;
      } else {
        this.modules[8][15 - i2 - 1] = mod;
      }
    }
    this.modules[this.moduleCount - 8][8] = !test;
  }
  mapData(data, maskPattern) {
    let inc = -1;
    let row = this.moduleCount - 1;
    let bitIndex = 7;
    let byteIndex = 0;
    for (let col = this.moduleCount - 1; col > 0; col -= 2) {
      if (col == 6)
        col--;
      for (; ; ) {
        for (let c = 0; c < 2; c++) {
          if (this.modules[row][col - c] == null) {
            let dark = false;
            if (byteIndex < data.length) {
              dark = (data[byteIndex] >>> bitIndex & 1) == 1;
            }
            const mask = QRUtil.getMask(maskPattern, row, col - c);
            if (mask) {
              dark = !dark;
            }
            this.modules[row][col - c] = dark;
            bitIndex--;
            if (bitIndex == -1) {
              byteIndex++;
              bitIndex = 7;
            }
          }
        }
        row += inc;
        if (row < 0 || this.moduleCount <= row) {
          row -= inc;
          inc = -inc;
          break;
        }
      }
    }
  }
  static createData(typeNumber, errorCorrectLevel, dataList) {
    const rsBlocks = QRRSBlock.getRSBlocks(typeNumber, errorCorrectLevel);
    const buffer = new QRBitBuffer();
    for (let i2 = 0; i2 < dataList.length; i2++) {
      const data = dataList[i2];
      buffer.put(data.mode, 4);
      buffer.put(data.getLength(), QRUtil.getLengthInBits(data.mode, typeNumber));
      data.write(buffer);
    }
    let totalDataCount = 0;
    for (let i2 = 0; i2 < rsBlocks.length; i2++) {
      totalDataCount += rsBlocks[i2].dataCount;
    }
    if (buffer.getLengthInBits() > totalDataCount * 8) {
      throw new Error("code length overflow. (" + buffer.getLengthInBits() + ">" + totalDataCount * 8 + ")");
    }
    if (buffer.getLengthInBits() + 4 <= totalDataCount * 8) {
      buffer.put(0, 4);
    }
    while (buffer.getLengthInBits() % 8 != 0) {
      buffer.putBit(false);
    }
    for (; ; ) {
      if (buffer.getLengthInBits() >= totalDataCount * 8) {
        break;
      }
      buffer.put(QRCode.PAD0, 8);
      if (buffer.getLengthInBits() >= totalDataCount * 8) {
        break;
      }
      buffer.put(QRCode.PAD1, 8);
    }
    return QRCode.createBytes(buffer, rsBlocks);
  }
  static createBytes(buffer, rsBlocks) {
    let offset = 0;
    let maxDcCount = 0;
    let maxEcCount = 0;
    const dcdata = new Array(rsBlocks.length);
    const ecdata = new Array(rsBlocks.length);
    for (let r = 0; r < rsBlocks.length; r++) {
      const dcCount = rsBlocks[r].dataCount;
      const ecCount = rsBlocks[r].totalCount - dcCount;
      maxDcCount = Math.max(maxDcCount, dcCount);
      maxEcCount = Math.max(maxEcCount, ecCount);
      dcdata[r] = new Array(dcCount);
      for (let i2 = 0; i2 < dcdata[r].length; i2++) {
        dcdata[r][i2] = 255 & buffer.buffer[i2 + offset];
      }
      offset += dcCount;
      const rsPoly = QRUtil.getErrorCorrectPolynomial(ecCount);
      const rawPoly = new QRPolynomial(dcdata[r], rsPoly.getLength() - 1);
      const modPoly = rawPoly.mod(rsPoly);
      ecdata[r] = new Array(rsPoly.getLength() - 1);
      for (let i2 = 0; i2 < ecdata[r].length; i2++) {
        const modIndex = i2 + modPoly.getLength() - ecdata[r].length;
        ecdata[r][i2] = modIndex >= 0 ? modPoly.get(modIndex) : 0;
      }
    }
    let totalCodeCount = 0;
    for (let i2 = 0; i2 < rsBlocks.length; i2++) {
      totalCodeCount += rsBlocks[i2].totalCount;
    }
    const data = new Array(totalCodeCount);
    let index = 0;
    for (let i2 = 0; i2 < maxDcCount; i2++) {
      for (let r = 0; r < rsBlocks.length; r++) {
        if (i2 < dcdata[r].length) {
          data[index++] = dcdata[r][i2];
        }
      }
    }
    for (let i2 = 0; i2 < maxEcCount; i2++) {
      for (let r = 0; r < rsBlocks.length; r++) {
        if (i2 < ecdata[r].length) {
          data[index++] = ecdata[r][i2];
        }
      }
    }
    return data;
  }
};
QRCode.PAD0 = 236;
QRCode.PAD1 = 17;
function generate(text2, level = "L", version = -1) {
  const qr = new QRCode(version, ErrorCorrectLevel[level]);
  const rects = [];
  qr.addData(text2);
  qr.make();
  const rows = qr.modules;
  const size = rows.length;
  for (const [y, row] of rows.entries()) {
    let rect;
    for (const [x, on] of row.entries()) {
      if (on) {
        if (!rect)
          rect = { x, y, width: 0, height: 1 };
        rect.width++;
      } else {
        if (rect && rect.width > 0) {
          rects.push(rect);
        }
        rect = void 0;
      }
    }
    if (rect && rect.width > 0) {
      rects.push(rect);
    }
  }
  const svg = [
    `<svg xmlns="http://www.w3.org/2000/svg" width="300" viewBox="0 0 ${size} ${size}">`
  ];
  for (const { x, y, width, height } of rects) {
    svg.push(`<rect x="${x}" y="${y}" width="${width}" height="${height}" />`);
  }
  svg.push("</svg>");
  return svg.join("");
}
function add_css$f(target) {
  append_styles(target, "svelte-1wvj6y8", "div.svelte-1wvj6y8{position:relative;display:grid;background:var(--body-background-color);border-radius:var(--space-s);padding:var(--space-s);border:1px solid var(--qr-border-color);aspect-ratio:1;align-self:stretch}span.svelte-1wvj6y8{background:white;padding:var(--space-xs);border-radius:var(--space-2xs);transition:scale 200ms ease;z-index:2}span.svelte-1wvj6y8 svg{width:100%;height:100%}");
}
function create_if_block$7(ctx) {
  let div;
  let span;
  let raw_value = generate(
    /*data*/
    ctx[0]
  ) + "";
  let span_style_value;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      span = element("span");
      attr(span, "style", span_style_value = /*expanded*/
      ctx[1] ? expandedStyles : "");
      attr(span, "class", "svelte-1wvj6y8");
      attr(div, "class", "svelte-1wvj6y8");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span);
      span.innerHTML = raw_value;
      if (!mounted) {
        dispose = [
          listen(
            span,
            "click",
            /*collapse*/
            ctx[2]
          ),
          listen(
            span,
            "keydown",
            /*collapse*/
            ctx[2]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*data*/
      1 && raw_value !== (raw_value = generate(
        /*data*/
        ctx2[0]
      ) + ""))
        span.innerHTML = raw_value;
      if (dirty & /*expanded*/
      2 && span_style_value !== (span_style_value = /*expanded*/
      ctx2[1] ? expandedStyles : "")) {
        attr(span, "style", span_style_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$j(ctx) {
  let if_block_anchor;
  let if_block = (
    /*data*/
    ctx[0] && create_if_block$7(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (
        /*data*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$7(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
var expandedStyles = "scale: 2; transform-origin: center;";
function instance$j($$self, $$props, $$invalidate) {
  let { data = "" } = $$props;
  let expanded = false;
  const collapse = () => {
    $$invalidate(1, expanded = false);
  };
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(0, data = $$props2.data);
  };
  return [data, expanded, collapse];
}
var Qr = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$j, create_fragment$j, safe_not_equal, { data: 0 }, add_css$f);
  }
};
function add_css$e(target) {
  append_styles(target, "svelte-1j7j5xe", "div.svelte-1j7j5xe{display:flex;background-color:var(--text-area-background);padding:var(--space-m);border-radius:var(--border-radius-inner)}textarea.svelte-1j7j5xe{flex:1;color:var(--text-area-text-color);background-color:var(--text-area-background);border:none;font-size:var(--fs-0);font-weight:600;line-height:1.5;resize:none;opacity:0.75}");
}
function create_fragment$i(ctx) {
  let div;
  let textarea;
  let textarea_value_value;
  return {
    c() {
      div = element("div");
      textarea = element("textarea");
      attr(textarea, "rows", "10");
      textarea.readOnly = true;
      textarea.value = textarea_value_value = /*data*/
      ctx[0].content;
      attr(textarea, "class", "svelte-1j7j5xe");
      attr(div, "class", "svelte-1j7j5xe");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, textarea);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*data*/
      1 && textarea_value_value !== (textarea_value_value = /*data*/
      ctx2[0].content)) {
        textarea.value = textarea_value_value;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function instance$i($$self, $$props, $$invalidate) {
  let { data = {} } = $$props;
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(0, data = $$props2.data);
  };
  return [data];
}
var Textarea = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$i, create_fragment$i, safe_not_equal, { data: 0 }, add_css$e);
  }
};
function add_css$d(target) {
  append_styles(target, "svelte-18rgh1v", "h3.svelte-18rgh1v{color:var(--body-text-color);font-size:var(--fs-2);font-weight:600;text-align:center;margin:0}");
}
function create_fragment$h(ctx) {
  let h3;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  return {
    c() {
      h3 = element("h3");
      if (default_slot)
        default_slot.c();
      attr(h3, "class", "svelte-18rgh1v");
    },
    m(target, anchor) {
      insert(target, h3, anchor);
      if (default_slot) {
        default_slot.m(h3, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(h3);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance$h($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var BodyTitle = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$h, create_fragment$h, safe_not_equal, {}, add_css$d);
  }
};
function add_css$c(target) {
  append_styles(target, "svelte-9xif45", "p.svelte-9xif45{color:var(--body-text-color-variant);font-size:var(--fs-1);font-weight:400;text-align:center;margin:0}");
}
function create_fragment$g(ctx) {
  let p2;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  return {
    c() {
      p2 = element("p");
      if (default_slot)
        default_slot.c();
      attr(p2, "class", "svelte-9xif45");
    },
    m(target, anchor) {
      insert(target, p2, anchor);
      if (default_slot) {
        default_slot.m(p2, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(p2);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance$g($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var BodyText = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$g, create_fragment$g, safe_not_equal, {}, add_css$c);
  }
};
function add_css$b(target) {
  append_styles(target, "svelte-zwsiaf", "div.svelte-zwsiaf{display:flex;flex-direction:column;gap:var(--space-m);gap:var(--space-l)}.text.svelte-zwsiaf{gap:var(--space-s)}");
}
function get_each_context$3(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i2];
  return child_ctx;
}
function create_default_slot_1$4(ctx) {
  var _a;
  let t_value = (
    /*$prompt*/
    ((_a = ctx[0]) == null ? void 0 : _a.args.title) + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      var _a2;
      if (dirty & /*$prompt*/
      1 && t_value !== (t_value = /*$prompt*/
      ((_a2 = ctx2[0]) == null ? void 0 : _a2.args.title) + ""))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t2);
    }
  };
}
function create_default_slot$6(ctx) {
  var _a;
  let t_value = (
    /*$prompt*/
    ((_a = ctx[0]) == null ? void 0 : _a.args.body) + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      var _a2;
      if (dirty & /*$prompt*/
      1 && t_value !== (t_value = /*$prompt*/
      ((_a2 = ctx2[0]) == null ? void 0 : _a2.args.body) + ""))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t2);
    }
  };
}
function create_each_block$3(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    /*component*/
    ctx[6].props
  ];
  var switch_value = (
    /*component*/
    ctx[6].component
  );
  function switch_props(ctx2) {
    let switch_instance_props = {};
    for (let i2 = 0; i2 < switch_instance_spread_levels.length; i2 += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i2]);
    }
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props());
    switch_instance.$on(
      "complete",
      /*complete_handler*/
      ctx[4]
    );
    switch_instance.$on(
      "cancel",
      /*cancel_handler*/
      ctx[5]
    );
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_instance_changes = dirty & /*$elements*/
      2 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(
        /*component*/
        ctx2[6].props
      )]) : {};
      if (switch_value !== (switch_value = /*component*/
      ctx2[6].component)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props());
          switch_instance.$on(
            "complete",
            /*complete_handler*/
            ctx2[4]
          );
          switch_instance.$on(
            "cancel",
            /*cancel_handler*/
            ctx2[5]
          );
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_fragment$f(ctx) {
  let div1;
  let div0;
  let bodytitle;
  let t0;
  let bodytext;
  let t1;
  let current;
  bodytitle = new BodyTitle({
    props: {
      $$slots: { default: [create_default_slot_1$4] },
      $$scope: { ctx }
    }
  });
  bodytext = new BodyText({
    props: {
      $$slots: { default: [create_default_slot$6] },
      $$scope: { ctx }
    }
  });
  let each_value = (
    /*$elements*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$3(get_each_context$3(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      create_component(bodytitle.$$.fragment);
      t0 = space();
      create_component(bodytext.$$.fragment);
      t1 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div0, "class", "text svelte-zwsiaf");
      attr(div1, "class", "svelte-zwsiaf");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      mount_component(bodytitle, div0, null);
      append(div0, t0);
      mount_component(bodytext, div0, null);
      append(div1, t1);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(div1, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      const bodytitle_changes = {};
      if (dirty & /*$$scope, $prompt*/
      513) {
        bodytitle_changes.$$scope = { dirty, ctx: ctx2 };
      }
      bodytitle.$set(bodytitle_changes);
      const bodytext_changes = {};
      if (dirty & /*$$scope, $prompt*/
      513) {
        bodytext_changes.$$scope = { dirty, ctx: ctx2 };
      }
      bodytext.$set(bodytext_changes);
      if (dirty & /*$elements, dispatch*/
      10) {
        each_value = /*$elements*/
        ctx2[1];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$3(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$3(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div1, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(bodytitle.$$.fragment, local);
      transition_in(bodytext.$$.fragment, local);
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      transition_out(bodytitle.$$.fragment, local);
      transition_out(bodytext.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(bodytitle);
      destroy_component(bodytext);
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance$f($$self, $$props, $$invalidate) {
  let $prompt;
  let $elements;
  component_subscribe($$self, prompt, ($$value) => $$invalidate(0, $prompt = $$value));
  const elements = derived(prompt, ($prompt2) => {
    const components = [];
    if ($prompt2) {
      $prompt2.args.elements.forEach((element2) => {
        switch (element2.type) {
          case "accept": {
            components.push({
              component: Accept,
              props: { data: element2.data }
            });
            break;
          }
          case "asset": {
            components.push({
              component: Asset,
              props: { data: element2.data }
            });
            break;
          }
          case "close": {
            components.push({
              component: Close,
              props: { label: element2.label }
            });
            break;
          }
          case "link": {
            components.push({
              component: Link,
              props: { data: element2.data }
            });
            break;
          }
          case "qr": {
            components.push({
              component: Qr,
              props: { data: element2.data }
            });
            break;
          }
          case "countdown": {
            components.push({
              component: Countdown,
              props: { data: element2.data }
            });
            break;
          }
          case "textarea": {
            components.push({
              component: Textarea,
              props: { data: element2.data }
            });
            break;
          }
          case "button": {
            components.push({
              component: Button,
              props: { data: element2.data }
            });
            break;
          }
          default: {
            throw new Error(`Unknown element type: ${element2.type}`);
          }
        }
      });
    }
    return components;
  });
  component_subscribe($$self, elements, (value) => $$invalidate(1, $elements = value));
  const dispatch2 = createEventDispatcher();
  const complete_handler = () => dispatch2("complete");
  const cancel_handler = () => dispatch2("cancel");
  return [$prompt, $elements, elements, dispatch2, complete_handler, cancel_handler];
}
var Prompt = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$f, create_fragment$f, safe_not_equal, {}, add_css$b);
  }
};
function add_css$a(target) {
  append_styles(target, "svelte-1q25md2", "ul.svelte-1q25md2{list-style:none;padding:0;margin:0}");
}
function create_fragment$e(ctx) {
  let ul;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  return {
    c() {
      ul = element("ul");
      if (default_slot)
        default_slot.c();
      attr(ul, "class", "svelte-1q25md2");
    },
    m(target, anchor) {
      insert(target, ul, anchor);
      if (default_slot) {
        default_slot.m(ul, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(ul);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance$e($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var List = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$e, create_fragment$e, safe_not_equal, {}, add_css$a);
  }
};
function add_css$9(target) {
  append_styles(target, "svelte-1dwmlhd", "li.svelte-1dwmlhd.svelte-1dwmlhd{display:flex}li.svelte-1dwmlhd:not(:last-child) button.svelte-1dwmlhd{border-bottom:1px solid var(--list-divider-color)}li.svelte-1dwmlhd button.svelte-1dwmlhd{flex:1;display:flex;align-items:center;cursor:pointer;border:none;background:none;color:var(--body-text-color);font-size:var(--fs-1);font-weight:500;padding-block:var(--space-s)}.leading.svelte-1dwmlhd>.svelte-1dwmlhd{display:grid;place-content:center;inline-size:var(--space-xl)}.leading.svelte-1dwmlhd img.svelte-1dwmlhd{max-inline-size:30px;max-block-size:30px;object-fit:contain}.trailing.svelte-1dwmlhd.svelte-1dwmlhd{opacity:0.2}li.svelte-1dwmlhd button.svelte-1dwmlhd:hover{background:var(--list-item-background-color-hover)}li.svelte-1dwmlhd button:hover .trailing.svelte-1dwmlhd{opacity:1}span.svelte-1dwmlhd.svelte-1dwmlhd{flex:1;text-align:start;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;padding-inline-start:var(--space-xs)}");
}
function create_if_block_2$3(ctx) {
  let div;
  let icon;
  let current;
  icon = new Icon({ props: { name: (
    /*leadingIcon*/
    ctx[2]
  ) } });
  return {
    c() {
      div = element("div");
      create_component(icon.$$.fragment);
      attr(div, "class", "icon svelte-1dwmlhd");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(icon, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const icon_changes = {};
      if (dirty & /*leadingIcon*/
      4)
        icon_changes.name = /*leadingIcon*/
        ctx2[2];
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(icon);
    }
  };
}
function create_if_block_1$4(ctx) {
  let div;
  let img;
  let img_src_value;
  let img_alt_value;
  return {
    c() {
      div = element("div");
      img = element("img");
      if (!src_url_equal(img.src, img_src_value = /*logo*/
      ctx[4]))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = `${/*label*/
      ctx[0]} logo`);
      attr(img, "class", "svelte-1dwmlhd");
      attr(div, "class", "logo svelte-1dwmlhd");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, img);
    },
    p(ctx2, dirty) {
      if (dirty & /*logo*/
      16 && !src_url_equal(img.src, img_src_value = /*logo*/
      ctx2[4])) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*label*/
      1 && img_alt_value !== (img_alt_value = `${/*label*/
      ctx2[0]} logo`)) {
        attr(img, "alt", img_alt_value);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block$6(ctx) {
  let div;
  let icon;
  let current;
  icon = new Icon({ props: { name: (
    /*trailingIcon*/
    ctx[3]
  ) } });
  return {
    c() {
      div = element("div");
      create_component(icon.$$.fragment);
      attr(div, "class", "trailing svelte-1dwmlhd");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(icon, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const icon_changes = {};
      if (dirty & /*trailingIcon*/
      8)
        icon_changes.name = /*trailingIcon*/
        ctx2[3];
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(icon);
    }
  };
}
function create_fragment$d(ctx) {
  let li;
  let button;
  let div;
  let current_block_type_index;
  let if_block0;
  let t0;
  let span;
  let t1;
  let t2;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_1$4, create_if_block_2$3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*logo*/
      ctx2[4]
    )
      return 0;
    if (
      /*leadingIcon*/
      ctx2[2]
    )
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  let if_block1 = (
    /*trailingIcon*/
    ctx[3] && create_if_block$6(ctx)
  );
  return {
    c() {
      li = element("li");
      button = element("button");
      div = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      span = element("span");
      t1 = text(
        /*label*/
        ctx[0]
      );
      t2 = space();
      if (if_block1)
        if_block1.c();
      attr(div, "class", "leading svelte-1dwmlhd");
      attr(span, "class", "svelte-1dwmlhd");
      attr(button, "class", "svelte-1dwmlhd");
      attr(li, "class", "svelte-1dwmlhd");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, button);
      append(button, div);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div, null);
      }
      append(button, t0);
      append(button, span);
      append(span, t1);
      append(button, t2);
      if (if_block1)
        if_block1.m(button, null);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", function() {
          if (is_function(
            /*onClick*/
            ctx[1]
          ))
            ctx[1].apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx, dirty);
        }
      } else {
        if (if_block0) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block0 = if_blocks[current_block_type_index];
          if (!if_block0) {
            if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
            if_block0.c();
          } else {
            if_block0.p(ctx, dirty);
          }
          transition_in(if_block0, 1);
          if_block0.m(div, null);
        } else {
          if_block0 = null;
        }
      }
      if (!current || dirty & /*label*/
      1)
        set_data(
          t1,
          /*label*/
          ctx[0]
        );
      if (
        /*trailingIcon*/
        ctx[3]
      ) {
        if (if_block1) {
          if_block1.p(ctx, dirty);
          if (dirty & /*trailingIcon*/
          8) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$6(ctx);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(button, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(li);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      if (if_block1)
        if_block1.d();
      mounted = false;
      dispose();
    }
  };
}
function instance$d($$self, $$props, $$invalidate) {
  let { label } = $$props;
  let { onClick } = $$props;
  let { leadingIcon = void 0 } = $$props;
  let { trailingIcon = "chevron-right" } = $$props;
  let { logo = void 0 } = $$props;
  $$self.$$set = ($$props2) => {
    if ("label" in $$props2)
      $$invalidate(0, label = $$props2.label);
    if ("onClick" in $$props2)
      $$invalidate(1, onClick = $$props2.onClick);
    if ("leadingIcon" in $$props2)
      $$invalidate(2, leadingIcon = $$props2.leadingIcon);
    if ("trailingIcon" in $$props2)
      $$invalidate(3, trailingIcon = $$props2.trailingIcon);
    if ("logo" in $$props2)
      $$invalidate(4, logo = $$props2.logo);
  };
  return [label, onClick, leadingIcon, trailingIcon, logo];
}
var ListItem = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance$d,
      create_fragment$d,
      safe_not_equal,
      {
        label: 0,
        onClick: 1,
        leadingIcon: 2,
        trailingIcon: 3,
        logo: 4
      },
      add_css$9
    );
  }
};
function add_css$8(target) {
  append_styles(target, "svelte-1d8fcdl", "section.svelte-1d8fcdl{display:flex;flex-direction:column;gap:var(--space-s)}");
}
function get_each_context$2(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list[i2];
  return child_ctx;
}
function create_if_block$5(ctx) {
  let section;
  let bodytitle;
  let t2;
  let list;
  let current;
  bodytitle = new BodyTitle({
    props: {
      $$slots: { default: [create_default_slot_1$3] },
      $$scope: { ctx }
    }
  });
  list = new List({
    props: {
      $$slots: { default: [create_default_slot$5] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      section = element("section");
      create_component(bodytitle.$$.fragment);
      t2 = space();
      create_component(list.$$.fragment);
      attr(section, "class", "svelte-1d8fcdl");
    },
    m(target, anchor) {
      insert(target, section, anchor);
      mount_component(bodytitle, section, null);
      append(section, t2);
      mount_component(list, section, null);
      current = true;
    },
    p(ctx2, dirty) {
      const bodytitle_changes = {};
      if (dirty & /*$$scope, title*/
      130) {
        bodytitle_changes.$$scope = { dirty, ctx: ctx2 };
      }
      bodytitle.$set(bodytitle_changes);
      const list_changes = {};
      if (dirty & /*$$scope, chains*/
      129) {
        list_changes.$$scope = { dirty, ctx: ctx2 };
      }
      list.$set(list_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(bodytitle.$$.fragment, local);
      transition_in(list.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(bodytitle.$$.fragment, local);
      transition_out(list.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(section);
      destroy_component(bodytitle);
      destroy_component(list);
    }
  };
}
function create_default_slot_1$3(ctx) {
  let t2;
  return {
    c() {
      t2 = text(
        /*title*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*title*/
      2)
        set_data(
          t2,
          /*title*/
          ctx2[1]
        );
    },
    d(detaching) {
      if (detaching)
        detach(t2);
    }
  };
}
function create_each_block$2(ctx) {
  let listitem;
  let current;
  function func() {
    return (
      /*func*/
      ctx[3](
        /*chain*/
        ctx[4]
      )
    );
  }
  listitem = new ListItem({
    props: {
      label: (
        /*chain*/
        ctx[4].name
      ),
      onClick: func,
      leadingIcon: "wharf",
      logo: getThemedLogo(
        /*chain*/
        ctx[4]
      )
    }
  });
  return {
    c() {
      create_component(listitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(listitem, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const listitem_changes = {};
      if (dirty & /*chains*/
      1)
        listitem_changes.label = /*chain*/
        ctx[4].name;
      if (dirty & /*chains*/
      1)
        listitem_changes.onClick = func;
      if (dirty & /*chains*/
      1)
        listitem_changes.logo = getThemedLogo(
          /*chain*/
          ctx[4]
        );
      listitem.$set(listitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(listitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(listitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(listitem, detaching);
    }
  };
}
function create_default_slot$5(ctx) {
  let each_1_anchor;
  let current;
  let each_value = (
    /*chains*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$2(get_each_context$2(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*chains, dispatch, getThemedLogo*/
      5) {
        each_value = /*chains*/
        ctx2[0];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$2(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$2(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_fragment$c(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*chains*/
    ctx[0] && create_if_block$5(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*chains*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*chains*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$5(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$c($$self, $$props, $$invalidate) {
  let { chains } = $$props;
  let { title } = $$props;
  const dispatch2 = createEventDispatcher();
  const func = (chain) => dispatch2("select", chain.id);
  $$self.$$set = ($$props2) => {
    if ("chains" in $$props2)
      $$invalidate(0, chains = $$props2.chains);
    if ("title" in $$props2)
      $$invalidate(1, title = $$props2.title);
  };
  return [chains, title, dispatch2, func];
}
var Blockchain = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$c, create_fragment$c, safe_not_equal, { chains: 0, title: 1 }, add_css$8);
  }
};
function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i2 = decorators.length - 1; i2 >= 0; i2--)
      if (d2 = decorators[i2])
        r = (c < 3 ? d2(r) : c > 3 ? d2(target, key, r) : d2(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var GetAccountsByAuthorizersRow = class GetAccountsByAuthorizersRow2 extends Struct {
};
__decorate([
  Struct.field(Name)
], GetAccountsByAuthorizersRow.prototype, "account_name", void 0);
__decorate([
  Struct.field(Name)
], GetAccountsByAuthorizersRow.prototype, "permission_name", void 0);
__decorate([
  Struct.field(PublicKey)
], GetAccountsByAuthorizersRow.prototype, "authorizing_key", void 0);
__decorate([
  Struct.field(Weight)
], GetAccountsByAuthorizersRow.prototype, "weight", void 0);
__decorate([
  Struct.field(UInt32)
], GetAccountsByAuthorizersRow.prototype, "threshold", void 0);
GetAccountsByAuthorizersRow = __decorate([
  Struct.type("get_accounts_by_authorizers")
], GetAccountsByAuthorizersRow);
var GetAccountsByAuthorizers = class GetAccountsByAuthorizers2 extends Struct {
};
__decorate([
  Struct.field(GetAccountsByAuthorizersRow, { array: true })
], GetAccountsByAuthorizers.prototype, "accounts", void 0);
GetAccountsByAuthorizers = __decorate([
  Struct.type("get_accounts_by_authorizers")
], GetAccountsByAuthorizers);
function add_css$7(target) {
  append_styles(target, "svelte-3b7p6", "input.svelte-3b7p6{box-sizing:border-box;height:var(--space-2xl);border-radius:var(--border-radius-inner);border:1px solid var(--input-border-color);padding-inline:var(--space-m);color:var(--body-text-color);background-color:var(--body-background-color);font-size:var(--fs-1)}input.svelte-3b7p6::placeholder{font-size:var(--fs-1);color:var(--input-placeholder-color);font-style:italic}input.svelte-3b7p6:hover{border:1px solid transparent;outline:2px solid var(--input-border-color-hover);background-color:var(--input-background-focus)}input.svelte-3b7p6:focus-within{border:1px solid transparent;outline:2px solid var(--input-border-color-focus);background-color:var(--input-background-focus)}input.error.svelte-3b7p6{border:1px solid var(--error-color);color:var(--error-color)}input.error.svelte-3b7p6:focus-within{border:1px solid transparent;color:var(--body-text-color)}");
}
function create_fragment$b(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      input.autofocus = /*autofocus*/
      ctx[3];
      attr(input, "type", "text");
      attr(
        input,
        "placeholder",
        /*placeholder*/
        ctx[1]
      );
      attr(input, "class", "svelte-3b7p6");
      toggle_class(
        input,
        "error",
        /*error*/
        ctx[4]
      );
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(
        input,
        /*value*/
        ctx[0]
      );
      if (
        /*autofocus*/
        ctx[3]
      )
        input.focus();
      if (!mounted) {
        dispose = [
          listen(input, "keyup", prevent_default(function() {
            if (is_function(
              /*onKeyup*/
              ctx[2]
            ))
              ctx[2].apply(this, arguments);
          })),
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[5]
          )
        ];
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (dirty & /*autofocus*/
      8) {
        input.autofocus = /*autofocus*/
        ctx[3];
      }
      if (dirty & /*placeholder*/
      2) {
        attr(
          input,
          "placeholder",
          /*placeholder*/
          ctx[1]
        );
      }
      if (dirty & /*value*/
      1 && input.value !== /*value*/
      ctx[0]) {
        set_input_value(
          input,
          /*value*/
          ctx[0]
        );
      }
      if (dirty & /*error*/
      16) {
        toggle_class(
          input,
          "error",
          /*error*/
          ctx[4]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(input);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$b($$self, $$props, $$invalidate) {
  let { value } = $$props;
  let { placeholder } = $$props;
  let { onKeyup } = $$props;
  let { autofocus = false } = $$props;
  let { error: error2 = false } = $$props;
  function input_input_handler() {
    value = this.value;
    $$invalidate(0, value);
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("placeholder" in $$props2)
      $$invalidate(1, placeholder = $$props2.placeholder);
    if ("onKeyup" in $$props2)
      $$invalidate(2, onKeyup = $$props2.onKeyup);
    if ("autofocus" in $$props2)
      $$invalidate(3, autofocus = $$props2.autofocus);
    if ("error" in $$props2)
      $$invalidate(4, error2 = $$props2.error);
  };
  return [value, placeholder, onKeyup, autofocus, error2, input_input_handler];
}
var TextInput = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance$b,
      create_fragment$b,
      safe_not_equal,
      {
        value: 0,
        placeholder: 1,
        onKeyup: 2,
        autofocus: 3,
        error: 4
      },
      add_css$7
    );
  }
};
function add_css$6(target) {
  append_styles(target, "svelte-3zo29t", "div.svelte-3zo29t{display:flex;flex-direction:column;align-items:center;gap:var(--space-s);text-align:center;color:var(--body-text-color);margin-block:var(--space-s)}svg.svelte-3zo29t{--size:var(--space-3xl);width:var(--size);height:var(--size)}h2.svelte-3zo29t{font-size:var(--fs-3);font-weight:600;margin:0}p.svelte-3zo29t{font-size:var(--fs-1);font-weight:400;margin:0;max-width:var(--measure);overflow-wrap:anywhere}");
}
function create_fragment$a(ctx) {
  let div;
  let svg;
  let circle;
  let line0;
  let line1;
  let t0;
  let h2;
  let t1;
  let t2;
  let p2;
  let t3;
  return {
    c() {
      div = element("div");
      svg = svg_element("svg");
      circle = svg_element("circle");
      line0 = svg_element("line");
      line1 = svg_element("line");
      t0 = space();
      h2 = element("h2");
      t1 = text(
        /*title*/
        ctx[0]
      );
      t2 = space();
      p2 = element("p");
      t3 = text(
        /*details*/
        ctx[1]
      );
      attr(circle, "cx", "12");
      attr(circle, "cy", "12");
      attr(circle, "r", "10");
      attr(line0, "x1", "12");
      attr(line0, "y1", "8");
      attr(line0, "x2", "12");
      attr(line0, "y2", "12");
      attr(line1, "x1", "12");
      attr(line1, "y1", "16");
      attr(line1, "x2", "12.01");
      attr(line1, "y2", "16");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "fill", "none");
      attr(svg, "stroke", "currentColor");
      attr(svg, "stroke-width", "2");
      attr(svg, "stroke-linecap", "round");
      attr(svg, "stroke-linejoin", "round");
      attr(svg, "class", "svelte-3zo29t");
      attr(h2, "class", "svelte-3zo29t");
      attr(p2, "class", "svelte-3zo29t");
      attr(div, "class", "svelte-3zo29t");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, svg);
      append(svg, circle);
      append(svg, line0);
      append(svg, line1);
      append(div, t0);
      append(div, h2);
      append(h2, t1);
      append(div, t2);
      append(div, p2);
      append(p2, t3);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*title*/
      1)
        set_data(
          t1,
          /*title*/
          ctx2[0]
        );
      if (dirty & /*details*/
      2)
        set_data(
          t3,
          /*details*/
          ctx2[1]
        );
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function instance$a($$self, $$props, $$invalidate) {
  let { title } = $$props;
  let { details } = $$props;
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
    if ("details" in $$props2)
      $$invalidate(1, details = $$props2.details);
  };
  return [title, details];
}
var WarningMessage = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$a, create_fragment$a, safe_not_equal, { title: 0, details: 1 }, add_css$6);
  }
};
function add_css$5(target) {
  append_styles(target, "svelte-13p224c", "section.svelte-13p224c{display:flex;flex-direction:column;gap:var(--space-s)}p.loading.svelte-13p224c{margin:0;text-align:center;height:var(--space-4xl)}p.error.svelte-13p224c{margin:0;text-align:center;color:var(--error-color)}.input-group.svelte-13p224c{display:flex;flex-direction:column;gap:var(--space-m);margin-top:var(--space-s)}");
}
function get_each_context$1(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[17] = list[i2];
  return child_ctx;
}
function create_default_slot_1$2(ctx) {
  let t_1;
  return {
    c() {
      t_1 = text(
        /*title*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, t_1, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*title*/
      2)
        set_data(
          t_1,
          /*title*/
          ctx2[1]
        );
    },
    d(detaching) {
      if (detaching)
        detach(t_1);
    }
  };
}
function create_if_block_3$2(ctx) {
  let div;
  let textinput;
  let updating_value;
  let t0;
  let t1;
  let button;
  let current;
  function textinput_value_binding(value) {
    ctx[16](value);
  }
  let textinput_props = {
    onKeyup: (
      /*handleKeyup*/
      ctx[13]
    ),
    placeholder: "Account name",
    autofocus: !/*input*/
    ctx[2],
    error: (
      /*accountNotFound*/
      ctx[5] && /*input*/
      ctx[2] === /*prevInput*/
      ctx[3]
    )
  };
  if (
    /*input*/
    ctx[2] !== void 0
  ) {
    textinput_props.value = /*input*/
    ctx[2];
  }
  textinput = new TextInput({ props: textinput_props });
  binding_callbacks.push(() => bind(textinput, "value", textinput_value_binding));
  let if_block = (
    /*accountNotFound*/
    ctx[5] && create_if_block_4$2(ctx)
  );
  button = new Button({
    props: {
      data: {
        variant: "primary",
        onClick: (
          /*lookup*/
          ctx[12]
        ),
        label: (
          /*$t*/
          ctx[8]("login.enter.lookup", { default: "Lookup Account" })
        )
      }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(textinput.$$.fragment);
      t0 = space();
      if (if_block)
        if_block.c();
      t1 = space();
      create_component(button.$$.fragment);
      attr(div, "class", "input-group svelte-13p224c");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(textinput, div, null);
      append(div, t0);
      if (if_block)
        if_block.m(div, null);
      append(div, t1);
      mount_component(button, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const textinput_changes = {};
      if (dirty & /*input*/
      4)
        textinput_changes.autofocus = !/*input*/
        ctx2[2];
      if (dirty & /*accountNotFound, input, prevInput*/
      44)
        textinput_changes.error = /*accountNotFound*/
        ctx2[5] && /*input*/
        ctx2[2] === /*prevInput*/
        ctx2[3];
      if (!updating_value && dirty & /*input*/
      4) {
        updating_value = true;
        textinput_changes.value = /*input*/
        ctx2[2];
        add_flush_callback(() => updating_value = false);
      }
      textinput.$set(textinput_changes);
      if (
        /*accountNotFound*/
        ctx2[5]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_4$2(ctx2);
          if_block.c();
          if_block.m(div, t1);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      const button_changes = {};
      if (dirty & /*$t*/
      256)
        button_changes.data = {
          variant: "primary",
          onClick: (
            /*lookup*/
            ctx2[12]
          ),
          label: (
            /*$t*/
            ctx2[8]("login.enter.lookup", { default: "Lookup Account" })
          )
        };
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(textinput.$$.fragment, local);
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(textinput);
      if (if_block)
        if_block.d();
      destroy_component(button);
    }
  };
}
function create_if_block_2$2(ctx) {
  let warningmessage;
  let current;
  warningmessage = new WarningMessage({
    props: {
      title: (
        /*$t*/
        ctx[8]("login.select.no_accounts", { default: "No accounts found" })
      ),
      details: (
        /*$t*/
        ctx[8]("login.select.no_match", {
          default: "No accounts found matching {{publicKey}}",
          publicKey: (
            /*walletPlugin*/
            ctx[0].metadata.publicKey
          )
        })
      )
    }
  });
  return {
    c() {
      create_component(warningmessage.$$.fragment);
    },
    m(target, anchor) {
      mount_component(warningmessage, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const warningmessage_changes = {};
      if (dirty & /*$t*/
      256)
        warningmessage_changes.title = /*$t*/
        ctx2[8]("login.select.no_accounts", { default: "No accounts found" });
      if (dirty & /*$t, walletPlugin*/
      257)
        warningmessage_changes.details = /*$t*/
        ctx2[8]("login.select.no_match", {
          default: "No accounts found matching {{publicKey}}",
          publicKey: (
            /*walletPlugin*/
            ctx2[0].metadata.publicKey
          )
        });
      warningmessage.$set(warningmessage_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(warningmessage.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(warningmessage.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(warningmessage, detaching);
    }
  };
}
function create_if_block_1$3(ctx) {
  let list;
  let current;
  list = new List({
    props: {
      $$slots: { default: [create_default_slot$4] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(list.$$.fragment);
    },
    m(target, anchor) {
      mount_component(list, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const list_changes = {};
      if (dirty & /*$$scope, permissions*/
      1048640) {
        list_changes.$$scope = { dirty, ctx: ctx2 };
      }
      list.$set(list_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(list.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(list.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(list, detaching);
    }
  };
}
function create_if_block$4(ctx) {
  let p2;
  let t_1_value = (
    /*$t*/
    ctx[8]("loading", { default: "Loading..." }) + ""
  );
  let t_1;
  return {
    c() {
      p2 = element("p");
      t_1 = text(t_1_value);
      attr(p2, "class", "loading svelte-13p224c");
    },
    m(target, anchor) {
      insert(target, p2, anchor);
      append(p2, t_1);
    },
    p(ctx2, dirty) {
      if (dirty & /*$t*/
      256 && t_1_value !== (t_1_value = /*$t*/
      ctx2[8]("loading", { default: "Loading..." }) + ""))
        set_data(t_1, t_1_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(p2);
    }
  };
}
function create_if_block_4$2(ctx) {
  let p2;
  let t0_value = (
    /*$t*/
    ctx[8]("login.enter.not_found", { default: "Unable to find account" }) + ""
  );
  let t0;
  let t1;
  let t2;
  return {
    c() {
      p2 = element("p");
      t0 = text(t0_value);
      t1 = space();
      t2 = text(
        /*prevInput*/
        ctx[3]
      );
      attr(p2, "class", "error svelte-13p224c");
    },
    m(target, anchor) {
      insert(target, p2, anchor);
      append(p2, t0);
      append(p2, t1);
      append(p2, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*$t*/
      256 && t0_value !== (t0_value = /*$t*/
      ctx2[8]("login.enter.not_found", { default: "Unable to find account" }) + ""))
        set_data(t0, t0_value);
      if (dirty & /*prevInput*/
      8)
        set_data(
          t2,
          /*prevInput*/
          ctx2[3]
        );
    },
    d(detaching) {
      if (detaching)
        detach(p2);
    }
  };
}
function create_each_block$1(ctx) {
  let listitem;
  let current;
  function func() {
    return (
      /*func*/
      ctx[15](
        /*permission*/
        ctx[17]
      )
    );
  }
  listitem = new ListItem({
    props: {
      label: String(
        /*permission*/
        ctx[17]
      ),
      onClick: func
    }
  });
  return {
    c() {
      create_component(listitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(listitem, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const listitem_changes = {};
      if (dirty & /*permissions*/
      64)
        listitem_changes.label = String(
          /*permission*/
          ctx[17]
        );
      if (dirty & /*permissions*/
      64)
        listitem_changes.onClick = func;
      listitem.$set(listitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(listitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(listitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(listitem, detaching);
    }
  };
}
function create_default_slot$4(ctx) {
  let each_1_anchor;
  let current;
  let each_value = (
    /*permissions*/
    ctx[6]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$1(get_each_context$1(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*String, permissions, dispatch*/
      1088) {
        each_value = /*permissions*/
        ctx2[6];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$1(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$1(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_fragment$9(ctx) {
  let section;
  let bodytitle;
  let t_1;
  let current_block_type_index;
  let if_block;
  let current;
  bodytitle = new BodyTitle({
    props: {
      $$slots: { default: [create_default_slot_1$2] },
      $$scope: { ctx }
    }
  });
  const if_block_creators = [create_if_block$4, create_if_block_1$3, create_if_block_2$2, create_if_block_3$2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$busy*/
      ctx2[7]
    )
      return 0;
    if (
      /*permissions*/
      ctx2[6] && /*permissions*/
      ctx2[6].length > 0
    )
      return 1;
    if (
      /*walletPlugin*/
      ctx2[0].metadata.publicKey
    )
      return 2;
    if (!/*accountName*/
    ctx2[4])
      return 3;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      section = element("section");
      create_component(bodytitle.$$.fragment);
      t_1 = space();
      if (if_block)
        if_block.c();
      attr(section, "class", "svelte-13p224c");
    },
    m(target, anchor) {
      insert(target, section, anchor);
      mount_component(bodytitle, section, null);
      append(section, t_1);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(section, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      const bodytitle_changes = {};
      if (dirty & /*$$scope, title*/
      1048578) {
        bodytitle_changes.$$scope = { dirty, ctx: ctx2 };
      }
      bodytitle.$set(bodytitle_changes);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(section, null);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(bodytitle.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(bodytitle.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(section);
      destroy_component(bodytitle);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
    }
  };
}
function instance$9($$self, $$props, $$invalidate) {
  let $busy;
  let $t;
  const { t: t2 } = getContext("i18n");
  component_subscribe($$self, t2, (value) => $$invalidate(8, $t = value));
  let { client } = $$props;
  let { walletPlugin } = $$props;
  let { title } = $$props;
  const dispatch2 = createEventDispatcher();
  let busy = writable(true);
  component_subscribe($$self, busy, (value) => $$invalidate(7, $busy = value));
  let input = "";
  let prevInput = "";
  let accountName;
  let accountNotFound = false;
  let permissions;
  onMount(async () => {
    if (walletPlugin.config.requiresPermissionSelect) {
      const response = await client.call({
        path: "/v1/chain/get_accounts_by_authorizers",
        params: { keys: [walletPlugin.metadata.publicKey] }
      });
      busy.set(false);
      $$invalidate(6, permissions = response.accounts.map((account) => PermissionLevel.from(`${account.account_name}@${account.permission_name}`)));
    } else if (walletPlugin.config.requiresPermissionEntry) {
      busy.set(false);
      $$invalidate(6, permissions = []);
    }
  });
  async function lookup() {
    busy.set(true);
    try {
      const response = await client.v1.chain.get_account(input);
      if (response.account_name.equals(input)) {
        $$invalidate(4, accountName = response.account_name);
        $$invalidate(6, permissions = response.permissions.map((permission) => PermissionLevel.from(`${response.account_name}@${permission.perm_name}`)));
      }
      $$invalidate(5, accountNotFound = false);
    } catch (error2) {
      $$invalidate(5, accountNotFound = true);
    } finally {
      $$invalidate(3, prevInput = input);
      busy.set(false);
    }
  }
  function handleKeyup(event) {
    if (event.code == "Enter") {
      event.preventDefault();
      lookup();
      return false;
    }
  }
  const func = (permission) => dispatch2("select", permission);
  function textinput_value_binding(value) {
    input = value;
    $$invalidate(2, input);
  }
  $$self.$$set = ($$props2) => {
    if ("client" in $$props2)
      $$invalidate(14, client = $$props2.client);
    if ("walletPlugin" in $$props2)
      $$invalidate(0, walletPlugin = $$props2.walletPlugin);
    if ("title" in $$props2)
      $$invalidate(1, title = $$props2.title);
  };
  return [
    walletPlugin,
    title,
    input,
    prevInput,
    accountName,
    accountNotFound,
    permissions,
    $busy,
    $t,
    t2,
    dispatch2,
    busy,
    lookup,
    handleKeyup,
    client,
    func,
    textinput_value_binding
  ];
}
var Permission = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$9, create_fragment$9, safe_not_equal, { client: 14, walletPlugin: 0, title: 1 }, add_css$5);
  }
};
function add_css$4(target) {
  append_styles(target, "svelte-lwrp5l", "section.svelte-lwrp5l{display:flex;flex-direction:column;gap:var(--space-s)}");
}
function get_each_context(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list[i2];
  child_ctx[6] = i2;
  return child_ctx;
}
function create_if_block$3(ctx) {
  let section;
  let bodytitle;
  let t2;
  let list;
  let current;
  bodytitle = new BodyTitle({
    props: {
      $$slots: { default: [create_default_slot_1$1] },
      $$scope: { ctx }
    }
  });
  list = new List({
    props: {
      $$slots: { default: [create_default_slot$3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      section = element("section");
      create_component(bodytitle.$$.fragment);
      t2 = space();
      create_component(list.$$.fragment);
      attr(section, "class", "svelte-lwrp5l");
    },
    m(target, anchor) {
      insert(target, section, anchor);
      mount_component(bodytitle, section, null);
      append(section, t2);
      mount_component(list, section, null);
      current = true;
    },
    p(ctx2, dirty) {
      const bodytitle_changes = {};
      if (dirty & /*$$scope, title*/
      130) {
        bodytitle_changes.$$scope = { dirty, ctx: ctx2 };
      }
      bodytitle.$set(bodytitle_changes);
      const list_changes = {};
      if (dirty & /*$$scope, wallets*/
      129) {
        list_changes.$$scope = { dirty, ctx: ctx2 };
      }
      list.$set(list_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(bodytitle.$$.fragment, local);
      transition_in(list.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(bodytitle.$$.fragment, local);
      transition_out(list.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(section);
      destroy_component(bodytitle);
      destroy_component(list);
    }
  };
}
function create_default_slot_1$1(ctx) {
  let t2;
  return {
    c() {
      t2 = text(
        /*title*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*title*/
      2)
        set_data(
          t2,
          /*title*/
          ctx2[1]
        );
    },
    d(detaching) {
      if (detaching)
        detach(t2);
    }
  };
}
function create_each_block(ctx) {
  let listitem;
  let current;
  function func() {
    return (
      /*func*/
      ctx[3](
        /*index*/
        ctx[6]
      )
    );
  }
  listitem = new ListItem({
    props: {
      label: (
        /*wallet*/
        ctx[4].metadata.name
      ),
      onClick: func,
      leadingIcon: "wallet",
      logo: getThemedLogo(
        /*wallet*/
        ctx[4].metadata
      )
    }
  });
  return {
    c() {
      create_component(listitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(listitem, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const listitem_changes = {};
      if (dirty & /*wallets*/
      1)
        listitem_changes.label = /*wallet*/
        ctx[4].metadata.name;
      if (dirty & /*wallets*/
      1)
        listitem_changes.logo = getThemedLogo(
          /*wallet*/
          ctx[4].metadata
        );
      listitem.$set(listitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(listitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(listitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(listitem, detaching);
    }
  };
}
function create_default_slot$3(ctx) {
  let each_1_anchor;
  let current;
  let each_value = (
    /*wallets*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block(get_each_context(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*wallets, dispatch, getThemedLogo*/
      5) {
        each_value = /*wallets*/
        ctx2[0];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_fragment$8(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*wallets*/
    ctx[0] && create_if_block$3(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*wallets*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*wallets*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$3(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$8($$self, $$props, $$invalidate) {
  let { wallets } = $$props;
  let { title } = $$props;
  const dispatch2 = createEventDispatcher();
  const func = (index) => dispatch2("select", index);
  $$self.$$set = ($$props2) => {
    if ("wallets" in $$props2)
      $$invalidate(0, wallets = $$props2.wallets);
    if ("title" in $$props2)
      $$invalidate(1, title = $$props2.title);
  };
  return [wallets, title, dispatch2, func];
}
var Wallet = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$8, create_fragment$8, safe_not_equal, { wallets: 0, title: 1 }, add_css$4);
  }
};
function cubicOut(t2) {
  const f2 = t2 - 1;
  return f2 * f2 * f2 + 1;
}
function fade(node, { delay = 0, duration = 400, easing = identity } = {}) {
  const o = +getComputedStyle(node).opacity;
  return {
    delay,
    duration,
    easing,
    css: (t2) => `opacity: ${t2 * o}`
  };
}
function fly(node, { delay = 0, duration = 400, easing = cubicOut, x = 0, y = 0, opacity = 0 } = {}) {
  const style = getComputedStyle(node);
  const target_opacity = +style.opacity;
  const transform = style.transform === "none" ? "" : style.transform;
  const od = target_opacity * (1 - opacity);
  return {
    delay,
    duration,
    easing,
    css: (t2, u2) => `
			transform: ${transform} translate(${(1 - t2) * x}px, ${(1 - t2) * y}px);
			opacity: ${target_opacity - od * u2}`
  };
}
function create_fragment$7(ctx) {
  let div;
  let div_intro;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    null
  );
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "class", "transition");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[1]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[1],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      if (!div_intro) {
        add_render_callback(() => {
          div_intro = create_in_transition(div, fly, { duration: 200, x: (
            /*direction*/
            ctx[0]
          ) });
          div_intro.start();
        });
      }
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance$7($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { direction = 0 } = $$props;
  $$self.$$set = ($$props2) => {
    if ("direction" in $$props2)
      $$invalidate(0, direction = $$props2.direction);
    if ("$$scope" in $$props2)
      $$invalidate(1, $$scope = $$props2.$$scope);
  };
  return [direction, $$scope, slots];
}
var Transition = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$7, create_fragment$7, safe_not_equal, { direction: 0 });
  }
};
function create_else_block_1(ctx) {
  let p2;
  let t_1_value = (
    /*$t*/
    ctx[3]("loading", { default: "Loading..." }) + ""
  );
  let t_1;
  return {
    c() {
      p2 = element("p");
      t_1 = text(t_1_value);
    },
    m(target, anchor) {
      insert(target, p2, anchor);
      append(p2, t_1);
    },
    p(ctx2, dirty) {
      if (dirty & /*$t*/
      8 && t_1_value !== (t_1_value = /*$t*/
      ctx2[3]("loading", { default: "Loading..." }) + ""))
        set_data(t_1, t_1_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(p2);
    }
  };
}
function create_if_block$2(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [
    create_if_block_1$2,
    create_if_block_2$1,
    create_if_block_3$1,
    create_if_block_4$1,
    create_else_block$1
  ];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*$step*/
      ctx2[5] === /*Steps*/
      ctx2[0].selectWallet
    )
      return 0;
    if (
      /*$step*/
      ctx2[5] === /*Steps*/
      ctx2[0].selectChain && /*$chains*/
      ctx2[6]
    )
      return 1;
    if (
      /*$step*/
      ctx2[5] === /*Steps*/
      ctx2[0].enterPermission && /*$client*/
      ctx2[7] && /*$walletPlugin*/
      ctx2[8]
    )
      return 2;
    if (
      /*$step*/
      ctx2[5] === /*Steps*/
      ctx2[0].selectPermission && /*$client*/
      ctx2[7] && /*$walletPlugin*/
      ctx2[8]
    )
      return 3;
    return 4;
  }
  current_block_type_index = select_block_type_1(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_else_block$1(ctx) {
  let p2;
  let t_1_value = (
    /*$t*/
    ctx[3]("login.complete", {
      default: "Complete the login using your selected wallet."
    }) + ""
  );
  let t_1;
  return {
    c() {
      p2 = element("p");
      t_1 = text(t_1_value);
    },
    m(target, anchor) {
      insert(target, p2, anchor);
      append(p2, t_1);
    },
    p(ctx2, dirty) {
      if (dirty & /*$t*/
      8 && t_1_value !== (t_1_value = /*$t*/
      ctx2[3]("login.complete", {
        default: "Complete the login using your selected wallet."
      }) + ""))
        set_data(t_1, t_1_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(p2);
    }
  };
}
function create_if_block_4$1(ctx) {
  let transition;
  let current;
  transition = new Transition({
    props: {
      direction: (
        /*transitionDirection*/
        ctx[1]
      ),
      $$slots: { default: [create_default_slot_3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(transition.$$.fragment);
    },
    m(target, anchor) {
      mount_component(transition, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const transition_changes = {};
      if (dirty & /*transitionDirection*/
      2)
        transition_changes.direction = /*transitionDirection*/
        ctx2[1];
      if (dirty & /*$$scope, $client, $walletPlugin, $t*/
      536871304) {
        transition_changes.$$scope = { dirty, ctx: ctx2 };
      }
      transition.$set(transition_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(transition.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(transition.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(transition, detaching);
    }
  };
}
function create_if_block_3$1(ctx) {
  let transition;
  let current;
  transition = new Transition({
    props: {
      direction: (
        /*transitionDirection*/
        ctx[1]
      ),
      $$slots: { default: [create_default_slot_2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(transition.$$.fragment);
    },
    m(target, anchor) {
      mount_component(transition, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const transition_changes = {};
      if (dirty & /*transitionDirection*/
      2)
        transition_changes.direction = /*transitionDirection*/
        ctx2[1];
      if (dirty & /*$$scope, $client, $walletPlugin, $t*/
      536871304) {
        transition_changes.$$scope = { dirty, ctx: ctx2 };
      }
      transition.$set(transition_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(transition.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(transition.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(transition, detaching);
    }
  };
}
function create_if_block_2$1(ctx) {
  let transition;
  let current;
  transition = new Transition({
    props: {
      direction: (
        /*transitionDirection*/
        ctx[1]
      ),
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(transition.$$.fragment);
    },
    m(target, anchor) {
      mount_component(transition, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const transition_changes = {};
      if (dirty & /*transitionDirection*/
      2)
        transition_changes.direction = /*transitionDirection*/
        ctx2[1];
      if (dirty & /*$$scope, $chains, $t*/
      536870984) {
        transition_changes.$$scope = { dirty, ctx: ctx2 };
      }
      transition.$set(transition_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(transition.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(transition.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(transition, detaching);
    }
  };
}
function create_if_block_1$2(ctx) {
  let transition;
  let current;
  transition = new Transition({
    props: {
      direction: (
        /*transitionDirection*/
        ctx[1]
      ),
      $$slots: { default: [create_default_slot$2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(transition.$$.fragment);
    },
    m(target, anchor) {
      mount_component(transition, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const transition_changes = {};
      if (dirty & /*transitionDirection*/
      2)
        transition_changes.direction = /*transitionDirection*/
        ctx2[1];
      if (dirty & /*$$scope, $loginContext, $t*/
      536870924) {
        transition_changes.$$scope = { dirty, ctx: ctx2 };
      }
      transition.$set(transition_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(transition.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(transition.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(transition, detaching);
    }
  };
}
function create_default_slot_3(ctx) {
  let permission;
  let current;
  permission = new Permission({
    props: {
      client: (
        /*$client*/
        ctx[7]
      ),
      walletPlugin: (
        /*$walletPlugin*/
        ctx[8]
      ),
      title: (
        /*$t*/
        ctx[3]("login.select.account", { default: "Select an Account" })
      )
    }
  });
  permission.$on(
    "select",
    /*selectPermission*/
    ctx[16]
  );
  permission.$on(
    "cancel",
    /*unselectChain*/
    ctx[15]
  );
  return {
    c() {
      create_component(permission.$$.fragment);
    },
    m(target, anchor) {
      mount_component(permission, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const permission_changes = {};
      if (dirty & /*$client*/
      128)
        permission_changes.client = /*$client*/
        ctx2[7];
      if (dirty & /*$walletPlugin*/
      256)
        permission_changes.walletPlugin = /*$walletPlugin*/
        ctx2[8];
      if (dirty & /*$t*/
      8)
        permission_changes.title = /*$t*/
        ctx2[3]("login.select.account", { default: "Select an Account" });
      permission.$set(permission_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(permission.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(permission.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(permission, detaching);
    }
  };
}
function create_default_slot_2(ctx) {
  let permission;
  let current;
  permission = new Permission({
    props: {
      client: (
        /*$client*/
        ctx[7]
      ),
      walletPlugin: (
        /*$walletPlugin*/
        ctx[8]
      ),
      title: (
        /*$t*/
        ctx[3]("login.enter.account", { default: "Enter account name" })
      )
    }
  });
  permission.$on(
    "select",
    /*selectPermission*/
    ctx[16]
  );
  permission.$on(
    "cancel",
    /*unselectChain*/
    ctx[15]
  );
  return {
    c() {
      create_component(permission.$$.fragment);
    },
    m(target, anchor) {
      mount_component(permission, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const permission_changes = {};
      if (dirty & /*$client*/
      128)
        permission_changes.client = /*$client*/
        ctx2[7];
      if (dirty & /*$walletPlugin*/
      256)
        permission_changes.walletPlugin = /*$walletPlugin*/
        ctx2[8];
      if (dirty & /*$t*/
      8)
        permission_changes.title = /*$t*/
        ctx2[3]("login.enter.account", { default: "Enter account name" });
      permission.$set(permission_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(permission.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(permission.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(permission, detaching);
    }
  };
}
function create_default_slot_1(ctx) {
  let blockchain;
  let current;
  blockchain = new Blockchain({
    props: {
      chains: (
        /*$chains*/
        ctx[6]
      ),
      title: (
        /*$t*/
        ctx[3]("login.select.blockchain", { default: "Select a Blockchain" })
      )
    }
  });
  blockchain.$on(
    "select",
    /*selectChain*/
    ctx[14]
  );
  blockchain.$on(
    "cancel",
    /*unselectWallet*/
    ctx[18]
  );
  return {
    c() {
      create_component(blockchain.$$.fragment);
    },
    m(target, anchor) {
      mount_component(blockchain, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const blockchain_changes = {};
      if (dirty & /*$chains*/
      64)
        blockchain_changes.chains = /*$chains*/
        ctx2[6];
      if (dirty & /*$t*/
      8)
        blockchain_changes.title = /*$t*/
        ctx2[3]("login.select.blockchain", { default: "Select a Blockchain" });
      blockchain.$set(blockchain_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(blockchain.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(blockchain.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(blockchain, detaching);
    }
  };
}
function create_default_slot$2(ctx) {
  let wallet;
  let current;
  wallet = new Wallet({
    props: {
      wallets: (
        /*$loginContext*/
        ctx[2].walletPlugins
      ),
      title: (
        /*$t*/
        ctx[3]("login.select.wallet", { default: "Select a Wallet" })
      )
    }
  });
  wallet.$on(
    "select",
    /*selectWallet*/
    ctx[17]
  );
  wallet.$on(
    "cancel",
    /*cancel*/
    ctx[19]
  );
  return {
    c() {
      create_component(wallet.$$.fragment);
    },
    m(target, anchor) {
      mount_component(wallet, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const wallet_changes = {};
      if (dirty & /*$loginContext*/
      4)
        wallet_changes.wallets = /*$loginContext*/
        ctx2[2].walletPlugins;
      if (dirty & /*$t*/
      8)
        wallet_changes.title = /*$t*/
        ctx2[3]("login.select.wallet", { default: "Select a Wallet" });
      wallet.$set(wallet_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(wallet.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(wallet.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(wallet, detaching);
    }
  };
}
function create_fragment$6(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$2, create_else_block_1];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$props*/
      ctx2[4] && /*$loginContext*/
      ctx2[2]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
var right = 100;
function instance$6($$self, $$props, $$invalidate) {
  let $loginResponse;
  let $backAction;
  let $loginContext;
  let $t;
  let $props;
  let $step;
  let $chains;
  let $client;
  let $walletPlugin;
  component_subscribe($$self, loginResponse, ($$value) => $$invalidate(21, $loginResponse = $$value));
  component_subscribe($$self, backAction, ($$value) => $$invalidate(22, $backAction = $$value));
  component_subscribe($$self, loginContext, ($$value) => $$invalidate(2, $loginContext = $$value));
  component_subscribe($$self, props, ($$value) => $$invalidate(4, $props = $$value));
  const { t: t2 } = getContext("i18n");
  component_subscribe($$self, t2, (value) => $$invalidate(3, $t = value));
  let completed = false;
  const dispatch2 = createEventDispatcher();
  var Steps;
  (function(Steps2) {
    Steps2["done"] = "done";
    Steps2["enterPermission"] = "enterPermission";
    Steps2["selectChain"] = "selectChain";
    Steps2["selectPermission"] = "selectPermission";
    Steps2["selectWallet"] = "selectWallet";
  })(Steps || (Steps = {}));
  const chain = derived([loginContext, loginResponse], ([$currentContext, $currentResponse]) => {
    if (!$currentContext || $currentResponse.chainId === void 0) {
      return void 0;
    }
    if ($currentContext.chain) {
      return $currentContext.chain;
    }
    return $currentContext.chains.find((c) => c.id === $currentResponse.chainId);
  });
  const client = derived([chain, loginContext], ([$currentChain, $currentContext]) => {
    if (!$currentContext || $currentChain === void 0) {
      return void 0;
    }
    return $currentContext.getClient($currentChain);
  });
  component_subscribe($$self, client, (value) => $$invalidate(7, $client = value));
  const walletPlugin = derived([loginContext, loginResponse], ([$currentContext, $currentResponse]) => {
    if (!$currentContext || $currentResponse.walletPluginIndex === void 0) {
      return void 0;
    }
    return $currentContext.walletPlugins[$currentResponse.walletPluginIndex];
  });
  component_subscribe($$self, walletPlugin, (value) => $$invalidate(8, $walletPlugin = value));
  let chains = derived([loginContext, walletPlugin], ([$currentContext, $currentWalletPlugin]) => {
    if (!$currentContext || !$currentWalletPlugin) {
      return [];
    }
    if ($currentWalletPlugin.config.supportedChains) {
      return $currentContext.chains.filter((chain2) => {
        return !$currentWalletPlugin.config.supportedChains || $currentWalletPlugin.config.supportedChains.includes(String(chain2.id));
      });
    }
    return $currentContext.chains;
  });
  component_subscribe($$self, chains, (value) => $$invalidate(6, $chains = value));
  const loginContextUnsubscribe = loginContext.subscribe((currentContext) => {
    if (currentContext) {
      set_store_value(
        props,
        $props.subtitle = $t("login.title-app", {
          appName: currentContext.appName,
          default: "Login to {{appName}}"
        }),
        $props
      );
      if (currentContext.chain) {
        set_store_value(loginResponse, $loginResponse.chainId = currentContext.chain.id, $loginResponse);
      }
      if (currentContext.chains.length === 1) {
        set_store_value(loginResponse, $loginResponse.chainId = currentContext.chains[0].id, $loginResponse);
      }
      if (currentContext.permissionLevel) {
        set_store_value(loginResponse, $loginResponse.permissionLevel = currentContext.permissionLevel, $loginResponse);
      }
      if (currentContext.walletPlugins.length === 1) {
        set_store_value(loginResponse, $loginResponse.walletPluginIndex = 0, $loginResponse);
      }
    }
  });
  onMount(() => {
    set_store_value(props, $props.title = $t("login.title", { default: "Login" }), $props);
  });
  onDestroy(loginContextUnsubscribe);
  const step = derived([loginResponse, walletPlugin], ([$currentResponse, $currentWalletPlugin]) => {
    if (!$currentWalletPlugin) {
      return Steps.selectWallet;
    }
    const { requiresChainSelect, requiresPermissionEntry, requiresPermissionSelect, supportedChains } = $currentWalletPlugin.config;
    if (!$currentResponse.chainId && supportedChains && supportedChains.length === 1) {
      set_store_value(loginResponse, $loginResponse.chainId = supportedChains[0], $loginResponse);
      return Steps.selectPermission;
    } else if (!$currentResponse.chainId && $loginContext && $loginContext.chain) {
      set_store_value(loginResponse, $loginResponse.chainId = $loginContext == null ? void 0 : $loginContext.chain.id, $loginResponse);
      return Steps.selectPermission;
    } else if (!$currentResponse.chainId && requiresChainSelect) {
      return Steps.selectChain;
    } else if (!$currentResponse.permissionLevel && requiresPermissionSelect) {
      return Steps.selectPermission;
    } else if (!$currentResponse.permissionLevel && requiresPermissionEntry) {
      return Steps.enterPermission;
    }
    complete();
  });
  component_subscribe($$self, step, (value) => $$invalidate(5, $step = value));
  let transitionDirection;
  const left = -100;
  const selectChain = (e) => {
    set_store_value(loginResponse, $loginResponse.chainId = e.detail, $loginResponse);
    set_store_value(backAction, $backAction = unselectChain, $backAction);
    $$invalidate(1, transitionDirection = right);
  };
  const unselectChain = () => {
    set_store_value(loginResponse, $loginResponse.chainId = void 0, $loginResponse);
    set_store_value(backAction, $backAction = unselectWallet, $backAction);
    $$invalidate(1, transitionDirection = left);
  };
  const selectPermission = (e) => {
    set_store_value(loginResponse, $loginResponse.permissionLevel = e.detail, $loginResponse);
    set_store_value(backAction, $backAction = void 0, $backAction);
    $$invalidate(1, transitionDirection = right);
  };
  const selectWallet = (e) => {
    set_store_value(backAction, $backAction = unselectWallet, $backAction);
    set_store_value(loginResponse, $loginResponse.walletPluginIndex = e.detail, $loginResponse);
    $$invalidate(1, transitionDirection = right);
  };
  const unselectWallet = () => {
    set_store_value(loginResponse, $loginResponse.walletPluginIndex = void 0, $loginResponse);
    set_store_value(backAction, $backAction = void 0, $backAction);
    $$invalidate(1, transitionDirection = left);
  };
  const complete = () => {
    if (!completed) {
      completed = true;
      dispatch2("complete", $loginResponse);
      backAction.set(void 0);
    }
  };
  const cancel2 = () => {
    dispatch2("cancel");
  };
  return [
    Steps,
    transitionDirection,
    $loginContext,
    $t,
    $props,
    $step,
    $chains,
    $client,
    $walletPlugin,
    t2,
    client,
    walletPlugin,
    chains,
    step,
    selectChain,
    unselectChain,
    selectPermission,
    selectWallet,
    unselectWallet,
    cancel2
  ];
}
var Login = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$6, create_fragment$6, safe_not_equal, {});
  }
};
function add_css$3(target) {
  append_styles(target, "svelte-mttle8", "button.svelte-mttle8.svelte-mttle8{--button-size:46px;--button-size:var(--space-2xl);position:relative;isolation:isolate;background:var(--header-button-background);border:1px solid var(--header-button-outline);border:none;box-shadow:inset 0 0 0 1px var(--header-button-outline);border-radius:var(--border-radius-inner);cursor:pointer;width:var(--button-size);height:var(--button-size);display:grid;place-content:center;color:var(--header-text-color);transition:transform 80ms ease}button.svelte-mttle8.svelte-mttle8:active{transform:scale(95%);transform-origin:center}@media(hover: hover){button.svelte-mttle8:hover .background.svelte-mttle8{opacity:1}}.background.svelte-mttle8.svelte-mttle8{position:absolute;border-radius:var(--border-radius-inner);inset:0;opacity:0;z-index:-1;transition:opacity 80ms ease;background:var(--header-button-outline)}.visually-hidden.svelte-mttle8.svelte-mttle8{border:0;clip:rect(0 0 0 0);height:auto;margin:0;overflow:hidden;padding:0;position:absolute;width:1px;white-space:nowrap}");
}
function create_fragment$5(ctx) {
  let button;
  let span0;
  let t0;
  let icon_1;
  let t1;
  let span1;
  let t2;
  let current;
  let mounted;
  let dispose;
  icon_1 = new Icon({ props: { name: (
    /*icon*/
    ctx[1]
  ) } });
  return {
    c() {
      button = element("button");
      span0 = element("span");
      t0 = space();
      create_component(icon_1.$$.fragment);
      t1 = space();
      span1 = element("span");
      t2 = text(
        /*icon*/
        ctx[1]
      );
      attr(span0, "class", "background svelte-mttle8");
      attr(span1, "class", "label visually-hidden svelte-mttle8");
      attr(button, "class", "svelte-mttle8");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, span0);
      append(button, t0);
      mount_component(icon_1, button, null);
      append(button, t1);
      append(button, span1);
      append(span1, t2);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", function() {
          if (is_function(
            /*onClick*/
            ctx[0]
          ))
            ctx[0].apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      const icon_1_changes = {};
      if (dirty & /*icon*/
      2)
        icon_1_changes.name = /*icon*/
        ctx[1];
      icon_1.$set(icon_1_changes);
      if (!current || dirty & /*icon*/
      2)
        set_data(
          t2,
          /*icon*/
          ctx[1]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(icon_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(button);
      destroy_component(icon_1);
      mounted = false;
      dispose();
    }
  };
}
function instance$5($$self, $$props, $$invalidate) {
  let { onClick } = $$props;
  let { icon } = $$props;
  $$self.$$set = ($$props2) => {
    if ("onClick" in $$props2)
      $$invalidate(0, onClick = $$props2.onClick);
    if ("icon" in $$props2)
      $$invalidate(1, icon = $$props2.icon);
  };
  return [onClick, icon];
}
var HeaderButton = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$5, create_fragment$5, safe_not_equal, { onClick: 0, icon: 1 }, add_css$3);
  }
};
function add_css$2(target) {
  append_styles(target, "svelte-1hx8qya", "button.svelte-1hx8qya{background:none;border:none;padding:0;cursor:pointer;flex:1;display:flex;flex-direction:column;justify-content:space-around;text-align:center}");
}
function create_fragment$4(ctx) {
  let button;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    null
  );
  return {
    c() {
      button = element("button");
      if (default_slot)
        default_slot.c();
      attr(button, "class", "svelte-1hx8qya");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (default_slot) {
        default_slot.m(button, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*toggleColorScheme*/
          ctx[0]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(button);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance$4($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  function toggleColorScheme() {
    colorScheme.update((current) => current === "light" ? "dark" : "light");
  }
  onMount(() => {
    if (window.matchMedia) {
      const mql = window.matchMedia("(prefers-color-scheme: dark)");
      colorScheme.set(getStoredColorScheme() ?? (mql.matches ? "dark" : "light"));
      mql.addEventListener("change", () => {
        colorScheme.set(mql.matches ? "dark" : "light");
      });
    }
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(1, $$scope = $$props2.$$scope);
  };
  return [toggleColorScheme, $$scope, slots];
}
var ThemeToggle = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4, create_fragment$4, safe_not_equal, {}, add_css$2);
  }
};
function add_css$1(target) {
  append_styles(target, "svelte-j6z3r6", ".modal-header.svelte-j6z3r6.svelte-j6z3r6{box-sizing:border-box;min-height:var(--header-height);color:var(--header-text-color);background:var(--header-background-color);display:grid;grid-template-columns:1fr auto 1fr;gap:var(--space-s);padding:var(--space-m)}.modal-header.svelte-j6z3r6 .slot.svelte-j6z3r6{display:flex;align-items:center}.modal-header.svelte-j6z3r6 .center.svelte-j6z3r6{flex-direction:column;justify-content:space-around;text-align:center}.modal-header.svelte-j6z3r6 .right.svelte-j6z3r6{justify-content:flex-end}.modal-header.svelte-j6z3r6 .svelte-j6z3r6:is(h2, p){color:var(--header-text-color);margin:0;line-height:1.1em}.modal-header.svelte-j6z3r6 h2.svelte-j6z3r6{font-size:var(--fs-3);font-weight:700}.modal-header.svelte-j6z3r6 p.svelte-j6z3r6{font-size:var(--fs-0)}");
}
var get_right_slot_changes = (dirty) => ({});
var get_right_slot_context = (ctx) => ({});
var get_center_slot_changes = (dirty) => ({});
var get_center_slot_context = (ctx) => ({});
var get_left_slot_changes = (dirty) => ({});
var get_left_slot_context = (ctx) => ({});
function create_if_block_1$1(ctx) {
  let div;
  let headerbutton;
  let div_transition;
  let current;
  headerbutton = new HeaderButton({
    props: {
      icon: "chevron-left",
      onClick: (
        /*$backAction*/
        ctx[2]
      )
    }
  });
  return {
    c() {
      div = element("div");
      create_component(headerbutton.$$.fragment);
      attr(div, "class", "svelte-j6z3r6");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(headerbutton, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const headerbutton_changes = {};
      if (dirty & /*$backAction*/
      4)
        headerbutton_changes.onClick = /*$backAction*/
        ctx2[2];
      headerbutton.$set(headerbutton_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(headerbutton.$$.fragment, local);
      add_render_callback(() => {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div, fade, { duration: 100 }, true);
        div_transition.run(1);
      });
      current = true;
    },
    o(local) {
      transition_out(headerbutton.$$.fragment, local);
      if (!div_transition)
        div_transition = create_bidirectional_transition(div, fade, { duration: 100 }, false);
      div_transition.run(0);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(headerbutton);
      if (detaching && div_transition)
        div_transition.end();
    }
  };
}
function fallback_block_2(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*$backAction*/
    ctx[2] && create_if_block_1$1(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*$backAction*/
        ctx2[2]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$backAction*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$1(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block$1(ctx) {
  let p2;
  let t2;
  return {
    c() {
      p2 = element("p");
      t2 = text(
        /*subtitle*/
        ctx[1]
      );
      attr(p2, "class", "svelte-j6z3r6");
    },
    m(target, anchor) {
      insert(target, p2, anchor);
      append(p2, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*subtitle*/
      2)
        set_data(
          t2,
          /*subtitle*/
          ctx2[1]
        );
    },
    d(detaching) {
      if (detaching)
        detach(p2);
    }
  };
}
function create_default_slot$1(ctx) {
  let h2;
  let t0;
  let t1;
  let if_block_anchor;
  let if_block = (
    /*subtitle*/
    ctx[1] && create_if_block$1(ctx)
  );
  return {
    c() {
      h2 = element("h2");
      t0 = text(
        /*title*/
        ctx[0]
      );
      t1 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(h2, "class", "svelte-j6z3r6");
    },
    m(target, anchor) {
      insert(target, h2, anchor);
      append(h2, t0);
      insert(target, t1, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*title*/
      1)
        set_data(
          t0,
          /*title*/
          ctx2[0]
        );
      if (
        /*subtitle*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$1(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching)
        detach(h2);
      if (detaching)
        detach(t1);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function fallback_block_1(ctx) {
  let themetoggle;
  let current;
  themetoggle = new ThemeToggle({
    props: {
      $$slots: { default: [create_default_slot$1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(themetoggle.$$.fragment);
    },
    m(target, anchor) {
      mount_component(themetoggle, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const themetoggle_changes = {};
      if (dirty & /*$$scope, subtitle, title*/
      67) {
        themetoggle_changes.$$scope = { dirty, ctx: ctx2 };
      }
      themetoggle.$set(themetoggle_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(themetoggle.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(themetoggle.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(themetoggle, detaching);
    }
  };
}
function fallback_block(ctx) {
  let headerbutton;
  let current;
  headerbutton = new HeaderButton({
    props: { icon: "close", onClick: (
      /*func*/
      ctx[5]
    ) }
  });
  return {
    c() {
      create_component(headerbutton.$$.fragment);
    },
    m(target, anchor) {
      mount_component(headerbutton, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(headerbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(headerbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(headerbutton, detaching);
    }
  };
}
function create_fragment$3(ctx) {
  let div3;
  let div0;
  let t0;
  let div1;
  let t1;
  let div2;
  let current;
  const left_slot_template = (
    /*#slots*/
    ctx[4].left
  );
  const left_slot = create_slot(
    left_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_left_slot_context
  );
  const left_slot_or_fallback = left_slot || fallback_block_2(ctx);
  const center_slot_template = (
    /*#slots*/
    ctx[4].center
  );
  const center_slot = create_slot(
    center_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_center_slot_context
  );
  const center_slot_or_fallback = center_slot || fallback_block_1(ctx);
  const right_slot_template = (
    /*#slots*/
    ctx[4].right
  );
  const right_slot = create_slot(
    right_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_right_slot_context
  );
  const right_slot_or_fallback = right_slot || fallback_block(ctx);
  return {
    c() {
      div3 = element("div");
      div0 = element("div");
      if (left_slot_or_fallback)
        left_slot_or_fallback.c();
      t0 = space();
      div1 = element("div");
      if (center_slot_or_fallback)
        center_slot_or_fallback.c();
      t1 = space();
      div2 = element("div");
      if (right_slot_or_fallback)
        right_slot_or_fallback.c();
      attr(div0, "class", "slot left svelte-j6z3r6");
      attr(div1, "class", "slot center svelte-j6z3r6");
      attr(div2, "class", "slot right svelte-j6z3r6");
      attr(div3, "class", "modal-header svelte-j6z3r6");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div0);
      if (left_slot_or_fallback) {
        left_slot_or_fallback.m(div0, null);
      }
      append(div3, t0);
      append(div3, div1);
      if (center_slot_or_fallback) {
        center_slot_or_fallback.m(div1, null);
      }
      append(div3, t1);
      append(div3, div2);
      if (right_slot_or_fallback) {
        right_slot_or_fallback.m(div2, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (left_slot) {
        if (left_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            left_slot,
            left_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              left_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_left_slot_changes
            ),
            get_left_slot_context
          );
        }
      } else {
        if (left_slot_or_fallback && left_slot_or_fallback.p && (!current || dirty & /*$backAction*/
        4)) {
          left_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (center_slot) {
        if (center_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            center_slot,
            center_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              center_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_center_slot_changes
            ),
            get_center_slot_context
          );
        }
      } else {
        if (center_slot_or_fallback && center_slot_or_fallback.p && (!current || dirty & /*subtitle, title*/
        3)) {
          center_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (right_slot) {
        if (right_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            right_slot,
            right_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              right_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_right_slot_changes
            ),
            get_right_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(left_slot_or_fallback, local);
      transition_in(center_slot_or_fallback, local);
      transition_in(right_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(left_slot_or_fallback, local);
      transition_out(center_slot_or_fallback, local);
      transition_out(right_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      if (left_slot_or_fallback)
        left_slot_or_fallback.d(detaching);
      if (center_slot_or_fallback)
        center_slot_or_fallback.d(detaching);
      if (right_slot_or_fallback)
        right_slot_or_fallback.d(detaching);
    }
  };
}
function instance$3($$self, $$props, $$invalidate) {
  let $backAction;
  component_subscribe($$self, backAction, ($$value) => $$invalidate(2, $backAction = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  let { title } = $$props;
  let { subtitle } = $$props;
  const dispatch2 = createEventDispatcher();
  const func = () => dispatch2("cancel");
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
    if ("subtitle" in $$props2)
      $$invalidate(1, subtitle = $$props2.subtitle);
    if ("$$scope" in $$props2)
      $$invalidate(6, $$scope = $$props2.$$scope);
  };
  return [title, subtitle, $backAction, dispatch2, slots, func, $$scope];
}
var Header = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3, create_fragment$3, safe_not_equal, { title: 0, subtitle: 1 }, add_css$1);
  }
};
function add_css(target) {
  append_styles(target, "svelte-ilturl", ':host dialog.svelte-ilturl,:root{color-scheme:light;--body-background-color:white;--body-text-color:var(--color-primary-700);--body-text-color-variant:var(--color-neutral-700);--header-background-color:var(--color-primary-700);--header-text-color:var(--color-primary-50);--header-button-background:var(--header-background-color);--header-button-outline:var(--color-primary-900);--button-text-color:var(--wharf-blue);--button-text-color-active:var(--wharf-blue);--button-outline-active:inset 0 0 0 2px var(--button-text-color);--button-primary-background:var(--color-secondary-200);--button-primary-background-hover:var(--color-secondary-200);--button-primary-background-active:linear-gradient(rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.1)),\n      var(--color-secondary-200);--button-primary-outline-hover:inset 0 0 0 1px #00000030,\n      inset 0 0 0 1px var(--color-secondary-200);--button-secondary-background:var(--color-custom-1);--button-secondary-background-hover:var(--color-custom-1);--button-secondary-background-active:var(--color-secondary-200);--button-secondary-outline-hover:inset 0 0 0 1px #00000020,\n      inset 0 0 0 1px var(--color-secondary-200);--button-outlined-background-active:var(--color-secondary-200);--button-outlined-outline:inset 0 0 0 1px var(--color-secondary-200);--button-outlined-outline-hover:inset 0 0 0 1px #00000020,\n      inset 0 0 0 1px var(--color-secondary-200);--input-placeholder-color:var(--color-neutral-500);--input-background-focus:var(--color-neutral-100);--input-border-color:#00000030;--input-border-color-hover:var(--color-custom-5);--input-border-color-focus:var(--wharf-blue);--qr-border-color:var(--seafoam-mint);--checkbox-stroke:var(--wharf-blue);--checkbox-fill:var(--reef-turquoise);--error-color:var(--color-error-1);--list-item-background-color-hover:var(--color-custom-9);--list-item-text-color-hover:var(--color-secondary-500);--list-divider-color:#00000010;--text-area-background:var(--swell-mist);--text-area-text-color:#242424}:host dialog[data-theme=dark].svelte-ilturl{color-scheme:dark;--body-background-color:var(--color-primary-700);--body-text-color:white;--body-text-color-variant:var(--color-neutral-300);--header-background-color:white;--header-text-color:var(--color-primary-700);--header-button-background:var(--header-background-color);--header-button-outline:var(--seafoam-mint);--button-text-color:var(--body-text-color);--button-text-color-active:var(--reef-turquoise);--button-outline-active:inset 0 0 0 2px var(--reef-turquoise);--button-primary-background:var(--color-secondary-500);--button-primary-background-hover:var(--color-secondary-500);--button-primary-background-active:var(--color-custom-2);--button-primary-outline-hover:inset 0 0 0 1px white;--button-secondary-background:var(--color-primary-800);--button-secondary-background-hover:var(--color-primary-800);--button-secondary-background-active:var(--color-primary-900);--button-secondary-outline-hover:inset 0 0 0 1px #ffffff30;--button-outlined-background-active:var(--color-primary-900);--button-outlined-outline:inset 0 0 0 1px #00000030;--button-outlined-outline-hover:inset 0 0 0 1px #ffffff30;--input-placeholder-color:#ffffff75;--input-background-focus:var(--color-custom-4);--input-border-color:#ffffff30;--input-border-color-hover:var(--color-custom-6);--input-border-color-focus:var(--reef-turquoise);--qr-border-color:rgba(0 0 0 / 0.2);--checkbox-stroke:var(--reef-turquoise);--checkbox-fill:var(--color-custom-3);--error-color:var(--color-error-3);--list-item-background-color-hover:var(--color-custom-8);--list-item-text-color-hover:var(--color-secondary-400);--list-divider-color:#ffffff10;--text-area-background:var(--color-primary-900);--text-area-text-color:#ffffff}@media(prefers-color-scheme: dark){:host dialog.svelte-ilturl,:root{color-scheme:dark;--body-background-color:var(--color-primary-700);--body-text-color:white;--body-text-color-variant:var(--color-neutral-300);--header-background-color:white;--header-text-color:var(--color-primary-700);--header-button-background:var(--header-background-color);--header-button-outline:var(--seafoam-mint);--button-text-color:var(--body-text-color);--button-text-color-active:var(--reef-turquoise);--button-outline-active:inset 0 0 0 2px var(--reef-turquoise);--button-primary-background:var(--color-secondary-500);--button-primary-background-hover:var(--color-secondary-500);--button-primary-background-active:var(--color-custom-2);--button-primary-outline-hover:inset 0 0 0 1px white;--button-secondary-background:var(--color-primary-800);--button-secondary-background-hover:var(--color-primary-800);--button-secondary-background-active:var(--color-primary-900);--button-secondary-outline-hover:inset 0 0 0 1px #ffffff30;--button-outlined-background-active:var(--color-primary-900);--button-outlined-outline:inset 0 0 0 1px #00000030;--button-outlined-outline-hover:inset 0 0 0 1px #ffffff30;--input-placeholder-color:#ffffff75;--input-background-focus:var(--color-custom-4);--input-border-color:#ffffff30;--input-border-color-hover:var(--color-custom-6);--input-border-color-focus:var(--reef-turquoise);--qr-border-color:rgba(0 0 0 / 0.2);--checkbox-stroke:var(--reef-turquoise);--checkbox-fill:var(--color-custom-3);--error-color:var(--color-error-3);--list-item-background-color-hover:var(--color-custom-8);--list-item-text-color-hover:var(--color-secondary-400);--list-divider-color:#ffffff10;--text-area-background:var(--color-primary-900);--text-area-text-color:#ffffff}:host dialog[data-theme=light].svelte-ilturl{color-scheme:light;--body-background-color:white;--body-text-color:var(--color-primary-700);--body-text-color-variant:var(--color-neutral-700);--header-background-color:var(--color-primary-700);--header-text-color:var(--color-primary-50);--header-button-background:var(--header-background-color);--header-button-outline:var(--color-primary-900);--button-text-color:var(--wharf-blue);--button-text-color-active:var(--wharf-blue);--button-outline-active:inset 0 0 0 2px var(--button-text-color);--button-primary-background:var(--color-secondary-200);--button-primary-background-hover:var(--color-secondary-200);--button-primary-background-active:linear-gradient(rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.1)),\n        var(--color-secondary-200);--button-primary-outline-hover:inset 0 0 0 1px #00000030,\n        inset 0 0 0 1px var(--color-secondary-200);--button-secondary-background:var(--color-custom-1);--button-secondary-background-hover:var(--color-custom-1);--button-secondary-background-active:var(--color-secondary-200);--button-secondary-outline-hover:inset 0 0 0 1px #00000020,\n        inset 0 0 0 1px var(--color-secondary-200);--button-outlined-background-active:var(--color-secondary-200);--button-outlined-outline:inset 0 0 0 1px var(--color-secondary-200);--button-outlined-outline-hover:inset 0 0 0 1px #00000020,\n        inset 0 0 0 1px var(--color-secondary-200);--input-placeholder-color:var(--color-neutral-500);--input-background-focus:var(--color-neutral-100);--input-border-color:#00000030;--input-border-color-hover:var(--color-custom-5);--input-border-color-focus:var(--wharf-blue);--qr-border-color:var(--seafoam-mint);--checkbox-stroke:var(--wharf-blue);--checkbox-fill:var(--reef-turquoise);--error-color:var(--color-error-1);--list-item-background-color-hover:var(--color-custom-9);--list-item-text-color-hover:var(--color-secondary-500);--list-divider-color:#00000010;--text-area-background:var(--swell-mist);--text-area-text-color:#242424}}:host dialog.svelte-ilturl,:root{--wharf-blue:var(--color-primary-700);--reef-turquoise:var(--color-secondary-300);--seafoam-mint:var(--color-secondary-200);--swell-mist:var(--color-accent-50);--color-primary-50:#f6f7f9;--color-primary-100:#ededf1;--color-primary-200:#d6d8e1;--color-primary-300:#b3b8c6;--color-primary-400:#8991a7;--color-primary-500:#6b738c;--color-primary-600:#565c73;--color-primary-700:#494e62;--color-primary-800:#3c4050;--color-primary-900:#363944;--color-secondary-50:#f1fcf9;--color-secondary-100:#cef9ed;--color-secondary-200:#b2f2e1;--color-secondary-300:#7be7ce;--color-secondary-400:#35ccae;--color-secondary-500:#1cb095;--color-secondary-600:#148d79;--color-secondary-700:#147163;--color-secondary-800:#155a51;--color-secondary-900:#164b43;--color-accent-50:#f4faf4;--color-accent-100:#e4f4e5;--color-accent-200:#cae8cc;--color-accent-300:#a1d4a3;--color-accent-400:#70b874;--color-accent-500:#4c9b51;--color-accent-600:#3a7f3e;--color-accent-700:#306534;--color-accent-800:#2a512d;--color-accent-900:#244326;--color-neutral-100:#f7f7f7;--color-neutral-200:#e3e3e3;--color-neutral-300:#c8c8c8;--color-neutral-400:#a4a4a4;--color-neutral-500:#818181;--color-neutral-600:#666666;--color-neutral-700:#515151;--color-neutral-800:#434343;--color-neutral-900:#383838;--color-custom-1:#f3f8f3;--color-custom-2:#415e60;--color-custom-3:#344b4d;--color-custom-4:#3d435a;--color-custom-5:#8ec2b4;--color-custom-6:#777b8b;--color-custom-7:#35ccae10;--color-custom-8:#575c6e;--color-custom-9:#f4f5f7;--color-error-1:#cd3939;--color-error-2:#ff5454;--color-error-3:#ffacac;font-family:system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;--measure:35ch;--fs-0:12px;--fs-1:14px;--fs-2:16px;--fs-3:20px;--ratio:1.5;--space-4xs:calc(var(--space-3xs) / var(--ratio));--space-3xs:calc(var(--space-2xs) / var(--ratio));--space-2xs:calc(var(--space-xs) / var(--ratio));--space-xs:calc(var(--space-s) / var(--ratio));--space-s:calc(var(--space-m) / var(--ratio));--space-m:1rem;--space-l:calc(var(--space-m) * var(--ratio));--space-xl:calc(var(--space-l) * var(--ratio));--space-2xl:calc(var(--space-xl) * var(--ratio));--space-3xl:calc(var(--space-2xl) * var(--ratio));--space-4xl:calc(var(--space-3xl) * var(--ratio));--space-5xl:calc(var(--space-4xl) * var(--ratio));--space-6xl:calc(var(--space-5xl) * var(--ratio));--space-7xl:calc(var(--space-6xl) * var(--ratio));--space-8xl:calc(var(--space-7xl) * var(--ratio));--space-9xl:calc(var(--space-8xl) * var(--ratio));--border-radius-outer:24px;--border-radius-inner:12px;--header-height:var(--space-3xl)}.svelte-ilturl{box-sizing:border-box}.svelte-ilturl::selection{color:var(--wharf-blue);background-color:var(--seafoam-mint)}dialog.svelte-ilturl{--margin-top:var(--space-xl);font-family:system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;margin-bottom:0;margin-top:var(--margin-top);margin-inline:auto;border:none !important;border-radius:var(--border-radius-outer);padding:0;width:min(var(--space-7xl), 100vw - var(--space-m));box-shadow:0px 4px 154px rgba(0, 0, 0, 0.35)}dialog.svelte-ilturl::backdrop{background:rgba(0, 0, 0, 0.75)}.modal-content.svelte-ilturl{--max-modal-content-height:calc(\n      100svh - var(--header-height) - var(--margin-top) - var(--margin-top)\n  );padding:var(--space-m);background-color:var(--body-background-color);overflow-y:scroll;max-height:var(--max-modal-content-height);scrollbar-gutter:stable both-edges;scrollbar-color:var(--header-background-color)}.modal-content.svelte-ilturl::-webkit-scrollbar{width:2px;background-color:var(--body-background-color)}.modal-content.svelte-ilturl::-webkit-scrollbar-thumb{background:var(--header-background-color)}');
}
function create_fragment$2(ctx) {
  let dialog_1;
  let header;
  let t2;
  let div;
  let current;
  let mounted;
  let dispose;
  header = new Header({
    props: {
      title: (
        /*$props*/
        ctx[2].title
      ),
      subtitle: (
        /*$props*/
        ctx[2].subtitle
      )
    }
  });
  header.$on(
    "cancel",
    /*cancelRequest*/
    ctx[3]
  );
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  return {
    c() {
      dialog_1 = element("dialog");
      create_component(header.$$.fragment);
      t2 = space();
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "class", "modal-content svelte-ilturl");
      attr(
        dialog_1,
        "data-theme",
        /*$colorScheme*/
        ctx[1]
      );
      attr(dialog_1, "class", "svelte-ilturl");
    },
    m(target, anchor) {
      insert(target, dialog_1, anchor);
      mount_component(header, dialog_1, null);
      append(dialog_1, t2);
      append(dialog_1, div);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[8](dialog_1);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            dialog_1,
            "click",
            /*backgroundClose*/
            ctx[4],
            { passive: false, capture: true }
          ),
          listen(dialog_1, "keyup", prevent_default(
            /*escapeClose*/
            ctx[5]
          ), { passive: false, capture: true })
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const header_changes = {};
      if (dirty & /*$props*/
      4)
        header_changes.title = /*$props*/
        ctx2[2].title;
      if (dirty & /*$props*/
      4)
        header_changes.subtitle = /*$props*/
        ctx2[2].subtitle;
      header.$set(header_changes);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*$colorScheme*/
      2) {
        attr(
          dialog_1,
          "data-theme",
          /*$colorScheme*/
          ctx2[1]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(header.$$.fragment, local);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(dialog_1);
      destroy_component(header);
      if (default_slot)
        default_slot.d(detaching);
      ctx[8](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$2($$self, $$props, $$invalidate) {
  let $cancelablePromises;
  let $colorScheme;
  let $props;
  component_subscribe($$self, cancelablePromises, ($$value) => $$invalidate(9, $cancelablePromises = $$value));
  component_subscribe($$self, colorScheme, ($$value) => $$invalidate(1, $colorScheme = $$value));
  component_subscribe($$self, props, ($$value) => $$invalidate(2, $props = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  let dialog;
  const unsubscribe = active.subscribe((current) => {
    if (dialog) {
      if (current && !dialog.open) {
        dialog.showModal();
      } else if (!current && dialog.open) {
        dialog.close();
        resetState();
      }
    }
  });
  onDestroy(unsubscribe);
  function cancelRequest() {
    $cancelablePromises.map((f2) => f2("Modal closed", true));
    active.set(false);
  }
  function backgroundClose(event) {
    var rect = dialog.getBoundingClientRect();
    var isInDialog = rect.top <= event.clientY && event.clientY <= rect.top + rect.height && rect.left <= event.clientX && event.clientX <= rect.left + rect.width;
    if (event.target === dialog && !isInDialog) {
      cancelRequest();
    }
  }
  function escapeClose(event) {
    if (event.key === "Escape") {
      cancelRequest();
    }
  }
  function dialog_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      dialog = $$value;
      $$invalidate(0, dialog);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(6, $$scope = $$props2.$$scope);
  };
  return [
    dialog,
    $colorScheme,
    $props,
    cancelRequest,
    backgroundClose,
    escapeClose,
    $$scope,
    slots,
    dialog_1_binding
  ];
}
var Modal = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2, create_fragment$2, safe_not_equal, {}, add_css);
  }
};
function create_fragment$1(ctx) {
  let p2;
  let t_1_value = (
    /*$t*/
    ctx[0]("transact.processing", {
      default: "Doing transact stuffs - cool animation!"
    }) + ""
  );
  let t_1;
  return {
    c() {
      p2 = element("p");
      t_1 = text(t_1_value);
    },
    m(target, anchor) {
      insert(target, p2, anchor);
      append(p2, t_1);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$t*/
      1 && t_1_value !== (t_1_value = /*$t*/
      ctx2[0]("transact.processing", {
        default: "Doing transact stuffs - cool animation!"
      }) + ""))
        set_data(t_1, t_1_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(p2);
    }
  };
}
function instance$1($$self, $$props, $$invalidate) {
  let $t;
  const { t: t2 } = getContext("i18n");
  component_subscribe($$self, t2, (value) => $$invalidate(0, $t = value));
  createEventDispatcher();
  return [$t, t2];
}
var Transact = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1, create_fragment$1, safe_not_equal, {});
  }
};
function create_else_block(ctx) {
  let p2;
  return {
    c() {
      p2 = element("p");
      p2.textContent = "Modal inactive";
    },
    m(target, anchor) {
      insert(target, p2, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(p2);
    }
  };
}
function create_if_block(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_1, create_if_block_2, create_if_block_3, create_if_block_4];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*$errorDetails*/
      ctx2[2]
    )
      return 0;
    if (
      /*$prompt*/
      ctx2[0]
    )
      return 1;
    if (
      /*$router*/
      ctx2[3].path === "login"
    )
      return 2;
    if (
      /*$router*/
      ctx2[3].path === "transact"
    )
      return 3;
    return -1;
  }
  if (~(current_block_type_index = select_block_type_1(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_4(ctx) {
  let transact2;
  let current;
  transact2 = new Transact({});
  transact2.$on(
    "cancel",
    /*cancel*/
    ctx[4]
  );
  transact2.$on(
    "complete",
    /*complete*/
    ctx[5]
  );
  return {
    c() {
      create_component(transact2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(transact2, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(transact2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(transact2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(transact2, detaching);
    }
  };
}
function create_if_block_3(ctx) {
  let login2;
  let current;
  login2 = new Login({});
  login2.$on(
    "cancel",
    /*cancel*/
    ctx[4]
  );
  login2.$on(
    "complete",
    /*complete*/
    ctx[5]
  );
  return {
    c() {
      create_component(login2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(login2, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(login2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(login2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(login2, detaching);
    }
  };
}
function create_if_block_2(ctx) {
  let prompt_1;
  let current;
  prompt_1 = new Prompt({});
  prompt_1.$on(
    "cancel",
    /*cancel*/
    ctx[4]
  );
  prompt_1.$on(
    "complete",
    /*complete*/
    ctx[5]
  );
  return {
    c() {
      create_component(prompt_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(prompt_1, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(prompt_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(prompt_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(prompt_1, detaching);
    }
  };
}
function create_if_block_1(ctx) {
  let error2;
  let current;
  error2 = new Error$1({});
  error2.$on(
    "cancel",
    /*cancel*/
    ctx[4]
  );
  error2.$on(
    "complete",
    /*complete*/
    ctx[5]
  );
  return {
    c() {
      create_component(error2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(error2, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(error2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(error2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(error2, detaching);
    }
  };
}
function create_default_slot(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$active*/
      ctx2[1]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment(ctx) {
  let modal;
  let current;
  modal = new Modal({
    props: {
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modal, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const modal_changes = {};
      if (dirty & /*$$scope, $errorDetails, $prompt, $router, $active*/
      271) {
        modal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal.$set(modal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modal, detaching);
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let $prompt;
  let $loginPromise;
  let $active;
  let $errorDetails;
  let $router;
  component_subscribe($$self, prompt, ($$value) => $$invalidate(0, $prompt = $$value));
  component_subscribe($$self, loginPromise, ($$value) => $$invalidate(7, $loginPromise = $$value));
  component_subscribe($$self, active, ($$value) => $$invalidate(1, $active = $$value));
  component_subscribe($$self, errorDetails, ($$value) => $$invalidate(2, $errorDetails = $$value));
  component_subscribe($$self, router, ($$value) => $$invalidate(3, $router = $$value));
  let { i18n } = $$props;
  setContext("i18n", i18n);
  function cancel2({ detail }) {
    if ($loginPromise) {
      $loginPromise.reject(detail);
    }
    if ($prompt) {
      $prompt.reject(detail);
      prompt.reset();
    }
    router.back();
  }
  function complete({ detail }) {
    if ($loginPromise) {
      $loginPromise.resolve(detail);
    }
    if ($prompt) {
      $prompt.resolve(detail);
      prompt.reset();
    }
    router.back();
  }
  $$self.$$set = ($$props2) => {
    if ("i18n" in $$props2)
      $$invalidate(6, i18n = $$props2.i18n);
  };
  return [$prompt, $active, $errorDetails, $router, cancel2, complete, i18n];
}
var App = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, { i18n: 6 });
  }
};
var defaultWebRendererOptions = {
  id: "wharfkit-web-ui"
};
var getNavigatorLanguage = () => (navigator.languages && navigator.languages.length ? navigator.languages[0] : navigator.language || "en").split("-")[0];
var WebRenderer = class extends AbstractUserInterface {
  constructor(options = defaultWebRendererOptions) {
    super();
    this.elementId = "wharfkit-web-ui";
    this.addCancelablePromise = (promise2) => cancelablePromises.update((current) => [...current, promise2]);
    this.element = document.createElement("div");
    this.elementId = options.id || defaultWebRendererOptions.id;
    this.element.id = this.elementId;
    this.shadow = this.element.attachShadow({ mode: "closed" });
    const lang2 = getNavigatorLanguage();
    this.i18n = makeLocalization();
    this.log(`Setting language to ${lang2}`);
    this.i18n.loadTranslations(lang2);
    if (document.readyState === "complete" || document.readyState === "interactive") {
      this.appendDialogElement();
    } else {
      document.addEventListener("DOMContentLoaded", () => this.appendDialogElement());
    }
  }
  appendDialogElement() {
    const existing = document.getElementById(this.elementId);
    if (!existing) {
      document.body.append(this.element);
      document.removeEventListener("DOMContentLoaded", () => this.appendDialogElement());
      new App({
        target: this.shadow,
        props: {
          i18n: this.i18n
        }
      });
    }
  }
  log(...args) {
    console.log("WebRenderer, LOG:", ...args);
  }
  login(context) {
    this.log("login", context);
    active.set(true);
    router.push("login");
    const promise2 = cancelable(new Promise((resolve, reject) => loginPromise.set({
      reject,
      resolve
    })));
    this.addCancelablePromise(promise2.cancel);
    loginContext.set(context);
    return promise2;
  }
  async onError(error2) {
    const isCancelable = error2 instanceof Canceled;
    const isSilent = isCancelable && error2.silent === true;
    this.log("onError", {
      isCancelable,
      isSilent,
      error: error2
    });
    if (isSilent) {
      return;
    }
    active.set(true);
    errorDetails.set(String(error2));
    router.push("error");
  }
  async onLogin() {
    this.log("onLogin");
    active.set(true);
    props.update((current) => ({
      ...current,
      title: this.i18n.t.get("login.title", { default: "Login" }),
      subtitle: this.i18n.t.get("login.subtitle", { default: "Please login to continue." })
    }));
    router.push("login");
  }
  async onLoginComplete() {
    this.log("onLoginResult");
    active.set(false);
    resetState();
  }
  async onTransact() {
    this.log("onTransact");
    active.set(true);
    props.update((c) => ({
      ...c,
      title: this.i18n.t.get("transact.title", { default: "Transact" }),
      subtitle: this.i18n.t.get("transact.subtitle", { default: " " })
    }));
    router.push("transact");
  }
  async onTransactComplete() {
    this.log("onTransactResult");
    resetState();
    active.set(false);
  }
  async onSign() {
    this.log("onSign");
    props.update((c) => ({
      ...c,
      subtitle: this.i18n.t.get("transact.signing", { default: "Signing transaction" })
    }));
  }
  async onSignComplete() {
    this.log("onSignComplete");
    props.update((c) => ({
      ...c,
      subtitle: this.i18n.t.get("transact.signed", { default: "Transaction signed" })
    }));
  }
  async onBroadcast() {
    this.log("onBroadcast");
    props.update((c) => ({
      ...c,
      subtitle: this.i18n.t.get("transact.broadcasting", {
        default: "Broadcasting transaction"
      })
    }));
  }
  async onBroadcastComplete() {
    this.log("onBroadcastComplete");
    props.update((c) => ({
      ...c,
      subtitle: this.i18n.t.get("transact.broadcasted", {
        default: "Transaction broadcasted!"
      })
    }));
  }
  prompt(args) {
    this.log("prompt", args);
    active.set(true);
    router.push("prompt");
    const promise2 = cancelable(new Promise((resolve, reject) => {
      prompt.set({
        args,
        resolve,
        reject
      });
    }), (canceled) => {
      throw canceled;
    });
    this.addCancelablePromise(promise2.cancel);
    return promise2;
  }
  status(message) {
    active.set(true);
    props.update((current) => ({
      ...current,
      subtitle: message
    }));
  }
  // Map the UserInterface translate call to our i18n instance
  translate(key, options, namespace) {
    if (namespace) {
      return this.i18n.t.get(`${namespace}.${key}`, options);
    }
    return this.i18n.t.get(key, options);
  }
  addTranslations(translations2) {
    this.i18n.addTranslations(translations2);
  }
};
WebRenderer.version = "0.4.0";
export {
  WebRenderer,
  WebRenderer as default,
  defaultWebRendererOptions
};
//# sourceMappingURL=@wharfkit_web-renderer.js.map
