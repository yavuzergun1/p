import {
  require_bn,
  require_brorand,
  require_elliptic
} from "./chunk-M7NDEZ3U.js";
import {
  require_hash
} from "./chunk-YSRTV47A.js";
import {
  __toESM
} from "./chunk-GKWPUQBP.js";

// node_modules/tslib/tslib.es6.js
function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

// node_modules/@greymass/eosio/lib/eosio-core.m.js
var import_brorand = __toESM(require_brorand());
var import_hash = __toESM(require_hash());
var import_bn = __toESM(require_bn());
var import_elliptic = __toESM(require_elliptic());
function arrayEquals(a, b) {
  const len = a.length;
  if (len !== b.length) {
    return false;
  }
  for (let i = 0; i < len; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}
function arrayEquatableEquals(a, b) {
  const len = a.length;
  if (len !== b.length) {
    return false;
  }
  for (let i = 0; i < len; i++) {
    if (!a[i].equals(b[i])) {
      return false;
    }
  }
  return true;
}
var hexLookup = {};
function buildHexLookup() {
  hexLookup.enc = new Array(255);
  hexLookup.dec = {};
  for (let i = 0; i <= 255; ++i) {
    const b = i.toString(16).padStart(2, "0");
    hexLookup.enc[i] = b;
    hexLookup.dec[b] = i;
  }
}
function arrayToHex(array) {
  if (!hexLookup.enc) {
    buildHexLookup();
  }
  const len = array.length;
  const rv = new Array(len);
  for (let i = 0; i < len; ++i) {
    rv[i] = hexLookup.enc[array[i]];
  }
  return rv.join("");
}
function hexToArray(hex) {
  if (!hexLookup.dec) {
    buildHexLookup();
  }
  if (typeof hex !== "string") {
    throw new Error("Expected string containing hex digits");
  }
  if (hex.length % 2) {
    throw new Error("Odd number of hex digits");
  }
  hex = hex.toLowerCase();
  const len = hex.length / 2;
  const result = new Uint8Array(len);
  for (let i = 0; i < len; i++) {
    const b = hexLookup.dec[hex[i * 2] + hex[i * 2 + 1]];
    if (b === void 0) {
      throw new Error("Expected hex string");
    }
    result[i] = b;
  }
  return result;
}
function secureRandom(length) {
  return (0, import_brorand.default)(length);
}
var didWarn = false;
function isInstanceOf(object, someClass) {
  if (object instanceof someClass) {
    return true;
  }
  if (object == null || typeof object !== "object") {
    return false;
  }
  const className = someClass["__className"] || someClass["abiName"];
  if (!className) {
    return false;
  }
  let instanceClass = object.constructor;
  let isAlienInstance = false;
  while (instanceClass && !isAlienInstance) {
    const instanceClassName = instanceClass["__className"] || instanceClass["abiName"];
    if (!instanceClassName) {
      break;
    }
    isAlienInstance = className == instanceClassName;
    instanceClass = Object.getPrototypeOf(instanceClass);
  }
  if (isAlienInstance && !didWarn) {
    console.warn(`Detected alien instance of ${className}, this usually means more than one version of @greymass/eosio has been included in your bundle.`);
    didWarn = true;
  }
  return isAlienInstance;
}
var Bytes = class {
  /**
   * Create a new Bytes instance.
   * @note Make sure to take a [[copy]] before mutating the bytes as the underlying source is not copied here.
   */
  static from(value, encoding) {
    if (isInstanceOf(value, this)) {
      return value;
    }
    if (typeof value === "string") {
      return this.fromString(value, encoding);
    }
    if (ArrayBuffer.isView(value)) {
      return new this(new Uint8Array(value.buffer, value.byteOffset, value.byteLength));
    }
    if (isInstanceOf(value["array"], Uint8Array)) {
      return new this(value["array"]);
    }
    return new this(new Uint8Array(value));
  }
  static fromString(value, encoding = "hex") {
    if (encoding === "hex") {
      const array = hexToArray(value);
      return new this(array);
    } else if (encoding == "utf8") {
      const encoder = new TextEncoder();
      return new this(encoder.encode(value));
    } else {
      throw new Error(`Unknown encoding: ${encoding}`);
    }
  }
  static fromABI(decoder) {
    const len = decoder.readVaruint32();
    return new this(decoder.readArray(len));
  }
  static abiDefault() {
    return new Bytes();
  }
  static equal(a, b) {
    return this.from(a).equals(this.from(b));
  }
  static random(length) {
    return new this(secureRandom(length));
  }
  /** Return true if given value is a valid `BytesType`. */
  static isBytes(value) {
    if (isInstanceOf(value, Bytes) || isInstanceOf(value, Uint8Array)) {
      return true;
    }
    if (Array.isArray(value) && value.every((v) => typeof v === "number")) {
      return true;
    }
    if (typeof value === "string" && (/[\da-f]/i.test(value) || value === "")) {
      return true;
    }
    return false;
  }
  constructor(array = new Uint8Array()) {
    this.array = array;
  }
  /** Number of bytes in this instance. */
  get length() {
    return this.array.byteLength;
  }
  /** Hex string representation of this instance. */
  get hexString() {
    return arrayToHex(this.array);
  }
  /** UTF-8 string representation of this instance. */
  get utf8String() {
    return new TextDecoder().decode(this.array);
  }
  /** Mutating. Append bytes to this instance. */
  append(other) {
    other = Bytes.from(other);
    const newSize = this.array.byteLength + other.array.byteLength;
    const buffer = new ArrayBuffer(newSize);
    const array = new Uint8Array(buffer);
    array.set(this.array);
    array.set(other.array, this.array.byteLength);
    this.array = array;
  }
  /** Non-mutating, returns a copy of this instance with appended bytes. */
  appending(other) {
    const rv = new Bytes(this.array);
    rv.append(other);
    return rv;
  }
  /** Mutating. Pad this instance to length. */
  zeropad(n, truncate2 = false) {
    const newSize = truncate2 ? n : Math.max(n, this.array.byteLength);
    const buffer = new ArrayBuffer(newSize);
    const array = new Uint8Array(buffer);
    array.fill(0);
    if (truncate2 && this.array.byteLength > newSize) {
      array.set(this.array.slice(0, newSize), 0);
    } else {
      array.set(this.array, newSize - this.array.byteLength);
    }
    this.array = array;
  }
  /** Non-mutating, returns a copy of this instance with zeros padded. */
  zeropadded(n, truncate2 = false) {
    const rv = new Bytes(this.array);
    rv.zeropad(n, truncate2);
    return rv;
  }
  /** Mutating. Drop bytes from the start of this instance. */
  dropFirst(n = 1) {
    this.array = this.array.subarray(n);
  }
  /** Non-mutating, returns a copy of this instance with dropped bytes from the start. */
  droppingFirst(n = 1) {
    return new Bytes(this.array.subarray(n));
  }
  copy() {
    const buffer = new ArrayBuffer(this.array.byteLength);
    const array = new Uint8Array(buffer);
    array.set(this.array);
    return new Bytes(array);
  }
  equals(other) {
    return arrayEquals(this.array, Bytes.from(other).array);
  }
  toString(encoding = "hex") {
    if (encoding === "hex") {
      return this.hexString;
    } else if (encoding === "utf8") {
      return this.utf8String;
    } else {
      throw new Error(`Unknown encoding: ${encoding}`);
    }
  }
  toABI(encoder) {
    encoder.writeVaruint32(this.array.byteLength);
    encoder.writeArray(this.array);
  }
  toJSON() {
    return this.hexString;
  }
};
Bytes.abiName = "bytes";
var Checksum = class {
  static from(value) {
    if (isInstanceOf(value, this)) {
      return value;
    }
    if (isInstanceOf(value, Checksum)) {
      return new this(value.array);
    }
    return new this(Bytes.from(value).array);
  }
  static fromABI(decoder) {
    return new this(decoder.readArray(this.byteSize));
  }
  static abiDefault() {
    return new this(new Uint8Array(this.byteSize));
  }
  constructor(array) {
    const byteSize = this.constructor.byteSize;
    if (array.byteLength !== byteSize) {
      throw new Error(`Checksum size mismatch, expected ${byteSize} bytes got ${array.byteLength}`);
    }
    this.array = array;
  }
  equals(other) {
    const self = this.constructor;
    try {
      return arrayEquals(this.array, self.from(other).array);
    } catch {
      return false;
    }
  }
  get hexString() {
    return arrayToHex(this.array);
  }
  toABI(encoder) {
    encoder.writeArray(this.array);
  }
  toString() {
    return this.hexString;
  }
  toJSON() {
    return this.toString();
  }
};
Checksum.abiName = "__checksum";
var Checksum256 = class extends Checksum {
  static from(value) {
    return super.from(value);
  }
  static hash(data) {
    const digest = new Uint8Array((0, import_hash.sha256)().update(Bytes.from(data).array).digest());
    return new Checksum256(digest);
  }
};
Checksum256.abiName = "checksum256";
Checksum256.byteSize = 32;
var Checksum512 = class extends Checksum {
  static from(value) {
    return super.from(value);
  }
  static hash(data) {
    const digest = new Uint8Array((0, import_hash.sha512)().update(Bytes.from(data).array).digest());
    return new Checksum512(digest);
  }
};
Checksum512.abiName = "checksum512";
Checksum512.byteSize = 64;
var Checksum160 = class extends Checksum {
  static from(value) {
    return super.from(value);
  }
  static hash(data) {
    const digest = new Uint8Array((0, import_hash.ripemd160)().update(Bytes.from(data).array).digest());
    return new Checksum160(digest);
  }
};
Checksum160.abiName = "checksum160";
Checksum160.byteSize = 20;
var KeyType;
(function(KeyType2) {
  KeyType2["K1"] = "K1";
  KeyType2["R1"] = "R1";
  KeyType2["WA"] = "WA";
})(KeyType || (KeyType = {}));
(function(KeyType2) {
  function indexFor(value) {
    switch (value) {
      case KeyType2.K1:
        return 0;
      case KeyType2.R1:
        return 1;
      case KeyType2.WA:
        return 2;
      default:
        throw new Error(`Unknown curve type: ${value}`);
    }
  }
  KeyType2.indexFor = indexFor;
  function from(value) {
    let index;
    if (typeof value !== "number") {
      index = KeyType2.indexFor(value);
    } else {
      index = value;
    }
    switch (index) {
      case 0:
        return KeyType2.K1;
      case 1:
        return KeyType2.R1;
      case 2:
        return KeyType2.WA;
      default:
        throw new Error("Unknown curve type");
    }
  }
  KeyType2.from = from;
})(KeyType || (KeyType = {}));
var Int = class {
  /** Largest value that can be represented by this integer type. */
  static get max() {
    return new import_bn.default(2).pow(new import_bn.default(this.byteWidth * 8 - (this.isSigned ? 1 : 0))).isubn(1);
  }
  /** Smallest value that can be represented by this integer type. */
  static get min() {
    return this.isSigned ? this.max.ineg().isubn(1) : new import_bn.default(0);
  }
  /** Add `lhs` to `rhs` and return the resulting value. */
  static add(lhs, rhs, overflow = "truncate") {
    return Int.operator(lhs, rhs, overflow, (a, b) => a.add(b));
  }
  /** Add `lhs` to `rhs` and return the resulting value. */
  static sub(lhs, rhs, overflow) {
    return Int.operator(lhs, rhs, overflow, (a, b) => a.sub(b));
  }
  /** Multiply `lhs` by `rhs` and return the resulting value. */
  static mul(lhs, rhs, overflow) {
    return Int.operator(lhs, rhs, overflow, (a, b) => a.mul(b));
  }
  /**
   * Divide `lhs` by `rhs` and return the quotient, dropping the remainder.
   * @throws When dividing by zero.
   */
  static div(lhs, rhs, overflow) {
    return Int.operator(lhs, rhs, overflow, (a, b) => {
      if (b.isZero()) {
        throw new Error("Division by zero");
      }
      return a.div(b);
    });
  }
  /**
   * Divide `lhs` by `rhs` and return the quotient + remainder rounded to the closest integer.
   * @throws When dividing by zero.
   */
  static divRound(lhs, rhs, overflow) {
    return Int.operator(lhs, rhs, overflow, (a, b) => {
      if (b.isZero()) {
        throw new Error("Division by zero");
      }
      return a.divRound(b);
    });
  }
  /**
   * Divide `lhs` by `rhs` and return the quotient + remainder rounded up to the closest integer.
   * @throws When dividing by zero.
   */
  static divCeil(lhs, rhs, overflow) {
    return Int.operator(lhs, rhs, overflow, (a, b) => {
      if (b.isZero()) {
        throw new Error("Division by zero");
      }
      const dm = a.divmod(b);
      if (dm.mod.isZero())
        return dm.div;
      return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
    });
  }
  /**
   * Can be used to implement custom operator.
   * @internal
   */
  static operator(lhs, rhs, overflow = "truncate", fn) {
    const { a, b } = convert(lhs, rhs);
    const type = a.constructor;
    const result = fn(a.value, b.value);
    return type.from(result, overflow);
  }
  static from(value, overflow) {
    if (isInstanceOf(value, this)) {
      return value;
    }
    let fromType = this;
    let bn;
    if (isInstanceOf(value, Int)) {
      fromType = value.constructor;
      bn = value.value.clone();
    } else if (value instanceof Uint8Array) {
      bn = new import_bn.default(value, void 0, "le");
      if (fromType.isSigned) {
        bn = bn.fromTwos(fromType.byteWidth * 8);
      }
    } else {
      if (typeof value === "string" && !/[0-9]+/.test(value) || typeof value === "number" && !Number.isFinite(value)) {
        throw new Error("Invalid number");
      }
      bn = import_bn.default.isBN(value) ? value.clone() : new import_bn.default(value, 10);
      if (bn.isNeg() && !fromType.isSigned) {
        fromType = { byteWidth: fromType.byteWidth, isSigned: true };
      }
    }
    switch (overflow) {
      case "clamp":
        bn = clamp(bn, this.min, this.max);
        break;
      case "truncate":
        bn = truncate(bn, fromType, this);
        break;
    }
    return new this(bn);
  }
  static fromABI(decoder) {
    return this.from(decoder.readArray(this.byteWidth));
  }
  static abiDefault() {
    return this.from(0);
  }
  static random() {
    return this.from(secureRandom(this.byteWidth));
  }
  /**
   * Create a new instance, don't use this directly. Use the `.from` factory method instead.
   * @throws If the value over- or under-flows the integer type.
   */
  constructor(value) {
    const self = this.constructor;
    if (self.isSigned === void 0 || self.byteWidth === void 0) {
      throw new Error("Cannot instantiate abstract class Int");
    }
    if (value.gt(self.max)) {
      throw new Error(`Number ${value} overflows ${self.abiName}`);
    }
    if (value.lt(self.min)) {
      throw new Error(`Number ${value} underflows ${self.abiName}`);
    }
    this.value = value;
  }
  cast(type, overflow = "truncate") {
    if (this.constructor === type) {
      return this;
    }
    return type.from(this, overflow);
  }
  /** Number as bytes in little endian (matches memory layout in C++ contract). */
  get byteArray() {
    const self = this.constructor;
    const value = self.isSigned ? this.value.toTwos(self.byteWidth * 8) : this.value;
    return value.toArrayLike(Uint8Array, "le", self.byteWidth);
  }
  /**
   * Compare two integers, if strict is set to true the test will only consider integers
   * of the exact same type. I.e. Int64.from(1).equals(UInt64.from(1)) will return false.
   */
  equals(other, strict = false) {
    const self = this.constructor;
    if (strict === true && isInstanceOf(other, Int)) {
      const otherType = other.constructor;
      if (self.byteWidth !== otherType.byteWidth || self.isSigned !== otherType.isSigned) {
        return false;
      }
    }
    try {
      return this.value.eq(self.from(other).value);
    } catch {
      return false;
    }
  }
  /** Mutating add. */
  add(num) {
    this.value = this.operator(num, Int.add).value;
  }
  /** Non-mutating add. */
  adding(num) {
    return this.operator(num, Int.add);
  }
  /** Mutating subtract. */
  subtract(num) {
    this.value = this.operator(num, Int.sub).value;
  }
  /** Non-mutating subtract. */
  subtracting(num) {
    return this.operator(num, Int.sub);
  }
  /** Mutating multiply. */
  multiply(by) {
    this.value = this.operator(by, Int.mul).value;
  }
  /** Non-mutating multiply. */
  multiplying(by) {
    return this.operator(by, Int.mul);
  }
  /**
   * Mutating divide.
   * @param behavior How to handle the remainder, default is to floor (round down).
   * @throws When dividing by zero.
   */
  divide(by, behavior) {
    this.value = this.dividing(by, behavior).value;
  }
  /**
   * Non-mutating divide.
   * @param behavior How to handle the remainder, default is to floor (round down).
   * @throws When dividing by zero.
   */
  dividing(by, behavior) {
    let op = Int.div;
    switch (behavior) {
      case "ceil":
        op = Int.divCeil;
        break;
      case "round":
        op = Int.divRound;
        break;
    }
    return this.operator(by, op);
  }
  /**
   * Run operator with C++11 implicit conversion.
   * @internal
   */
  operator(other, fn) {
    let rhs;
    if (isInstanceOf(other, Int)) {
      rhs = other;
    } else {
      rhs = Int64.from(other, "truncate");
    }
    return fn(this, rhs).cast(this.constructor);
  }
  /**
   * Convert to a JavaScript number.
   * @throws If the number cannot be represented by 53-bits.
   **/
  toNumber() {
    return this.value.toNumber();
  }
  toString() {
    return this.value.toString();
  }
  [Symbol.toPrimitive](type) {
    if (type === "number") {
      return this.toNumber();
    } else {
      return this.toString();
    }
  }
  toABI(encoder) {
    encoder.writeArray(this.byteArray);
  }
  toJSON() {
    if (this.value.bitLength() > 32) {
      return this.value.toString();
    } else {
      return this.value.toNumber();
    }
  }
};
Int.abiName = "__int";
var Int8 = class extends Int {
};
Int8.abiName = "int8";
Int8.byteWidth = 1;
Int8.isSigned = true;
var Int16 = class extends Int {
};
Int16.abiName = "int16";
Int16.byteWidth = 2;
Int16.isSigned = true;
var Int32 = class extends Int {
};
Int32.abiName = "int32";
Int32.byteWidth = 4;
Int32.isSigned = true;
var Int64 = class extends Int {
};
Int64.abiName = "int64";
Int64.byteWidth = 8;
Int64.isSigned = true;
var Int128 = class extends Int {
};
Int128.abiName = "int128";
Int128.byteWidth = 16;
Int128.isSigned = true;
var UInt8 = class extends Int {
};
UInt8.abiName = "uint8";
UInt8.byteWidth = 1;
UInt8.isSigned = false;
var UInt16 = class extends Int {
};
UInt16.abiName = "uint16";
UInt16.byteWidth = 2;
UInt16.isSigned = false;
var UInt32 = class extends Int {
};
UInt32.abiName = "uint32";
UInt32.byteWidth = 4;
UInt32.isSigned = false;
var UInt64 = class extends Int {
};
UInt64.abiName = "uint64";
UInt64.byteWidth = 8;
UInt64.isSigned = false;
var UInt128 = class extends Int {
};
UInt128.abiName = "uint128";
UInt128.byteWidth = 16;
UInt128.isSigned = false;
var VarInt = class extends Int {
  static fromABI(decoder) {
    return new this(new import_bn.default(decoder.readVarint32()));
  }
  toABI(encoder) {
    encoder.writeVarint32(Number(this));
  }
};
VarInt.abiName = "varint32";
VarInt.byteWidth = 32;
VarInt.isSigned = true;
var VarUInt = class extends Int {
  static fromABI(decoder) {
    return new this(new import_bn.default(decoder.readVaruint32()));
  }
  toABI(encoder) {
    encoder.writeVaruint32(Number(this));
  }
};
VarUInt.abiName = "varuint32";
VarUInt.byteWidth = 32;
VarUInt.isSigned = false;
function clamp(num, min, max) {
  return import_bn.default.min(import_bn.default.max(num, min), max);
}
function truncate(value, from, to) {
  const fill = value.isNeg() ? 255 : 0;
  const fromValue = from.isSigned ? value.toTwos(from.byteWidth * 8) : value;
  const fromBytes = fromValue.toArrayLike(Uint8Array, "le");
  const toBytes = new Uint8Array(to.byteWidth);
  toBytes.fill(fill);
  toBytes.set(fromBytes.slice(0, to.byteWidth));
  const toValue = new import_bn.default(toBytes, void 0, "le");
  return to.isSigned ? toValue.fromTwos(to.byteWidth * 8) : toValue;
}
function convert(a, b) {
  a = promote(a);
  b = promote(b);
  const aType = a.constructor;
  const bType = b.constructor;
  if (aType !== bType) {
    if (aType.isSigned === bType.isSigned) {
      if (aType.byteWidth > bType.byteWidth) {
        b = b.cast(aType);
      } else if (bType.byteWidth > aType.byteWidth) {
        a = a.cast(bType);
      }
    } else {
      if (aType.isSigned === false && aType.byteWidth >= bType.byteWidth) {
        b = b.cast(aType);
      } else if (bType.isSigned === false && bType.byteWidth >= aType.byteWidth) {
        a = a.cast(bType);
      } else {
        if (aType.isSigned === true && aType.max.gte(bType.max) && aType.min.lte(bType.min)) {
          b = b.cast(aType);
        } else if (bType.isSigned === true && bType.max.gte(aType.max) && bType.min.lte(aType.min)) {
          a = a.cast(bType);
        } else
          ;
      }
    }
  }
  return { a, b };
}
function promote(n) {
  let rv = n;
  const type = n.constructor;
  if (type.byteWidth < 4) {
    rv = n.cast(Int32);
  }
  return rv;
}
function synthesizeABI(type) {
  const structs = [];
  const variants = [];
  const aliases = [];
  const seen = /* @__PURE__ */ new Set();
  const resolveAbiType = (t) => {
    let typeName;
    if (typeof t.type !== "string") {
      typeName = resolve(t.type);
    } else {
      typeName = t.type;
    }
    if (t.array === true) {
      typeName += "[]";
    }
    if (t.optional === true) {
      typeName += "?";
    }
    if (t.extension === true) {
      typeName += "$";
    }
    return typeName;
  };
  const resolve = (t) => {
    if (!t.abiName) {
      throw new Error("Encountered non-conforming type");
    } else if (t.abiName === "__struct") {
      throw new Error("Misconfigured Struct subclass, did you forget @Struct.type?");
    }
    if (seen.has(t)) {
      return t.abiName;
    }
    seen.add(t);
    if (t.abiAlias) {
      aliases.push({
        new_type_name: t.abiName,
        type: resolveAbiType(t.abiAlias)
      });
    } else if (t.abiFields) {
      const fields = t.abiFields.map((field) => {
        return {
          name: field.name,
          type: resolveAbiType(field)
        };
      });
      const struct = {
        base: t.abiBase ? resolve(t.abiBase) : "",
        name: t.abiName,
        fields
      };
      structs.push(struct);
    } else if (t.abiVariant) {
      const variant = {
        name: t.abiName,
        types: t.abiVariant.map(resolveAbiType)
      };
      variants.push(variant);
    }
    return t.abiName;
  };
  const root = resolve(type);
  return { abi: ABI.from({ structs, variants, types: aliases }), types: Array.from(seen), root };
}
function abiTypeString(type) {
  let typeName = typeof type.type === "string" ? type.type : type.type.abiName;
  if (type.array === true) {
    typeName += "[]";
  }
  if (type.optional === true) {
    typeName += "?";
  }
  if (type.extension === true) {
    typeName += "$";
  }
  return typeName;
}
function isTypeDescriptor(type) {
  return typeof type !== "string" && type.abiName === void 0 && type.type !== void 0;
}
function toTypeDescriptor(type) {
  if (typeof type === "string") {
    return { type };
  }
  if (typeof type.abiName !== "undefined") {
    return { type };
  }
  return type;
}
var StringType = {
  abiName: "string",
  abiDefault: () => "",
  fromABI: (decoder) => {
    return decoder.readString();
  },
  from: (string) => string,
  toABI: (string, encoder) => {
    encoder.writeString(string);
  }
};
var BoolType = {
  abiName: "bool",
  abiDefault: () => false,
  fromABI: (decoder) => {
    return decoder.readByte() === 1;
  },
  from: (value) => value,
  toABI: (value, encoder) => {
    encoder.writeByte(value === true ? 1 : 0);
  }
};
function getBuiltins() {
  return [
    // types represented by JavaScript builtins
    BoolType,
    StringType,
    // types represented by Classes
    Asset,
    Asset.Symbol,
    Asset.SymbolCode,
    BlockTimestamp,
    Bytes,
    Checksum160,
    Checksum256,
    Checksum512,
    ExtendedAsset,
    Float128,
    Float32,
    Float64,
    Int128,
    Int16,
    Int32,
    Int64,
    Int8,
    Name,
    PublicKey,
    Signature,
    TimePoint,
    TimePointSec,
    UInt128,
    UInt16,
    UInt32,
    UInt64,
    UInt8,
    VarInt,
    VarUInt
  ];
}
function buildTypeLookup(additional = []) {
  const rv = {};
  const builtins = getBuiltins();
  for (const type of builtins) {
    rv[type.abiName] = type;
  }
  for (const type of additional) {
    if (!type.abiName) {
      throw new Error("Invalid type");
    }
    rv[type.abiName] = type;
  }
  return rv;
}
function getTypeName(object) {
  if (object.constructor && object.constructor.abiName !== void 0) {
    return object.constructor.abiName;
  }
  if (Array.isArray(object)) {
    const types2 = object.map(getTypeName);
    const type = types2[0];
    if (!type || !types2.every((t) => t === type)) {
      return;
    }
    return type + "[]";
  }
  switch (typeof object) {
    case "boolean":
      return "bool";
    case "string":
      return "string";
  }
}
function getType(object, name = "jsobj") {
  var _a;
  if (object.constructor && object.constructor.abiName !== void 0) {
    return object.constructor;
  }
  if (Array.isArray(object)) {
    const types2 = object.map((v) => {
      return getType(v, name);
    });
    const type = types2[0];
    if (!type) {
      return;
    }
    if (!types2.every((t) => t && t.abiName === type.abiName)) {
      return;
    }
    return type;
  }
  const objectType = typeof object;
  if (objectType === "object" && object !== null) {
    const fields = Object.keys(object).map((key) => {
      return { name: key, type: getType(object[key], name + "_nested") };
    });
    if (fields.find((field) => !field.type)) {
      return;
    }
    return _a = class extends Struct {
    }, _a.abiName = name, _a.abiFields = fields, _a;
  }
  switch (objectType) {
    case "boolean":
      return BoolType;
    case "string":
      return StringType;
  }
}
var DecodingError = class extends Error {
  constructor(ctx, underlyingError) {
    const path = ctx.codingPath.map(({ field, type }) => {
      if (typeof field === "number") {
        return field;
      } else {
        return `${field}<${type.typeName}>`;
      }
    }).join(".");
    super(`Decoding error at ${path}: ${underlyingError.message}`);
    this.stack = underlyingError.stack;
    this.ctx = ctx;
    this.underlyingError = underlyingError;
  }
};
DecodingError.__className = "DecodingError";
function abiDecode(args) {
  const descriptor = toTypeDescriptor(args.type);
  const typeName = abiTypeString(descriptor);
  const customTypes = args.customTypes || [];
  let abi;
  if (args.abi) {
    abi = ABI.from(args.abi);
  } else {
    try {
      let type;
      if (typeof descriptor.type === "string") {
        const lookup2 = buildTypeLookup(customTypes);
        const rName = new ABI.ResolvedType(descriptor.type).name;
        type = lookup2[rName];
        if (!type) {
          throw new Error(`Unknown type: ${descriptor.type}`);
        }
      } else {
        type = descriptor.type;
      }
      const synthesized = synthesizeABI(type);
      abi = synthesized.abi;
      customTypes.push(...synthesized.types);
    } catch (error) {
      throw Error(`Unable to synthesize ABI for: ${typeName} (${error.message}). To decode non-class types you need to pass the ABI definition manually.`);
    }
  }
  const resolved = abi.resolveType(typeName);
  if (typeof descriptor.type !== "string") {
    customTypes.unshift(descriptor.type);
  }
  const ctx = {
    types: buildTypeLookup(customTypes),
    strictExtensions: args.strictExtensions || false,
    codingPath: [{ field: "root", type: resolved }]
  };
  try {
    if (args.data || args.data === "") {
      let decoder;
      if (isInstanceOf(args.data, ABIDecoder)) {
        decoder = args.data;
      } else {
        const bytes = Bytes.from(args.data);
        const fatal = args.ignoreInvalidUTF8 === void 0 ? true : !args.ignoreInvalidUTF8;
        decoder = new ABIDecoder(bytes.array, new TextDecoder("utf-8", { fatal }));
      }
      if (args.metadata) {
        decoder.metadata = args.metadata;
      }
      return decodeBinary(resolved, decoder, ctx);
    } else if (args.object !== void 0) {
      return decodeObject(args.object, resolved, ctx);
    } else if (args.json) {
      return decodeObject(JSON.parse(args.json), resolved, ctx);
    } else {
      throw new Error("Nothing to decode, you must set one of data, json, object");
    }
  } catch (error) {
    throw new DecodingError(ctx, error);
  }
}
var Resolved = Symbol("Resolved");
function decodeBinary(type, decoder, ctx) {
  if (ctx.codingPath.length > 32) {
    throw new Error("Maximum decoding depth exceeded");
  }
  if (type.isExtension) {
    if (!decoder.canRead()) {
      if (ctx.strictExtensions) {
        return defaultValue(type, ctx);
      } else {
        return null;
      }
    }
  }
  if (type.isOptional) {
    if (decoder.readByte() === 0) {
      return null;
    }
  }
  if (type.isArray) {
    const len = decoder.readVaruint32();
    const rv = [];
    for (let i = 0; i < len; i++) {
      ctx.codingPath.push({ field: i, type });
      rv.push(decodeInner());
      ctx.codingPath.pop();
    }
    return rv;
  } else {
    return decodeInner();
  }
  function decodeInner() {
    const abiType = ctx.types[type.name];
    if (abiType && abiType.fromABI) {
      return abiType.fromABI(decoder);
    } else {
      if (type.ref) {
        ctx.codingPath.push({ field: "", type: type.ref });
        const rv = decodeBinary(type.ref, decoder, ctx);
        ctx.codingPath.pop();
        return rv;
      } else if (type.fields) {
        const fields = type.allFields;
        if (!fields) {
          throw new Error("Invalid struct fields");
        }
        const rv = {};
        for (const field of fields) {
          ctx.codingPath.push({ field: field.name, type: field.type });
          rv[field.name] = decodeBinary(field.type, decoder, ctx);
          ctx.codingPath.pop();
        }
        if (abiType) {
          rv[Resolved] = true;
          return abiType.from(rv);
        } else {
          return rv;
        }
      } else if (type.variant) {
        const vIdx = decoder.readByte();
        const vType = type.variant[vIdx];
        if (!vType) {
          throw new Error(`Unknown variant idx: ${vIdx}`);
        }
        ctx.codingPath.push({ field: `v${vIdx}`, type: vType });
        const rv = [vType.typeName, decodeBinary(vType, decoder, ctx)];
        ctx.codingPath.pop();
        if (abiType) {
          return abiType.from(rv);
        } else {
          return rv;
        }
      } else if (abiType) {
        throw new Error("Invalid type");
      } else {
        throw new Error(type.name === "any" ? "Unable to decode 'any' type from binary" : "Unknown type");
      }
    }
  }
}
function decodeObject(value, type, ctx) {
  if (value === null || value === void 0) {
    if (type.isOptional) {
      return null;
    }
    if (type.isExtension) {
      if (ctx.strictExtensions) {
        return defaultValue(type, ctx);
      } else {
        return null;
      }
    }
    throw new Error(`Unexpectedly encountered ${value} for non-optional`);
  } else if (type.isArray) {
    if (!Array.isArray(value)) {
      throw new Error("Expected array");
    }
    const rv = [];
    const len = value.length;
    for (let i = 0; i < len; i++) {
      ctx.codingPath.push({ field: i, type });
      rv.push(decodeInner(value[i]));
      ctx.codingPath.pop();
    }
    return rv;
  } else {
    return decodeInner(value);
  }
  function decodeInner(value2) {
    const abiType = ctx.types[type.name];
    if (type.ref && !abiType) {
      return decodeObject(value2, type.ref, ctx);
    } else if (type.fields) {
      if (typeof value2 !== "object") {
        throw new Error("Expected object");
      }
      if (typeof abiType === "function" && isInstanceOf(value2, abiType)) {
        return value2;
      }
      const fields = type.allFields;
      if (!fields) {
        throw new Error("Invalid struct fields");
      }
      const struct = {};
      for (const field of fields) {
        ctx.codingPath.push({ field: field.name, type: field.type });
        struct[field.name] = decodeObject(value2[field.name], field.type, ctx);
        ctx.codingPath.pop();
      }
      if (abiType) {
        struct[Resolved] = true;
        return abiType.from(struct);
      } else {
        return struct;
      }
    } else if (type.variant) {
      let vName;
      if (Array.isArray(value2) && value2.length === 2 && typeof value2[0] === "string") {
        vName = value2[0];
        value2 = value2[1];
      } else if (isInstanceOf(value2, Variant)) {
        vName = value2.variantName;
        value2 = value2.value;
      } else {
        vName = getTypeName(value2);
      }
      const vIdx = type.variant.findIndex((t) => t.typeName === vName);
      if (vIdx === -1) {
        throw new Error(`Unknown variant type: ${vName}`);
      }
      const vType = type.variant[vIdx];
      ctx.codingPath.push({ field: `v${vIdx}`, type: vType });
      const rv = [vType.typeName, decodeObject(value2, vType, ctx)];
      ctx.codingPath.pop();
      if (abiType) {
        rv[Resolved] = true;
        return abiType.from(rv);
      } else {
        return rv;
      }
    } else {
      if (!abiType) {
        if (type.name === "any") {
          return value2;
        }
        throw new Error("Unknown type");
      }
      return abiType.from(value2);
    }
  }
}
function defaultValue(type, ctx, seen = /* @__PURE__ */ new Set()) {
  if (type.isArray) {
    return [];
  }
  if (type.isOptional) {
    return null;
  }
  const abiType = ctx.types[type.name];
  if (abiType && abiType.abiDefault) {
    return abiType.abiDefault();
  }
  if (seen.has(type.name)) {
    throw new Error("Circular type reference");
  }
  seen.add(type.name);
  if (type.allFields) {
    const rv = {};
    for (const field of type.allFields) {
      ctx.codingPath.push({ field: field.name, type: field.type });
      rv[field.name] = defaultValue(field.type, ctx, seen);
      ctx.codingPath.pop();
    }
    if (abiType) {
      rv[Resolved] = true;
      return abiType.from(rv);
    }
    return rv;
  }
  if (type.variant && type.variant.length > 0) {
    const rv = [type.variant[0].typeName, defaultValue(type.variant[0], ctx)];
    if (abiType) {
      rv[Resolved] = true;
      return abiType.from(rv);
    }
    return rv;
  }
  if (type.ref) {
    ctx.codingPath.push({ field: "", type: type.ref });
    const rv = defaultValue(type.ref, ctx, seen);
    ctx.codingPath.pop();
    return rv;
  }
  throw new Error("Unable to determine default value");
}
var ABIDecoder = class {
  constructor(array, textDecoder) {
    this.array = array;
    this.pos = 0;
    this.metadata = {};
    this.textDecoder = textDecoder || new TextDecoder("utf-8", { fatal: true });
    this.data = new DataView(array.buffer, array.byteOffset, array.byteLength);
  }
  canRead(bytes = 1) {
    return !(this.pos + bytes > this.array.byteLength);
  }
  ensure(bytes) {
    if (!this.canRead(bytes)) {
      throw new Error("Read past end of buffer");
    }
  }
  setPosition(pos) {
    if (pos < 0 || pos > this.array.byteLength) {
      throw new Error("Invalid position");
    }
    this.pos = pos;
  }
  getPosition() {
    return this.pos;
  }
  advance(bytes) {
    this.ensure(bytes);
    this.pos += bytes;
  }
  /** Read one byte. */
  readByte() {
    this.ensure(1);
    return this.array[this.pos++];
  }
  /** Read floating point as JavaScript number, 32 or 64 bits. */
  readFloat(byteWidth) {
    this.ensure(byteWidth);
    let rv;
    switch (byteWidth) {
      case 4:
        rv = this.data.getFloat32(this.pos, true);
        break;
      case 8:
        rv = this.data.getFloat64(this.pos, true);
        break;
      default:
        throw new Error("Invalid float size");
    }
    this.pos += byteWidth;
    return rv;
  }
  readVaruint32() {
    let v = 0;
    let bit = 0;
    for (; ; ) {
      const b = this.readByte();
      v |= (b & 127) << bit;
      bit += 7;
      if (!(b & 128)) {
        break;
      }
    }
    return v >>> 0;
  }
  readVarint32() {
    const v = this.readVaruint32();
    if (v & 1) {
      return ~v >> 1 | 2147483648;
    } else {
      return v >>> 1;
    }
  }
  readArray(length) {
    this.ensure(length);
    const rv = this.array.subarray(this.pos, this.pos + length);
    this.pos += length;
    return rv;
  }
  readString() {
    const length = this.readVaruint32();
    return this.textDecoder.decode(this.readArray(length));
  }
};
ABIDecoder.__className = "ABIDecoder";
var EncodingError = class extends Error {
  constructor(ctx, underlyingError) {
    const path = ctx.codingPath.map(({ field, type }) => {
      if (typeof field === "number") {
        return field;
      } else {
        return `${field}<${type.typeName}>`;
      }
    }).join(".");
    super(`Encoding error at ${path}: ${underlyingError.message}`);
    this.stack = underlyingError.stack;
    this.ctx = ctx;
    this.underlyingError = underlyingError;
  }
};
EncodingError.__className = "EncodingError";
function abiEncode(args) {
  let type;
  let typeName;
  if (typeof args.type === "string") {
    typeName = args.type;
  } else if (args.type && isTypeDescriptor(args.type)) {
    if (typeof args.type.type !== "string") {
      type = args.type.type;
    }
    typeName = abiTypeString(args.type);
  } else if (args.type && args.type.abiName !== void 0) {
    type = args.type;
    typeName = args.type.abiName;
  } else {
    type = getType(args.object);
    if (type) {
      typeName = type.abiName;
      if (Array.isArray(args.object)) {
        typeName += "[]";
      }
    }
  }
  const customTypes = args.customTypes ? args.customTypes.slice() : [];
  if (type) {
    customTypes.unshift(type);
  } else if (typeName) {
    const rootName = new ABI.ResolvedType(typeName).name;
    type = customTypes.find((t) => t.abiName === rootName);
  }
  let rootType;
  if (args.abi && typeName) {
    rootType = ABI.from(args.abi).resolveType(typeName);
  } else if (type) {
    const synthesized = synthesizeABI(type);
    rootType = synthesized.abi.resolveType(typeName || type.abiName);
    customTypes.push(...synthesized.types);
  } else if (typeName) {
    rootType = new ABI.ResolvedType(typeName);
  } else {
    throw new Error("Unable to determine the type of the object to be encoded. To encode custom ABI types you must pass the type argument.");
  }
  const types2 = buildTypeLookup(customTypes);
  const encoder = args.encoder || new ABIEncoder();
  if (args.metadata) {
    encoder.metadata = args.metadata;
  }
  const ctx = {
    types: types2,
    encoder,
    codingPath: [{ field: "root", type: rootType }]
  };
  try {
    encodeAny(args.object, rootType, ctx);
  } catch (error) {
    throw new EncodingError(ctx, error);
  }
  return Bytes.from(encoder.getData());
}
function encodeAny(value, type, ctx) {
  const valueExists = value !== void 0 && value !== null;
  if (type.isOptional) {
    ctx.encoder.writeByte(valueExists ? 1 : 0);
    if (!valueExists) {
      return;
    }
  }
  if (type.isArray) {
    if (!Array.isArray(value)) {
      throw new Error(`Expected array for: ${type.typeName}`);
    }
    const len = value.length;
    ctx.encoder.writeVaruint32(len);
    for (let i = 0; i < len; i++) {
      ctx.codingPath.push({ field: i, type });
      encodeInner(value[i]);
      ctx.codingPath.pop();
    }
  } else {
    encodeInner(value);
  }
  function encodeInner(value2) {
    const abiType = ctx.types[type.name];
    if (type.ref && !abiType) {
      encodeAny(value2, type.ref, ctx);
      return;
    }
    if (!valueExists) {
      if (type.isExtension) {
        return;
      }
      throw new Error(`Found ${value2} for non-optional type: ${type.typeName}`);
    }
    if (abiType && abiType.toABI) {
      abiType.toABI(value2, ctx.encoder);
    } else if (typeof value2.toABI === "function" && value2.constructor.abiName === type.name) {
      value2.toABI(ctx.encoder);
    } else {
      if (type.fields) {
        if (typeof value2 !== "object") {
          throw new Error(`Expected object for: ${type.name}`);
        }
        const fields = type.allFields;
        if (!fields) {
          throw new Error("Invalid struct fields");
        }
        for (const field of fields) {
          ctx.codingPath.push({ field: field.name, type: field.type });
          encodeAny(value2[field.name], field.type, ctx);
          ctx.codingPath.pop();
        }
      } else if (type.variant) {
        let vName;
        if (Array.isArray(value2) && value2.length === 2 && typeof value2[0] === "string") {
          vName = value2[0];
          value2 = value2[1];
        } else if (isInstanceOf(value2, Variant)) {
          vName = value2.variantName;
          value2 = value2.value;
        } else {
          vName = getTypeName(value2);
        }
        const vIdx = type.variant.findIndex((t) => t.typeName === vName);
        if (vIdx === -1) {
          const types2 = type.variant.map((t) => `'${t.typeName}'`).join(", ");
          throw new Error(`Unknown variant type '${vName}', expected one of ${types2}`);
        }
        const vType = type.variant[vIdx];
        ctx.encoder.writeVaruint32(vIdx);
        ctx.codingPath.push({ field: `v${vIdx}`, type: vType });
        encodeAny(value2, vType, ctx);
        ctx.codingPath.pop();
      } else {
        if (!abiType) {
          throw new Error(type.name === "any" ? "Unable to encode any type to binary" : "Unknown type");
        }
        const instance = abiType.from(value2);
        if (!instance.toABI) {
          throw new Error(`Invalid type ${type.name}, no encoding methods implemented`);
        }
        instance.toABI(ctx.encoder);
      }
    }
  }
}
var ABIEncoder = class {
  constructor(pageSize = 1024) {
    this.pageSize = pageSize;
    this.pos = 0;
    this.textEncoder = new TextEncoder();
    this.metadata = {};
    const buffer = new ArrayBuffer(pageSize);
    this.data = new DataView(buffer);
    this.array = new Uint8Array(buffer);
  }
  ensure(bytes) {
    if (this.data.byteLength >= this.pos + bytes) {
      return;
    }
    const pages = Math.ceil(bytes / this.pageSize);
    const newSize = this.data.byteLength + this.pageSize * pages;
    const buffer = new ArrayBuffer(newSize);
    const data = new DataView(buffer);
    const array = new Uint8Array(buffer);
    array.set(this.array);
    this.data = data;
    this.array = array;
  }
  /** Write a single byte. */
  writeByte(byte) {
    this.ensure(1);
    this.array[this.pos++] = byte;
  }
  /** Write an array of bytes. */
  writeArray(bytes) {
    const size = bytes.length;
    this.ensure(size);
    this.array.set(bytes, this.pos);
    this.pos += size;
  }
  writeFloat(value, byteWidth) {
    this.ensure(byteWidth);
    switch (byteWidth) {
      case 4:
        this.data.setFloat32(this.pos, value, true);
        break;
      case 8:
        this.data.setFloat64(this.pos, value, true);
        break;
      default:
        throw new Error("Invalid float size");
    }
    this.pos += byteWidth;
  }
  writeVaruint32(v) {
    this.ensure(4);
    for (; ; ) {
      if (v >>> 7) {
        this.array[this.pos++] = 128 | v & 127;
        v = v >>> 7;
      } else {
        this.array[this.pos++] = v;
        break;
      }
    }
  }
  writeVarint32(v) {
    this.writeVaruint32(v << 1 ^ v >> 31);
  }
  writeString(v) {
    const data = this.textEncoder.encode(v);
    this.writeVaruint32(data.byteLength);
    this.writeArray(data);
  }
  getData() {
    return new Uint8Array(this.array.buffer, this.array.byteOffset, this.pos);
  }
  getBytes() {
    return new Bytes(this.getData());
  }
};
ABIEncoder.__className = "ABIEncoder";
var Struct = class {
  static from(value) {
    if (value[Resolved] === true) {
      return new this(value);
    }
    if (isInstanceOf(value, this)) {
      return value;
    }
    return abiDecode({ object: value, type: this });
  }
  static get structFields() {
    const rv = [];
    const walk = (t) => {
      if (t.abiBase) {
        walk(t.abiBase);
      }
      for (const field of t.abiFields || []) {
        rv.push(field);
      }
    };
    walk(this);
    return rv;
  }
  /** @internal */
  constructor(object) {
    const self = this.constructor;
    for (const field of self.structFields) {
      this[field.name] = object[field.name];
    }
  }
  /**
   * Return true if this struct equals the other.
   *
   * Note: This compares the ABI encoded bytes of both structs, subclasses
   *       should implement their own fast equality check when possible.
   */
  equals(other) {
    const self = this.constructor;
    if (other.constructor && typeof other.constructor.abiName === "string" && other.constructor.abiName !== self.abiName) {
      return false;
    }
    return abiEncode({ object: this }).equals(abiEncode({ object: self.from(other) }));
  }
  /** @internal */
  toJSON() {
    const self = this.constructor;
    const rv = {};
    for (const field of self.structFields) {
      rv[field.name] = this[field.name];
    }
    return rv;
  }
};
Struct.abiName = "__struct";
(function(Struct2) {
  const FieldsOwner = Symbol("FieldsOwner");
  function type(name) {
    return function(struct) {
      struct.abiName = name;
      return struct;
    };
  }
  Struct2.type = type;
  function field(type2, options = {}) {
    return (target, name) => {
      const ctor = target.constructor;
      if (!ctor.abiFields) {
        ctor.abiFields = [];
        ctor.abiFields[FieldsOwner] = ctor;
      } else if (ctor.abiFields[FieldsOwner] !== ctor) {
        ctor.abiBase = ctor.abiFields[FieldsOwner];
        ctor.abiFields = [];
        ctor.abiFields[FieldsOwner] = ctor;
      }
      ctor.abiFields.push({ ...options, name, type: type2 });
    };
  }
  Struct2.field = field;
})(Struct || (Struct = {}));
function TypeAlias(name) {
  return function(typeAlias) {
    typeAlias.abiAlias = { type: Object.getPrototypeOf(typeAlias.prototype).constructor };
    typeAlias.abiName = name;
    return typeAlias;
  };
}
var Variant = class {
  static from(object) {
    if (object[Resolved]) {
      return new this(object);
    }
    if (isInstanceOf(object, this)) {
      return object;
    }
    return abiDecode({ object, type: this });
  }
  /** @internal */
  constructor(variant) {
    const abiVariant = this.constructor.abiVariant;
    this.value = variant[1];
    const variantIdx = abiVariant.map(abiTypeString).findIndex((t) => t === variant[0]);
    if (0 > variantIdx || abiVariant.length <= variantIdx) {
      throw new Error(`Unknown variant ${variant[0]}`);
    }
    this.variantIdx = variantIdx;
  }
  /**
   * Return true if this variant equals the other.
   *
   * Note: This compares the ABI encoded bytes of both variants, subclasses
   *       should implement their own fast equality check when possible.
   */
  equals(other) {
    const self = this.constructor;
    const otherVariant = self.from(other);
    if (this.variantIdx !== otherVariant.variantIdx) {
      return false;
    }
    return abiEncode({ object: this }).equals(abiEncode({ object: otherVariant }));
  }
  get variantName() {
    const variant = this.constructor.abiVariant[this.variantIdx];
    return abiTypeString(variant);
  }
  /** @internal */
  toJSON() {
    return [this.variantName, this.value];
  }
};
Variant.abiName = "__variant";
Variant.abiVariant = [];
(function(Variant2) {
  function type(name, types2) {
    return function(variant) {
      variant.abiName = name;
      variant.abiVariant = types2.map(toTypeDescriptor);
      return variant;
    };
  }
  Variant2.type = type;
})(Variant || (Variant = {}));
var Float = class {
  static from(value) {
    if (isInstanceOf(value, this)) {
      return value;
    }
    if (typeof value === "string") {
      value = Number.parseFloat(value);
    } else if (isInstanceOf(value, Float)) {
      value = value.value;
    }
    return new this(value);
  }
  static fromABI(decoder) {
    return new this(decoder.readFloat(this.byteWidth));
  }
  static abiDefault() {
    return this.from(0);
  }
  static random() {
    const bytes = secureRandom(this.byteWidth);
    const decoder = new ABIDecoder(bytes);
    return this.fromABI(decoder);
  }
  constructor(value) {
    if (!Number.isFinite(value)) {
      throw new Error("Invalid number");
    }
    this.value = value;
  }
  equals(other) {
    const self = this.constructor;
    return this.value === self.from(other).value;
  }
  toABI(encoder) {
    const self = this.constructor;
    encoder.writeFloat(this.value, self.byteWidth);
  }
  toString() {
    return this.value.toString();
  }
  toJSON() {
    return this.toString();
  }
};
Float.abiName = "__float";
var Float32 = class extends Float {
  toString() {
    return this.value.toFixed(7);
  }
};
Float32.abiName = "float32";
Float32.byteWidth = 4;
var Float64 = class extends Float {
};
Float64.abiName = "float64";
Float64.byteWidth = 8;
var Float128 = class {
  static from(value) {
    if (isInstanceOf(value, this)) {
      return value;
    }
    if (typeof value === "string" && value.startsWith("0x")) {
      value = value.slice(2);
    }
    return new this(Bytes.from(value));
  }
  static fromABI(decoder) {
    return new this(new Bytes(decoder.readArray(this.byteWidth)));
  }
  static random() {
    const bytes = secureRandom(16);
    const decoder = new ABIDecoder(bytes);
    return this.fromABI(decoder);
  }
  constructor(data) {
    if (data.array.length !== 16) {
      throw new Error("Invalid float128");
    }
    this.data = data;
  }
  equals(other) {
    const self = this.constructor;
    return this.data.equals(self.from(other).data);
  }
  toABI(encoder) {
    encoder.writeArray(this.data.array);
  }
  toString() {
    return "0x" + this.data.hexString;
  }
  toJSON() {
    return this.toString();
  }
};
Float128.abiName = "float128";
Float128.byteWidth = 16;
var Name = class {
  /**
   * The raw representation of the name.
   * @deprecated Use value instead.
   */
  get rawValue() {
    return this.value;
  }
  /** Create a new Name instance from any of its representing types. */
  static from(value) {
    if (isInstanceOf(value, Name)) {
      return value;
    } else if (typeof value === "string") {
      return new Name(stringToName(value));
    } else if (isInstanceOf(value, UInt64)) {
      return new Name(value);
    } else {
      throw new Error("Invalid name");
    }
  }
  static fromABI(decoder) {
    return new Name(UInt64.fromABI(decoder));
  }
  static abiDefault() {
    return new this(UInt64.from(0));
  }
  constructor(value) {
    this.value = value;
  }
  /** Return true if this name is equal to passed name. */
  equals(other) {
    return this.value.equals(Name.from(other).value);
  }
  /** Return string representation of this name. */
  toString() {
    return nameToString(this.value);
  }
  toABI(encoder) {
    this.value.toABI(encoder);
  }
  /** @internal */
  toJSON() {
    return this.toString();
  }
};
Name.abiName = "name";
Name.pattern = /^[a-z1-5.]{0,13}$/;
function stringToName(s) {
  function charToSymbol(c) {
    if (c >= "a".charCodeAt(0) && c <= "z".charCodeAt(0)) {
      return c - "a".charCodeAt(0) + 6;
    }
    if (c >= "1".charCodeAt(0) && c <= "5".charCodeAt(0)) {
      return c - "1".charCodeAt(0) + 1;
    }
    return 0;
  }
  const a = new Uint8Array(8);
  let bit = 63;
  for (let i = 0; i < s.length; ++i) {
    let c = charToSymbol(s.charCodeAt(i));
    if (bit < 5) {
      c = c << 1;
    }
    for (let j = 4; j >= 0; --j) {
      if (bit >= 0) {
        a[Math.floor(bit / 8)] |= (c >> j & 1) << bit % 8;
        --bit;
      }
    }
  }
  return UInt64.from(a);
}
function nameToString(n) {
  const a = n.value.toArray("le", 8);
  let result = "";
  for (let bit = 63; bit >= 0; ) {
    let c = 0;
    for (let i = 0; i < 5; ++i) {
      if (bit >= 0) {
        c = c << 1 | a[Math.floor(bit / 8)] >> bit % 8 & 1;
        --bit;
      }
    }
    if (c >= 6) {
      result += String.fromCharCode(c + "a".charCodeAt(0) - 6);
    } else if (c >= 1) {
      result += String.fromCharCode(c + "1".charCodeAt(0) - 1);
    } else {
      result += ".";
    }
  }
  while (result.endsWith(".")) {
    result = result.substr(0, result.length - 1);
  }
  return result;
}
var TimePointBase = class {
  static from(value) {
    if (isInstanceOf(value, this)) {
      return value;
    }
    if (isInstanceOf(value, TimePointBase)) {
      return this.fromMilliseconds(value.toMilliseconds());
    }
    if (isInstanceOf(value, Date)) {
      return this.fromDate(value);
    }
    if (typeof value === "string") {
      return this.fromString(value);
    }
    return this.fromInteger(value);
  }
  static fromString(string) {
    const value = Date.parse(string + "Z");
    if (!Number.isFinite(value)) {
      throw new Error("Invalid date string");
    }
    return this.fromMilliseconds(value);
  }
  static fromDate(date) {
    return this.fromMilliseconds(date.getTime());
  }
  static abiDefault() {
    return this.from(0);
  }
  toABI(encoder) {
    const self = this;
    self.value.toABI(encoder);
  }
  equals(other) {
    const self = this.constructor;
    return this.toMilliseconds() === self.from(other).toMilliseconds();
  }
  toMilliseconds() {
    throw new Error("Not implemented");
  }
  toDate() {
    return new Date(this.toMilliseconds());
  }
  toJSON() {
    return this.toString();
  }
};
TimePointBase.abiName = "__time_point_base";
var TimePoint = class extends TimePointBase {
  static fromMilliseconds(ms) {
    return new this(Int64.from(Math.round(ms * 1e3)));
  }
  static fromInteger(value) {
    return new this(Int64.from(value));
  }
  static fromABI(decoder) {
    return new this(Int64.fromABI(decoder));
  }
  constructor(value) {
    super();
    this.value = value;
  }
  toString() {
    return this.toDate().toISOString().slice(0, -1);
  }
  toMilliseconds() {
    return Number(this.value.dividing(1e3, "round"));
  }
};
TimePoint.abiName = "time_point";
var TimePointSec = class extends TimePointBase {
  static fromMilliseconds(ms) {
    return new this(UInt32.from(Math.round(ms / 1e3)));
  }
  static fromInteger(value) {
    return new this(UInt32.from(value));
  }
  static fromABI(decoder) {
    return new this(UInt32.fromABI(decoder));
  }
  constructor(value) {
    super();
    this.value = value;
  }
  toString() {
    return this.toDate().toISOString().slice(0, -5);
  }
  toMilliseconds() {
    return Number(this.value.cast(UInt64).multiplying(1e3));
  }
};
TimePointSec.abiName = "time_point_sec";
var BlockTimestamp = class extends TimePointBase {
  static fromMilliseconds(ms) {
    return new this(UInt32.from(Math.round((ms - 9466848e5) / 500)));
  }
  static fromInteger(value) {
    return new this(UInt32.from(value));
  }
  static fromABI(decoder) {
    return new this(UInt32.fromABI(decoder));
  }
  constructor(value) {
    super();
    this.value = value;
  }
  toString() {
    return this.toDate().toISOString().slice(0, -1);
  }
  toMilliseconds() {
    return Number(this.value.cast(UInt64).multiplying(500).adding(9466848e5));
  }
};
BlockTimestamp.abiName = "block_timestamp_type";
var ABI = class {
  constructor(args) {
    this.version = args.version || ABI.version;
    this.types = args.types || [];
    this.variants = args.variants || [];
    this.structs = args.structs || [];
    this.actions = args.actions || [];
    this.tables = args.tables || [];
    this.ricardian_clauses = args.ricardian_clauses || [];
  }
  static from(value) {
    if (isInstanceOf(value, ABI)) {
      return value;
    }
    if (typeof value === "string") {
      return new ABI(JSON.parse(value));
    }
    return new ABI(value);
  }
  static fromABI(decoder) {
    const version = decoder.readString();
    const types2 = [];
    const numTypes = decoder.readVaruint32();
    for (let i = 0; i < numTypes; i++) {
      types2.push({ new_type_name: decoder.readString(), type: decoder.readString() });
    }
    const structs = [];
    const numStructs = decoder.readVaruint32();
    for (let i = 0; i < numStructs; i++) {
      const name = decoder.readString();
      const base = decoder.readString();
      const numFields = decoder.readVaruint32();
      const fields = [];
      for (let j = 0; j < numFields; j++) {
        fields.push({ name: decoder.readString(), type: decoder.readString() });
      }
      structs.push({ base, name, fields });
    }
    const actions = [];
    const numActions = decoder.readVaruint32();
    for (let i = 0; i < numActions; i++) {
      const name = Name.fromABI(decoder);
      const type = decoder.readString();
      const ricardian_contract = decoder.readString();
      actions.push({ name, type, ricardian_contract });
    }
    const tables = [];
    const numTables = decoder.readVaruint32();
    for (let i = 0; i < numTables; i++) {
      const name = Name.fromABI(decoder);
      const index_type = decoder.readString();
      const key_names = [];
      const numKeyNames = decoder.readVaruint32();
      for (let j = 0; j < numKeyNames; j++) {
        key_names.push(decoder.readString());
      }
      const key_types = [];
      const numKeyTypes = decoder.readVaruint32();
      for (let j = 0; j < numKeyTypes; j++) {
        key_types.push(decoder.readString());
      }
      const type = decoder.readString();
      tables.push({ name, index_type, key_names, key_types, type });
    }
    const ricardian_clauses = [];
    const numClauses = decoder.readVaruint32();
    for (let i = 0; i < numClauses; i++) {
      const id = decoder.readString();
      const body = decoder.readString();
      ricardian_clauses.push({ id, body });
    }
    const numErrors = decoder.readVaruint32();
    for (let i = 0; i < numErrors; i++) {
      decoder.advance(8);
      decoder.advance(decoder.readVaruint32());
    }
    const numExtensions = decoder.readVaruint32();
    for (let i = 0; i < numExtensions; i++) {
      decoder.advance(2);
      decoder.advance(decoder.readVaruint32());
    }
    const variants = [];
    if (decoder.canRead()) {
      const numVariants = decoder.readVaruint32();
      for (let i = 0; i < numVariants; i++) {
        const name = decoder.readString();
        const types3 = [];
        const numTypes2 = decoder.readVaruint32();
        for (let j = 0; j < numTypes2; j++) {
          types3.push(decoder.readString());
        }
        variants.push({ name, types: types3 });
      }
    }
    return new ABI({
      version,
      types: types2,
      structs,
      actions,
      tables,
      ricardian_clauses,
      variants
    });
  }
  toABI(encoder) {
    encoder.writeString(this.version);
    encoder.writeVaruint32(this.types.length);
    for (const type of this.types) {
      encoder.writeString(type.new_type_name);
      encoder.writeString(type.type);
    }
    encoder.writeVaruint32(this.structs.length);
    for (const struct of this.structs) {
      encoder.writeString(struct.name);
      encoder.writeString(struct.base);
      encoder.writeVaruint32(struct.fields.length);
      for (const field of struct.fields) {
        encoder.writeString(field.name);
        encoder.writeString(field.type);
      }
    }
    encoder.writeVaruint32(this.actions.length);
    for (const action of this.actions) {
      Name.from(action.name).toABI(encoder);
      encoder.writeString(action.type);
      encoder.writeString(action.ricardian_contract);
    }
    encoder.writeVaruint32(this.tables.length);
    for (const table of this.tables) {
      Name.from(table.name).toABI(encoder);
      encoder.writeString(table.index_type);
      encoder.writeVaruint32(table.key_names.length);
      for (const key of table.key_names) {
        encoder.writeString(key);
      }
      encoder.writeVaruint32(table.key_types.length);
      for (const key of table.key_types) {
        encoder.writeString(key);
      }
      encoder.writeString(table.type);
    }
    encoder.writeVaruint32(this.ricardian_clauses.length);
    for (const clause of this.ricardian_clauses) {
      encoder.writeString(clause.id);
      encoder.writeString(clause.body);
    }
    encoder.writeVaruint32(0);
    encoder.writeVaruint32(0);
    encoder.writeVaruint32(this.variants.length);
    for (const variant of this.variants) {
      encoder.writeString(variant.name);
      encoder.writeVaruint32(variant.types.length);
      for (const type of variant.types) {
        encoder.writeString(type);
      }
    }
  }
  resolveType(name) {
    const types2 = {};
    return this.resolve({ name, types: types2 }, { id: 0 });
  }
  resolveAll() {
    const types2 = {};
    const ctx = { id: 0 };
    return {
      types: this.types.map((t) => this.resolve({ name: t.new_type_name, types: types2 }, ctx)),
      variants: this.variants.map((t) => this.resolve({ name: t.name, types: types2 }, ctx)),
      structs: this.structs.map((t) => this.resolve({ name: t.name, types: types2 }, ctx))
    };
  }
  resolve({ name, types: types2 }, ctx) {
    const existing = types2[name];
    if (existing) {
      return existing;
    }
    const type = new ABI.ResolvedType(name, ++ctx.id);
    types2[type.typeName] = type;
    const alias = this.types.find((typeDef) => typeDef.new_type_name == type.name);
    if (alias) {
      type.ref = this.resolve({ name: alias.type, types: types2 }, ctx);
      return type;
    }
    const struct = this.getStruct(type.name);
    if (struct) {
      if (struct.base) {
        type.base = this.resolve({ name: struct.base, types: types2 }, ctx);
      }
      type.fields = struct.fields.map((field) => {
        return {
          name: field.name,
          type: this.resolve({ name: field.type, types: types2 }, ctx)
        };
      });
      return type;
    }
    const variant = this.getVariant(type.name);
    if (variant) {
      type.variant = variant.types.map((name2) => this.resolve({ name: name2, types: types2 }, ctx));
      return type;
    }
    return type;
  }
  getStruct(name) {
    return this.structs.find((struct) => struct.name == name);
  }
  getVariant(name) {
    return this.variants.find((variant) => variant.name == name);
  }
  /** Return arguments type of an action in this ABI. */
  getActionType(actionName) {
    const name = Name.from(actionName).toString();
    const action = this.actions.find((a) => a.name.toString() === name);
    if (action) {
      return action.type;
    }
  }
  equals(other) {
    const o = ABI.from(other);
    if (this.version != o.version || this.types.length != o.types.length || this.structs.length != o.structs.length || this.actions.length != o.actions.length || this.tables.length != o.tables.length || this.ricardian_clauses.length != o.ricardian_clauses.length || this.variants.length != o.variants.length) {
      return false;
    }
    return abiEncode({ object: this }).equals(abiEncode({ object: o }));
  }
  toJSON() {
    return {
      version: this.version,
      types: this.types,
      structs: this.structs,
      actions: this.actions,
      tables: this.tables,
      ricardian_clauses: this.ricardian_clauses,
      error_messages: [],
      abi_extensions: [],
      variants: this.variants
    };
  }
};
ABI.abiName = "abi";
ABI.version = "eosio::abi/1.1";
(function(ABI2) {
  class ResolvedType {
    constructor(fullName, id = 0) {
      let name = fullName;
      if (name.endsWith("$")) {
        name = name.slice(0, -1);
        this.isExtension = true;
      } else {
        this.isExtension = false;
      }
      if (name.endsWith("?")) {
        name = name.slice(0, -1);
        this.isOptional = true;
      } else {
        this.isOptional = false;
      }
      if (name.endsWith("[]")) {
        name = name.slice(0, -2);
        this.isArray = true;
      } else {
        this.isArray = false;
      }
      this.id = id;
      this.name = name;
    }
    /**
     * Type name including suffixes: [] array, ? optional, $ binary ext
     */
    get typeName() {
      let rv = this.name;
      if (this.isArray) {
        rv += "[]";
      }
      if (this.isOptional) {
        rv += "?";
      }
      if (this.isExtension) {
        rv += "$";
      }
      return rv;
    }
    /** All fields including base struct(s), undefined if not a struct type. */
    get allFields() {
      let current = this;
      const rv = [];
      const seen = /* @__PURE__ */ new Set();
      do {
        if (!current.fields) {
          return;
        }
        if (seen.has(current.name)) {
          return;
        }
        for (let i = current.fields.length - 1; i >= 0; i--) {
          rv.unshift(current.fields[i]);
        }
        seen.add(current.name);
        current = current.base;
      } while (current !== void 0);
      return rv;
    }
  }
  ABI2.ResolvedType = ResolvedType;
})(ABI || (ABI = {}));
var Asset = class {
  static from(value, symbol) {
    if (isInstanceOf(value, Asset)) {
      return value;
    }
    switch (typeof value) {
      case "number":
        if (!symbol) {
          throw new Error("Symbol is required when creating Asset from number");
        }
        return this.fromFloat(value, symbol);
      case "string":
        return this.fromString(value);
      default:
        throw new Error("Invalid asset");
    }
  }
  static fromString(value) {
    const parts = (typeof value === "string" ? value : "").split(" ");
    if (parts.length !== 2) {
      throw new Error("Invalid asset string");
    }
    const amount = parts[0].replace(".", "");
    const precision = (parts[0].split(".")[1] || "").length;
    const symbol = Asset.Symbol.fromParts(parts[1], precision);
    return new Asset(Int64.from(amount), symbol);
  }
  static fromFloat(value, symbol) {
    const s = Asset.Symbol.from(symbol);
    return new Asset(s.convertFloat(value), s);
  }
  static fromUnits(value, symbol) {
    return new Asset(Int64.from(value), Asset.Symbol.from(symbol));
  }
  static fromABI(decoder) {
    const units = Int64.fromABI(decoder);
    const symbol = Asset.Symbol.fromABI(decoder);
    return new Asset(units, symbol);
  }
  static abiDefault() {
    return new this(Int64.from(0), Asset.Symbol.abiDefault());
  }
  constructor(units, symbol) {
    this.units = units;
    this.symbol = symbol;
  }
  equals(other) {
    const { symbol, units } = Asset.from(other);
    return this.symbol.value.equals(symbol.value) && this.units.equals(units);
  }
  get value() {
    return this.symbol.convertUnits(this.units);
  }
  set value(newValue) {
    this.units = this.symbol.convertFloat(newValue);
  }
  toABI(encoder) {
    this.units.toABI(encoder);
    this.symbol.toABI(encoder);
  }
  toString() {
    const digits = this.units.toString().split("");
    let negative = false;
    if (digits[0] === "-") {
      negative = true;
      digits.shift();
    }
    const p = this.symbol.precision;
    while (digits.length <= p) {
      digits.unshift("0");
    }
    if (p > 0) {
      digits.splice(digits.length - p, 0, ".");
    }
    let rv = digits.join("");
    if (negative) {
      rv = "-" + rv;
    }
    return rv + " " + this.symbol.name;
  }
  toJSON() {
    return this.toString();
  }
};
Asset.abiName = "asset";
(function(Asset2) {
  class Symbol2 {
    static from(value) {
      if (isInstanceOf(value, Symbol2)) {
        return value;
      }
      if (isInstanceOf(value, UInt64)) {
        return new Symbol2(value);
      }
      const parts = value.split(",");
      if (parts.length !== 2) {
        throw new Error("Invalid symbol string");
      }
      const precision = Number.parseInt(parts[0]);
      return Symbol2.fromParts(parts[1], precision);
    }
    static fromParts(name, precision) {
      return new Symbol2(toRawSymbol(name, precision));
    }
    // eslint-disable-next-line @typescript-eslint/ban-types
    static fromABI(decoder) {
      return new Symbol2(UInt64.fromABI(decoder));
    }
    static abiDefault() {
      return this.from("4,SYS");
    }
    constructor(value) {
      if (toSymbolPrecision(value) > Symbol2.maxPrecision) {
        throw new Error("Invalid asset symbol, precision too large");
      }
      if (!Symbol2.symbolNamePattern.test(toSymbolName(value))) {
        throw new Error("Invalid asset symbol, name must be uppercase A-Z");
      }
      this.value = value;
    }
    equals(other) {
      return this.value.equals(Symbol2.from(other).value);
    }
    get name() {
      return toSymbolName(this.value);
    }
    get precision() {
      return toSymbolPrecision(this.value);
    }
    get code() {
      return new SymbolCode(UInt64.from(this.value.value.clone().iushrn(8)));
    }
    toABI(encoder) {
      this.value.toABI(encoder);
    }
    /**
     * Convert units to floating point number according to symbol precision.
     * @throws If the given units can't be represented in 53 bits.
     **/
    convertUnits(units) {
      return units.value.toNumber() / Math.pow(10, this.precision);
    }
    /**
     * Convert floating point to units according to symbol precision.
     * Note that the value will be rounded to closest precision.
     **/
    convertFloat(float) {
      return Int64.from(float.toFixed(this.precision).replace(".", ""));
    }
    toString() {
      return `${this.precision},${this.name}`;
    }
    toJSON() {
      return this.toString();
    }
  }
  Symbol2.abiName = "symbol";
  Symbol2.symbolNamePattern = /^[A-Z]{0,7}$/;
  Symbol2.maxPrecision = 18;
  Asset2.Symbol = Symbol2;
  class SymbolCode {
    static from(value) {
      if (isInstanceOf(value, SymbolCode)) {
        return value;
      }
      if (typeof value === "string") {
        value = UInt64.from(toRawSymbolCode(value));
      }
      return new this(UInt64.from(value));
    }
    static fromABI(decoder) {
      return new SymbolCode(UInt64.fromABI(decoder));
    }
    static abiDefault() {
      return this.from("SYS");
    }
    constructor(value) {
      this.value = value;
    }
    equals(other) {
      return this.value.equals(SymbolCode.from(other).value);
    }
    toABI(encoder) {
      this.value.toABI(encoder);
    }
    toString() {
      return charsToSymbolName(this.value.value.toArray("be"));
    }
    toJSON() {
      return this.toString();
    }
  }
  SymbolCode.abiName = "symbol_code";
  Asset2.SymbolCode = SymbolCode;
})(Asset || (Asset = {}));
var ExtendedAsset = class {
  static from(value) {
    if (isInstanceOf(value, ExtendedAsset)) {
      return value;
    }
    return new this(Asset.from(value.quantity), Name.from(value.contract));
  }
  static fromABI(decoder) {
    return new ExtendedAsset(Asset.fromABI(decoder), Name.fromABI(decoder));
  }
  constructor(quantity, contract) {
    this.quantity = quantity;
    this.contract = contract;
  }
  equals(other) {
    return this.quantity.equals(other.quantity) && this.contract.equals(other.contract);
  }
  toABI(encoder) {
    this.quantity.toABI(encoder);
    this.contract.toABI(encoder);
  }
  toJSON() {
    return {
      quantity: this.quantity,
      contract: this.contract
    };
  }
};
ExtendedAsset.abiName = "extended_asset";
function toSymbolPrecision(rawSymbol) {
  return rawSymbol.value.and(UInt64.from(255).value).toNumber();
}
function toSymbolName(rawSymbol) {
  const chars = rawSymbol.value.toArray("be").slice(0, -1);
  return charsToSymbolName(chars);
}
function charsToSymbolName(chars) {
  return chars.map((char) => String.fromCharCode(char)).reverse().join("");
}
function toRawSymbol(name, precision) {
  const code = toRawSymbolCode(name);
  const bytes = new Uint8Array(code.length + 1);
  bytes[0] = precision;
  bytes.set(code, 1);
  return UInt64.from(bytes);
}
function toRawSymbolCode(name) {
  const length = Math.min(name.length, 7);
  const bytes = new Uint8Array(length);
  for (let i = 0; i < length; i++) {
    bytes[i] = name.charCodeAt(i);
  }
  return bytes;
}
var Base58;
(function(Base582) {
  let ErrorCode;
  (function(ErrorCode2) {
    ErrorCode2["E_CHECKSUM"] = "E_CHECKSUM";
    ErrorCode2["E_INVALID"] = "E_INVALID";
  })(ErrorCode = Base582.ErrorCode || (Base582.ErrorCode = {}));
  class DecodingError2 extends Error {
    constructor(message, code, info = {}) {
      super(message);
      this.code = code;
      this.info = info;
    }
  }
  DecodingError2.__className = "DecodingError";
  Base582.DecodingError = DecodingError2;
  const chars = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
  const charMap = new Int16Array(255).fill(-1);
  for (let i = 0; i < 58; ++i) {
    charMap[chars.charCodeAt(i)] = i;
  }
  function decode2(s, size) {
    if (size == null) {
      return decodeVar(s);
    }
    const result = new Uint8Array(size);
    for (let i = 0; i < s.length; ++i) {
      let carry = charMap[s.charCodeAt(i)];
      if (carry < 0) {
        throw new DecodingError2("Invalid Base58 character encountered", ErrorCode.E_INVALID, { char: s[i] });
      }
      for (let j = 0; j < size; ++j) {
        const x = result[j] * 58 + carry;
        result[j] = x;
        carry = x >> 8;
      }
      if (carry) {
        throw new DecodingError2("Base58 value is out of range", ErrorCode.E_INVALID);
      }
    }
    result.reverse();
    return new Bytes(result);
  }
  Base582.decode = decode2;
  function decodeCheck(encoded, size) {
    const decoded = decode2(encoded, size != null ? size + 4 : size);
    const data = decoded.array.subarray(0, -4);
    const expected = decoded.array.subarray(-4);
    const actual = dsha256Checksum(data);
    if (!arrayEquals(expected, actual)) {
      throw new DecodingError2("Checksum mismatch", ErrorCode.E_CHECKSUM, {
        actual,
        expected,
        data,
        hash: "double_sha256"
      });
    }
    return new Bytes(data);
  }
  Base582.decodeCheck = decodeCheck;
  function decodeRipemd160Check(encoded, size, suffix) {
    const decoded = decode2(encoded, size != null ? size + 4 : size);
    const data = decoded.array.subarray(0, -4);
    const expected = decoded.array.subarray(-4);
    const actual = ripemd160Checksum(data, suffix);
    if (!arrayEquals(expected, actual)) {
      throw new DecodingError2("Checksum mismatch", ErrorCode.E_CHECKSUM, {
        actual,
        expected,
        data,
        hash: "ripemd160"
      });
    }
    return new Bytes(data);
  }
  Base582.decodeRipemd160Check = decodeRipemd160Check;
  function encode2(data) {
    data = Bytes.from(data);
    const result = [];
    for (const byte of data.array) {
      let carry = byte;
      for (let j = 0; j < result.length; ++j) {
        const x = (charMap[result[j]] << 8) + carry;
        result[j] = chars.charCodeAt(x % 58);
        carry = x / 58 | 0;
      }
      while (carry) {
        result.push(chars.charCodeAt(carry % 58));
        carry = carry / 58 | 0;
      }
    }
    for (const byte of data.array) {
      if (byte) {
        break;
      } else {
        result.push("1".charCodeAt(0));
      }
    }
    result.reverse();
    return String.fromCharCode(...result);
  }
  Base582.encode = encode2;
  function encodeCheck(data) {
    data = Bytes.from(data);
    data = data.appending(dsha256Checksum(data.array));
    return encode2(data);
  }
  Base582.encodeCheck = encodeCheck;
  function encodeRipemd160Check(data, suffix) {
    data = Bytes.from(data);
    data = data.appending(ripemd160Checksum(data.array, suffix));
    return encode2(data);
  }
  Base582.encodeRipemd160Check = encodeRipemd160Check;
  function decodeVar(s) {
    const result = [];
    for (let i = 0; i < s.length; ++i) {
      let carry = charMap[s.charCodeAt(i)];
      if (carry < 0) {
        throw new DecodingError2("Invalid Base58 character encountered", ErrorCode.E_INVALID, { char: s[i] });
      }
      for (let j = 0; j < result.length; ++j) {
        const x = result[j] * 58 + carry;
        result[j] = x & 255;
        carry = x >> 8;
      }
      if (carry) {
        result.push(carry);
      }
    }
    for (const ch of s) {
      if (ch === "1") {
        result.push(0);
      } else {
        break;
      }
    }
    result.reverse();
    return Bytes.from(result);
  }
  function ripemd160Checksum(data, suffix) {
    const hash = (0, import_hash.ripemd160)().update(data);
    if (suffix) {
      hash.update(suffix);
    }
    return new Uint8Array(hash.digest().slice(0, 4));
  }
  function dsha256Checksum(data) {
    const round1 = (0, import_hash.sha256)().update(data).digest();
    const round2 = (0, import_hash.sha256)().update(round1).digest();
    return new Uint8Array(round2.slice(0, 4));
  }
})(Base58 || (Base58 = {}));
var PublicKey = class {
  /** Create PublicKey object from representing types. */
  static from(value) {
    if (isInstanceOf(value, PublicKey)) {
      return value;
    }
    if (typeof value === "object" && value.type && value.compressed) {
      return new PublicKey(KeyType.from(value.type), new Bytes(value.compressed));
    }
    if (typeof value !== "string") {
      throw new Error("Invalid public key");
    }
    if (value.startsWith("PUB_")) {
      const parts = value.split("_");
      if (parts.length !== 3) {
        throw new Error("Invalid public key string");
      }
      const type = KeyType.from(parts[1]);
      const size = type === KeyType.K1 || type === KeyType.R1 ? 33 : void 0;
      const data = Base58.decodeRipemd160Check(parts[2], size, type);
      return new PublicKey(type, data);
    } else if (value.length >= 50) {
      const data = Base58.decodeRipemd160Check(value.slice(-50));
      return new PublicKey(KeyType.K1, data);
    } else {
      throw new Error("Invalid public key string");
    }
  }
  /** @internal */
  static fromABI(decoder) {
    const type = KeyType.from(decoder.readByte());
    if (type == KeyType.WA) {
      const startPos = decoder.getPosition();
      decoder.advance(33);
      decoder.advance(1);
      decoder.advance(decoder.readVaruint32());
      const len = decoder.getPosition() - startPos;
      decoder.setPosition(startPos);
      const data = Bytes.from(decoder.readArray(len));
      return new PublicKey(KeyType.WA, data);
    }
    return new PublicKey(type, new Bytes(decoder.readArray(33)));
  }
  /** @internal */
  constructor(type, data) {
    this.type = type;
    this.data = data;
  }
  equals(other) {
    const otherKey = PublicKey.from(other);
    return this.type === otherKey.type && this.data.equals(otherKey.data);
  }
  /**
   * Return EOSIO legacy (`EOS<base58data>`) formatted key.
   * @throws If the key type isn't `K1`
   */
  toLegacyString(prefix = "EOS") {
    if (this.type !== KeyType.K1) {
      throw new Error("Unable to create legacy formatted string for non-K1 key");
    }
    return `${prefix}${Base58.encodeRipemd160Check(this.data)}`;
  }
  /** Return key in modern EOSIO format (`PUB_<type>_<base58data>`) */
  toString() {
    return `PUB_${this.type}_${Base58.encodeRipemd160Check(this.data, this.type)}`;
  }
  /** @internal */
  toABI(encoder) {
    encoder.writeByte(KeyType.indexFor(this.type));
    encoder.writeArray(this.data.array);
  }
  /** @internal */
  toJSON() {
    return this.toString();
  }
};
PublicKey.abiName = "public_key";
var curves = {};
function getCurve(type) {
  let rv = curves[type];
  if (!rv) {
    if (type === "K1") {
      rv = curves[type] = new import_elliptic.ec("secp256k1");
    } else if (type === "R1") {
      rv = curves[type] = new import_elliptic.ec("p256");
    } else {
      throw new Error(`Unknown curve type: ${type}`);
    }
  }
  return rv;
}
function recover(signature, message, type) {
  const curve = getCurve(type);
  const recid = signature[0] - 31;
  const r = signature.subarray(1, 33);
  const s = signature.subarray(33);
  const point = curve.recoverPubKey(message, { r, s }, recid);
  return new Uint8Array(point.encodeCompressed());
}
function verify(signature, message, pubkey, type) {
  const curve = getCurve(type);
  const r = signature.subarray(1, 33);
  const s = signature.subarray(33);
  return curve.verify(message, { r, s }, pubkey);
}
var Signature = class {
  /** Create Signature object from representing types. */
  static from(value) {
    if (isInstanceOf(value, Signature)) {
      return value;
    }
    if (typeof value === "object" && value.r && value.s) {
      const data = new Uint8Array(1 + 32 + 32);
      let recid = value.recid;
      const type = KeyType.from(value.type);
      if (value.type === KeyType.K1 || value.type === KeyType.R1) {
        recid += 31;
      }
      data[0] = recid;
      data.set(value.r, 1);
      data.set(value.s, 33);
      return new Signature(type, new Bytes(data));
    }
    if (typeof value !== "string") {
      throw new Error("Invalid signature");
    }
    if (value.startsWith("SIG_")) {
      const parts = value.split("_");
      if (parts.length !== 3) {
        throw new Error("Invalid signature string");
      }
      const type = KeyType.from(parts[1]);
      const size = type === KeyType.K1 || type === KeyType.R1 ? 65 : void 0;
      const data = Base58.decodeRipemd160Check(parts[2], size, type);
      return new Signature(type, data);
    } else {
      throw new Error("Invalid signature string");
    }
  }
  /** @internal */
  static fromABI(decoder) {
    const type = KeyType.from(decoder.readByte());
    if (type === KeyType.WA) {
      const startPos = decoder.getPosition();
      decoder.advance(65);
      decoder.advance(decoder.readVaruint32());
      decoder.advance(decoder.readVaruint32());
      const len = decoder.getPosition() - startPos;
      decoder.setPosition(startPos);
      const data = Bytes.from(decoder.readArray(len));
      return new Signature(KeyType.WA, data);
    }
    return new Signature(type, new Bytes(decoder.readArray(65)));
  }
  /** @internal */
  constructor(type, data) {
    this.type = type;
    this.data = data;
  }
  equals(other) {
    const otherSig = Signature.from(other);
    return this.type === otherSig.type && this.data.equals(otherSig.data);
  }
  /** Recover public key from given message digest. */
  recoverDigest(digest) {
    digest = Checksum256.from(digest);
    const compressed = recover(this.data.array, digest.array, this.type);
    return PublicKey.from({ compressed, type: this.type });
  }
  /** Recover public key from given message. */
  recoverMessage(message) {
    return this.recoverDigest(Checksum256.hash(message));
  }
  /** Verify this signature with given message digest and public key. */
  verifyDigest(digest, publicKey) {
    digest = Checksum256.from(digest);
    return verify(this.data.array, digest.array, publicKey.data.array, this.type);
  }
  /** Verify this signature with given message and public key. */
  verifyMessage(message, publicKey) {
    return this.verifyDigest(Checksum256.hash(message), publicKey);
  }
  /** Base58check encoded string representation of this signature (`SIG_<type>_<data>`). */
  toString() {
    return `SIG_${this.type}_${Base58.encodeRipemd160Check(this.data, this.type)}`;
  }
  /** @internal */
  toABI(encoder) {
    encoder.writeByte(KeyType.indexFor(this.type));
    encoder.writeArray(this.data.array);
  }
  /** @internal */
  toJSON() {
    return this.toString();
  }
};
Signature.abiName = "signature";
function getPublic(privkey, type) {
  const curve = getCurve(type);
  const key = curve.keyFromPrivate(privkey);
  const point = key.getPublic();
  return new Uint8Array(point.encodeCompressed());
}
function sharedSecret(privkey, pubkey, type) {
  const curve = getCurve(type);
  const priv = curve.keyFromPrivate(privkey);
  const pub = curve.keyFromPublic(pubkey).getPublic();
  return priv.derive(pub).toArrayLike(Uint8Array, "be");
}
function sign(secret, message, type) {
  const curve = getCurve(type);
  const key = curve.keyFromPrivate(secret);
  let sig;
  let r;
  let s;
  if (type === "K1") {
    let attempt = 1;
    do {
      sig = key.sign(message, { canonical: true, pers: [attempt++] });
      r = sig.r.toArrayLike(Uint8Array, "be", 32);
      s = sig.s.toArrayLike(Uint8Array, "be", 32);
    } while (!isCanonical(r, s));
  } else {
    sig = key.sign(message, { canonical: true });
    r = sig.r.toArrayLike(Uint8Array, "be", 32);
    s = sig.s.toArrayLike(Uint8Array, "be", 32);
  }
  return { type, r, s, recid: sig.recoveryParam || 0 };
}
function isCanonical(r, s) {
  return !(r[0] & 128) && !(r[0] === 0 && !(r[1] & 128)) && !(s[0] & 128) && !(s[0] === 0 && !(s[1] & 128));
}
function generate(type) {
  const curve = getCurve(type);
  const privkey = curve.genKeyPair().getPrivate();
  return privkey.toArrayLike(Uint8Array, "be", 32);
}
var PrivateKey = class {
  /** Create PrivateKey object from representing types. */
  static from(value) {
    if (isInstanceOf(value, PrivateKey)) {
      return value;
    } else {
      return this.fromString(value);
    }
  }
  /**
   * Create PrivateKey object from a string representation.
   * Accepts WIF (5...) and EOSIO (PVT_...) style private keys.
   */
  static fromString(string, ignoreChecksumError = false) {
    try {
      const { type, data } = decodeKey(string);
      return new this(type, data);
    } catch (error) {
      error.message = `Invalid private key (${error.message})`;
      if (ignoreChecksumError && isInstanceOf(error, Base58.DecodingError) && error.code === Base58.ErrorCode.E_CHECKSUM) {
        const type = string.startsWith("PVT_R1") ? KeyType.R1 : KeyType.K1;
        const data = new Bytes(error.info.data);
        if (data.length === 33) {
          data.dropFirst();
        }
        data.zeropad(32, true);
        return new this(type, data);
      }
      throw error;
    }
  }
  /**
   * Generate new PrivateKey.
   * @throws If a secure random source isn't available.
   */
  static generate(type) {
    return new PrivateKey(KeyType.from(type), new Bytes(generate(type)));
  }
  /** @internal */
  constructor(type, data) {
    if ((type === KeyType.K1 || type === KeyType.R1) && data.length !== 32) {
      throw new Error("Invalid private key length");
    }
    this.type = type;
    this.data = data;
  }
  /**
   * Sign message digest using this key.
   * @throws If the key type isn't R1 or K1.
   */
  signDigest(digest) {
    digest = Checksum256.from(digest);
    return Signature.from(sign(this.data.array, digest.array, this.type));
  }
  /**
   * Sign message using this key.
   * @throws If the key type isn't R1 or K1.
   */
  signMessage(message) {
    return this.signDigest(Checksum256.hash(message));
  }
  /**
   * Derive the shared secret between this private key and given public key.
   * @throws If the key type isn't R1 or K1.
   */
  sharedSecret(publicKey) {
    const shared = sharedSecret(this.data.array, publicKey.data.array, this.type);
    return Checksum512.hash(shared);
  }
  /**
   * Get the corresponding public key.
   * @throws If the key type isn't R1 or K1.
   */
  toPublic() {
    const compressed = getPublic(this.data.array, this.type);
    return PublicKey.from({ compressed, type: this.type });
  }
  /**
   * Return WIF representation of this private key
   * @throws If the key type isn't K1.
   */
  toWif() {
    if (this.type !== KeyType.K1) {
      throw new Error("Unable to generate WIF for non-k1 key");
    }
    return Base58.encodeCheck(Bytes.from([128]).appending(this.data));
  }
  /**
   * Return the key in EOSIO PVT_<type>_<base58check> format.
   */
  toString() {
    return `PVT_${this.type}_${Base58.encodeRipemd160Check(this.data, this.type)}`;
  }
  toJSON() {
    return this.toString();
  }
};
function decodeKey(value) {
  const type = typeof value;
  if (type !== "string") {
    throw new Error(`Expected string, got ${type}`);
  }
  if (value.startsWith("PVT_")) {
    const parts = value.split("_");
    if (parts.length !== 3) {
      throw new Error("Invalid PVT format");
    }
    const type2 = KeyType.from(parts[1]);
    let size;
    switch (type2) {
      case KeyType.K1:
      case KeyType.R1:
        size = 32;
        break;
    }
    const data = Base58.decodeRipemd160Check(parts[2], size, type2);
    return { type: type2, data };
  } else {
    const type2 = KeyType.K1;
    const data = Base58.decodeCheck(value);
    if (data.array[0] !== 128) {
      throw new Error("Invalid WIF");
    }
    return { type: type2, data: data.droppingFirst() };
  }
}
var PermissionLevel_1;
var PermissionLevel = PermissionLevel_1 = class PermissionLevel2 extends Struct {
  /** Create new permission level from representing types. Can be expressed as a string in the format `<actor>@<permission>`. */
  static from(value) {
    if (typeof value === "string") {
      const parts = value.split("@");
      if (parts.length !== 2 && parts[0].length > 0 && parts[1].length > 0) {
        throw new Error("Invalid permission level string, should be in the format <actor>@<permission>");
      }
      value = { actor: parts[0], permission: parts[1] };
    }
    return super.from(value);
  }
  /** Return true if this permission level equals other. */
  equals(other) {
    const otherPerm = PermissionLevel_1.from(other);
    return this.actor.equals(otherPerm.actor) && this.permission.equals(otherPerm.permission);
  }
  toString() {
    return `${this.actor}@${this.permission}`;
  }
};
__decorate([
  Struct.field("name")
], PermissionLevel.prototype, "actor", void 0);
__decorate([
  Struct.field("name")
], PermissionLevel.prototype, "permission", void 0);
PermissionLevel = PermissionLevel_1 = __decorate([
  Struct.type("permission_level")
], PermissionLevel);
var Action_1;
var Action = Action_1 = class Action2 extends Struct {
  static from(object, abi) {
    const data = object.data;
    if (!Bytes.isBytes(data)) {
      let type;
      if (abi) {
        type = ABI.from(abi).getActionType(object.name);
      } else if (!data.constructor || data.constructor.abiName === void 0) {
        throw new Error("Missing ABI definition when creating action with untyped action data");
      }
      object = {
        ...object,
        data: abiEncode({ object: data, type, abi })
      };
    }
    return super.from(object);
  }
  /** Return true if this Action is equal to given action. */
  equals(other) {
    const otherAction = Action_1.from(other);
    return this.account.equals(otherAction.account) && this.name.equals(otherAction.name) && arrayEquatableEquals(this.authorization, otherAction.authorization) && this.data.equals(otherAction.data);
  }
  decodeData(typeOrAbi) {
    if (typeof typeOrAbi === "string" || typeOrAbi.abiName) {
      return abiDecode({
        data: this.data,
        type: typeOrAbi
      });
    } else {
      const abi = ABI.from(typeOrAbi);
      const type = abi.getActionType(this.name);
      if (!type) {
        throw new Error(`Action ${this.name} does not exist in provided ABI`);
      }
      return abiDecode({ data: this.data, type, abi });
    }
  }
};
__decorate([
  Struct.field("name")
], Action.prototype, "account", void 0);
__decorate([
  Struct.field("name")
], Action.prototype, "name", void 0);
__decorate([
  Struct.field(PermissionLevel, { array: true })
], Action.prototype, "authorization", void 0);
__decorate([
  Struct.field("bytes")
], Action.prototype, "data", void 0);
Action = Action_1 = __decorate([
  Struct.type("action")
], Action);
var Transaction_1;
var TransactionExtension = class TransactionExtension2 extends Struct {
};
__decorate([
  Struct.field("uint16")
], TransactionExtension.prototype, "type", void 0);
__decorate([
  Struct.field("bytes")
], TransactionExtension.prototype, "data", void 0);
TransactionExtension = __decorate([
  Struct.type("transaction_extension")
], TransactionExtension);
var TransactionHeader = class TransactionHeader2 extends Struct {
  static from(object) {
    return super.from({
      max_net_usage_words: 0,
      max_cpu_usage_ms: 0,
      delay_sec: 0,
      ...object
    });
  }
};
__decorate([
  Struct.field("time_point_sec")
], TransactionHeader.prototype, "expiration", void 0);
__decorate([
  Struct.field("uint16")
], TransactionHeader.prototype, "ref_block_num", void 0);
__decorate([
  Struct.field("uint32")
], TransactionHeader.prototype, "ref_block_prefix", void 0);
__decorate([
  Struct.field("varuint32")
], TransactionHeader.prototype, "max_net_usage_words", void 0);
__decorate([
  Struct.field("uint8")
], TransactionHeader.prototype, "max_cpu_usage_ms", void 0);
__decorate([
  Struct.field("varuint32")
], TransactionHeader.prototype, "delay_sec", void 0);
TransactionHeader = __decorate([
  Struct.type("transaction_header")
], TransactionHeader);
var Transaction = Transaction_1 = class Transaction2 extends TransactionHeader {
  static from(object, abis) {
    const abiFor = (contract) => {
      if (!abis) {
        return;
      } else if (Array.isArray(abis)) {
        return abis.filter((abi) => Name.from(abi.contract).equals(contract)).map(({ abi }) => abi)[0];
      } else {
        return abis;
      }
    };
    const resolveAction = (action) => Action.from(action, abiFor(action.account));
    const actions = (object.actions || []).map(resolveAction);
    const context_free_actions = (object.context_free_actions || []).map(resolveAction);
    const transaction = {
      transaction_extensions: [],
      ...object,
      context_free_actions,
      actions
    };
    return super.from(transaction);
  }
  /** Return true if this transaction is equal to given transaction. */
  equals(other) {
    const tx = Transaction_1.from(other);
    return this.id.equals(tx.id);
  }
  get id() {
    return Checksum256.hash(abiEncode({ object: this }));
  }
  signingDigest(chainId) {
    const data = this.signingData(chainId);
    return Checksum256.hash(data);
  }
  signingData(chainId) {
    let data = Bytes.from(Checksum256.from(chainId).array);
    data = data.appending(abiEncode({ object: this }));
    data = data.appending(new Uint8Array(32));
    return data;
  }
};
__decorate([
  Struct.field(Action, { array: true })
], Transaction.prototype, "context_free_actions", void 0);
__decorate([
  Struct.field(Action, { array: true })
], Transaction.prototype, "actions", void 0);
__decorate([
  Struct.field(TransactionExtension, { array: true })
], Transaction.prototype, "transaction_extensions", void 0);
Transaction = Transaction_1 = __decorate([
  Struct.type("transaction")
], Transaction);
var SignedTransaction = class SignedTransaction2 extends Transaction {
  /** The transaction without the signatures. */
  get transaction() {
    return Transaction.from({
      ...this,
      signatures: void 0,
      context_free_data: void 0
    });
  }
  get id() {
    return this.transaction.id;
  }
  static from(object) {
    return super.from({
      signatures: [],
      context_free_data: [],
      ...object
    });
  }
};
__decorate([
  Struct.field("signature[]")
], SignedTransaction.prototype, "signatures", void 0);
__decorate([
  Struct.field("bytes[]")
], SignedTransaction.prototype, "context_free_data", void 0);
SignedTransaction = __decorate([
  Struct.type("signed_transaction")
], SignedTransaction);
var PackedTransaction = class PackedTransaction2 extends Struct {
  static from(object) {
    return super.from({
      signatures: [],
      packed_context_free_data: "",
      compression: 0,
      ...object
    });
  }
  static fromSigned(signed) {
    const tx = Transaction.from(signed);
    return this.from({
      signatures: signed.signatures,
      packed_context_free_data: abiEncode({
        object: signed.context_free_data,
        type: "bytes[]"
      }),
      packed_trx: abiEncode({ object: tx })
    });
  }
  getTransaction() {
    if (Number(this.compression) !== 0) {
      throw new Error("Transaction compression not supported yet");
    }
    return abiDecode({ data: this.packed_trx, type: Transaction });
  }
  getSignedTransaction() {
    const transaction = this.getTransaction();
    return SignedTransaction.from({
      ...transaction,
      signatures: this.signatures
    });
  }
};
__decorate([
  Struct.field("signature[]")
], PackedTransaction.prototype, "signatures", void 0);
__decorate([
  Struct.field("uint8")
], PackedTransaction.prototype, "compression", void 0);
__decorate([
  Struct.field("bytes")
], PackedTransaction.prototype, "packed_context_free_data", void 0);
__decorate([
  Struct.field("bytes")
], PackedTransaction.prototype, "packed_trx", void 0);
PackedTransaction = __decorate([
  Struct.type("packed_transaction")
], PackedTransaction);
var TransactionReceipt = class TransactionReceipt2 extends Struct {
};
__decorate([
  Struct.field("string")
], TransactionReceipt.prototype, "status", void 0);
__decorate([
  Struct.field("uint32")
], TransactionReceipt.prototype, "cpu_usage_us", void 0);
__decorate([
  Struct.field("uint32")
], TransactionReceipt.prototype, "net_usage_words", void 0);
TransactionReceipt = __decorate([
  Struct.type("transaction_receipt")
], TransactionReceipt);
var Authority_1;
var Weight = class Weight2 extends UInt16 {
};
Weight = __decorate([
  TypeAlias("weight_type")
], Weight);
var KeyWeight = class KeyWeight2 extends Struct {
};
__decorate([
  Struct.field(PublicKey)
], KeyWeight.prototype, "key", void 0);
__decorate([
  Struct.field(Weight)
], KeyWeight.prototype, "weight", void 0);
KeyWeight = __decorate([
  Struct.type("key_weight")
], KeyWeight);
var PermissionLevelWeight = class PermissionLevelWeight2 extends Struct {
};
__decorate([
  Struct.field(PermissionLevel)
], PermissionLevelWeight.prototype, "permission", void 0);
__decorate([
  Struct.field(Weight)
], PermissionLevelWeight.prototype, "weight", void 0);
PermissionLevelWeight = __decorate([
  Struct.type("permission_level_weight")
], PermissionLevelWeight);
var WaitWeight = class WaitWeight2 extends Struct {
};
__decorate([
  Struct.field(UInt32)
], WaitWeight.prototype, "wait_sec", void 0);
__decorate([
  Struct.field(Weight)
], WaitWeight.prototype, "weight", void 0);
WaitWeight = __decorate([
  Struct.type("wait_weight")
], WaitWeight);
var Authority = Authority_1 = class Authority2 extends Struct {
  static from(value) {
    if (isInstanceOf(value, Authority_1)) {
      return value;
    }
    const rv = super.from({
      keys: [],
      accounts: [],
      waits: [],
      ...value
    });
    rv.sort();
    return rv;
  }
  /** Total weight of all waits. */
  get waitThreshold() {
    return this.waits.reduce((val, wait) => val + wait.weight.toNumber(), 0);
  }
  /** Weight a key needs to sign for this authority. */
  get keyThreshold() {
    return this.threshold.toNumber() - this.waitThreshold;
  }
  /** Return the weight for given public key, or zero if it is not included in this authority. */
  keyWeight(publicKey) {
    const weight = this.keys.find(({ key }) => key.equals(publicKey));
    return weight ? weight.weight.toNumber() : 0;
  }
  /**
   * Check if given public key has permission in this authority,
   * @attention Does not take indirect permissions for the key via account weights into account.
   * @param publicKey The key to check.
   * @param includePartial Whether to consider auths where the key is included but can't be reached alone (e.g. multisig).
   */
  hasPermission(publicKey, includePartial = false) {
    const threshold = includePartial ? 1 : this.keyThreshold;
    const weight = this.keyWeight(publicKey);
    return weight >= threshold;
  }
  /**
   * Sorts the authority weights in place, should be called before including the authority in a `updateauth` action or it might be rejected.
   */
  sort() {
    this.keys.sort((a, b) => String(a.key).localeCompare(String(b.key)));
    this.accounts.sort((a, b) => String(a.permission).localeCompare(String(b.permission)));
    this.waits.sort((a, b) => String(a.wait_sec).localeCompare(String(b.wait_sec)));
  }
};
__decorate([
  Struct.field(UInt32)
], Authority.prototype, "threshold", void 0);
__decorate([
  Struct.field(KeyWeight, { array: true })
], Authority.prototype, "keys", void 0);
__decorate([
  Struct.field(PermissionLevelWeight, { array: true })
], Authority.prototype, "accounts", void 0);
__decorate([
  Struct.field(WaitWeight, { array: true })
], Authority.prototype, "waits", void 0);
Authority = Authority_1 = __decorate([
  Struct.type("authority")
], Authority);
var Serializer;
(function(Serializer2) {
  Serializer2.encode = abiEncode;
  Serializer2.decode = abiDecode;
  function synthesize(type) {
    return synthesizeABI(type).abi;
  }
  Serializer2.synthesize = synthesize;
  function stringify(object) {
    return JSON.stringify(object);
  }
  Serializer2.stringify = stringify;
  function objectify(object) {
    const walk = (v) => {
      switch (typeof v) {
        case "boolean":
        case "number":
        case "string":
          return v;
        case "object": {
          if (v === null) {
            return v;
          }
          if (typeof v.toJSON === "function") {
            return walk(v.toJSON());
          }
          if (Array.isArray(v)) {
            return v.map(walk);
          }
          const rv = {};
          for (const key of Object.keys(v)) {
            rv[key] = walk(v[key]);
          }
          return rv;
        }
      }
    };
    return walk(object);
  }
  Serializer2.objectify = objectify;
})(Serializer || (Serializer = {}));
var FetchProvider = class {
  constructor(url, options = {}) {
    url = url.trim();
    if (url.endsWith("/"))
      url = url.slice(0, -1);
    this.url = url;
    if (!options.fetch) {
      if (typeof window !== "undefined" && window.fetch) {
        this.fetch = window.fetch.bind(window);
      } else if (typeof global !== "undefined" && global.fetch) {
        this.fetch = global.fetch.bind(global);
      } else {
        throw new Error("Missing fetch");
      }
    } else {
      this.fetch = options.fetch;
    }
  }
  async call(path, params) {
    const url = this.url + path;
    const response = await this.fetch(url, {
      method: "POST",
      body: params !== void 0 ? JSON.stringify(params) : void 0
    });
    const text = await response.text();
    let json;
    try {
      json = JSON.parse(text);
    } catch {
    }
    const headers = {};
    for (const [key, value] of response.headers.entries()) {
      headers[key] = value;
    }
    return { headers, status: response.status, json, text };
  }
};
var AccountLinkedAction = class AccountLinkedAction2 extends Struct {
};
__decorate([
  Struct.field("name")
], AccountLinkedAction.prototype, "account", void 0);
__decorate([
  Struct.field("name")
], AccountLinkedAction.prototype, "action", void 0);
AccountLinkedAction = __decorate([
  Struct.type("account_linked_action")
], AccountLinkedAction);
var AccountPermission = class AccountPermission2 extends Struct {
};
__decorate([
  Struct.field("name")
], AccountPermission.prototype, "perm_name", void 0);
__decorate([
  Struct.field("name")
], AccountPermission.prototype, "parent", void 0);
__decorate([
  Struct.field(Authority)
], AccountPermission.prototype, "required_auth", void 0);
__decorate([
  Struct.field(AccountLinkedAction, { optional: true, array: true })
], AccountPermission.prototype, "linked_actions", void 0);
AccountPermission = __decorate([
  Struct.type("account_permission")
], AccountPermission);
var AccountResourceLimit = class AccountResourceLimit2 extends Struct {
};
__decorate([
  Struct.field("int64")
], AccountResourceLimit.prototype, "used", void 0);
__decorate([
  Struct.field("int64")
], AccountResourceLimit.prototype, "available", void 0);
__decorate([
  Struct.field("int64")
], AccountResourceLimit.prototype, "max", void 0);
AccountResourceLimit = __decorate([
  Struct.type("account_resource_limit")
], AccountResourceLimit);
var AccountTotalResources = class AccountTotalResources2 extends Struct {
};
__decorate([
  Struct.field("name")
], AccountTotalResources.prototype, "owner", void 0);
__decorate([
  Struct.field("asset")
], AccountTotalResources.prototype, "net_weight", void 0);
__decorate([
  Struct.field("asset")
], AccountTotalResources.prototype, "cpu_weight", void 0);
__decorate([
  Struct.field("uint64")
], AccountTotalResources.prototype, "ram_bytes", void 0);
AccountTotalResources = __decorate([
  Struct.type("account_total_resources")
], AccountTotalResources);
var AccountSelfDelegatedBandwidth = class AccountSelfDelegatedBandwidth2 extends Struct {
};
__decorate([
  Struct.field("name")
], AccountSelfDelegatedBandwidth.prototype, "from", void 0);
__decorate([
  Struct.field("name")
], AccountSelfDelegatedBandwidth.prototype, "to", void 0);
__decorate([
  Struct.field("asset")
], AccountSelfDelegatedBandwidth.prototype, "net_weight", void 0);
__decorate([
  Struct.field("asset")
], AccountSelfDelegatedBandwidth.prototype, "cpu_weight", void 0);
AccountSelfDelegatedBandwidth = __decorate([
  Struct.type("account_self_delegated_bandwidth")
], AccountSelfDelegatedBandwidth);
var AccountRefundRequest = class AccountRefundRequest2 extends Struct {
};
__decorate([
  Struct.field("name")
], AccountRefundRequest.prototype, "owner", void 0);
__decorate([
  Struct.field("time_point")
], AccountRefundRequest.prototype, "request_time", void 0);
__decorate([
  Struct.field("asset")
], AccountRefundRequest.prototype, "net_amount", void 0);
__decorate([
  Struct.field("asset")
], AccountRefundRequest.prototype, "cpu_amount", void 0);
AccountRefundRequest = __decorate([
  Struct.type("account_refund_request")
], AccountRefundRequest);
var AccountVoterInfo = class AccountVoterInfo2 extends Struct {
};
__decorate([
  Struct.field("name")
], AccountVoterInfo.prototype, "owner", void 0);
__decorate([
  Struct.field("name")
], AccountVoterInfo.prototype, "proxy", void 0);
__decorate([
  Struct.field("name", { array: true })
], AccountVoterInfo.prototype, "producers", void 0);
__decorate([
  Struct.field("int64", { optional: true })
], AccountVoterInfo.prototype, "staked", void 0);
__decorate([
  Struct.field("bool")
], AccountVoterInfo.prototype, "is_proxy", void 0);
__decorate([
  Struct.field("uint32", { optional: true })
], AccountVoterInfo.prototype, "flags1", void 0);
__decorate([
  Struct.field("uint32")
], AccountVoterInfo.prototype, "reserved2", void 0);
__decorate([
  Struct.field("string")
], AccountVoterInfo.prototype, "reserved3", void 0);
AccountVoterInfo = __decorate([
  Struct.type("account_voter_info")
], AccountVoterInfo);
var AccountRexInfoMaturities = class AccountRexInfoMaturities2 extends Struct {
};
__decorate([
  Struct.field("time_point", { optional: true })
], AccountRexInfoMaturities.prototype, "key", void 0);
__decorate([
  Struct.field("int64", { optional: true })
], AccountRexInfoMaturities.prototype, "value", void 0);
__decorate([
  Struct.field("time_point", { optional: true })
], AccountRexInfoMaturities.prototype, "first", void 0);
__decorate([
  Struct.field("int64", { optional: true })
], AccountRexInfoMaturities.prototype, "second", void 0);
AccountRexInfoMaturities = __decorate([
  Struct.type("account_rex_info_maturities")
], AccountRexInfoMaturities);
var AccountRexInfo = class AccountRexInfo2 extends Struct {
};
__decorate([
  Struct.field("uint32")
], AccountRexInfo.prototype, "version", void 0);
__decorate([
  Struct.field("name")
], AccountRexInfo.prototype, "owner", void 0);
__decorate([
  Struct.field("asset")
], AccountRexInfo.prototype, "vote_stake", void 0);
__decorate([
  Struct.field("asset")
], AccountRexInfo.prototype, "rex_balance", void 0);
__decorate([
  Struct.field("int64")
], AccountRexInfo.prototype, "matured_rex", void 0);
__decorate([
  Struct.field(AccountRexInfoMaturities, { array: true })
], AccountRexInfo.prototype, "rex_maturities", void 0);
AccountRexInfo = __decorate([
  Struct.type("account_rex_info")
], AccountRexInfo);
var AccountObject = class AccountObject2 extends Struct {
  getPermission(permission) {
    const name = Name.from(permission);
    const match = this.permissions.find((p) => p.perm_name.equals(name));
    if (!match) {
      throw new Error(`Unknown permission ${name} on account ${this.account_name}.`);
    }
    return match;
  }
};
__decorate([
  Struct.field("name")
], AccountObject.prototype, "account_name", void 0);
__decorate([
  Struct.field("uint32")
], AccountObject.prototype, "head_block_num", void 0);
__decorate([
  Struct.field("time_point")
], AccountObject.prototype, "head_block_time", void 0);
__decorate([
  Struct.field("bool")
], AccountObject.prototype, "privileged", void 0);
__decorate([
  Struct.field("time_point")
], AccountObject.prototype, "last_code_update", void 0);
__decorate([
  Struct.field("time_point")
], AccountObject.prototype, "created", void 0);
__decorate([
  Struct.field("asset?")
], AccountObject.prototype, "core_liquid_balance", void 0);
__decorate([
  Struct.field("int64")
], AccountObject.prototype, "ram_quota", void 0);
__decorate([
  Struct.field("int64")
], AccountObject.prototype, "net_weight", void 0);
__decorate([
  Struct.field("int64")
], AccountObject.prototype, "cpu_weight", void 0);
__decorate([
  Struct.field(AccountResourceLimit)
], AccountObject.prototype, "net_limit", void 0);
__decorate([
  Struct.field(AccountResourceLimit)
], AccountObject.prototype, "cpu_limit", void 0);
__decorate([
  Struct.field("uint64")
], AccountObject.prototype, "ram_usage", void 0);
__decorate([
  Struct.field(AccountPermission, { array: true })
], AccountObject.prototype, "permissions", void 0);
__decorate([
  Struct.field(AccountTotalResources, { optional: true })
], AccountObject.prototype, "total_resources", void 0);
__decorate([
  Struct.field(AccountSelfDelegatedBandwidth, { optional: true })
], AccountObject.prototype, "self_delegated_bandwidth", void 0);
__decorate([
  Struct.field(AccountRefundRequest, { optional: true })
], AccountObject.prototype, "refund_request", void 0);
__decorate([
  Struct.field(AccountVoterInfo, { optional: true })
], AccountObject.prototype, "voter_info", void 0);
__decorate([
  Struct.field(AccountRexInfo, { optional: true })
], AccountObject.prototype, "rex_info", void 0);
AccountObject = __decorate([
  Struct.type("account_object")
], AccountObject);
var AccountByAuthorizersRow = class AccountByAuthorizersRow2 extends Struct {
};
__decorate([
  Struct.field(Name)
], AccountByAuthorizersRow.prototype, "account_name", void 0);
__decorate([
  Struct.field(Name)
], AccountByAuthorizersRow.prototype, "permission_name", void 0);
__decorate([
  Struct.field(PublicKey)
], AccountByAuthorizersRow.prototype, "authorizing_key", void 0);
__decorate([
  Struct.field(Weight)
], AccountByAuthorizersRow.prototype, "weight", void 0);
__decorate([
  Struct.field(UInt32)
], AccountByAuthorizersRow.prototype, "threshold", void 0);
AccountByAuthorizersRow = __decorate([
  Struct.type("account_by_authorizers_row")
], AccountByAuthorizersRow);
var AccountsByAuthorizers = class AccountsByAuthorizers2 extends Struct {
};
__decorate([
  Struct.field(AccountByAuthorizersRow, { array: true })
], AccountsByAuthorizers.prototype, "accounts", void 0);
AccountsByAuthorizers = __decorate([
  Struct.type("account_by_authorizers")
], AccountsByAuthorizers);
var NewProducersEntry$1 = class NewProducersEntry extends Struct {
};
__decorate([
  Struct.field("name")
], NewProducersEntry$1.prototype, "producer_name", void 0);
__decorate([
  Struct.field("public_key")
], NewProducersEntry$1.prototype, "block_signing_key", void 0);
NewProducersEntry$1 = __decorate([
  Struct.type("new_producers_entry")
], NewProducersEntry$1);
var NewProducers$1 = class NewProducers extends Struct {
};
__decorate([
  Struct.field("uint32")
], NewProducers$1.prototype, "version", void 0);
__decorate([
  Struct.field(NewProducersEntry$1, { array: true })
], NewProducers$1.prototype, "producers", void 0);
NewProducers$1 = __decorate([
  Struct.type("new_producers")
], NewProducers$1);
var BlockExtension$1 = class BlockExtension extends Struct {
};
__decorate([
  Struct.field("uint16")
], BlockExtension$1.prototype, "type", void 0);
__decorate([
  Struct.field("bytes")
], BlockExtension$1.prototype, "data", void 0);
BlockExtension$1 = __decorate([
  Struct.type("block_extension")
], BlockExtension$1);
var HeaderExtension$1 = class HeaderExtension extends Struct {
};
__decorate([
  Struct.field("uint16")
], HeaderExtension$1.prototype, "type", void 0);
__decorate([
  Struct.field("bytes")
], HeaderExtension$1.prototype, "data", void 0);
HeaderExtension$1 = __decorate([
  Struct.type("header_extension")
], HeaderExtension$1);
var TrxVariant$1 = class TrxVariant {
  static from(data) {
    let id;
    let extra;
    if (typeof data === "string") {
      id = Checksum256.from(data);
      extra = {};
    } else {
      id = Checksum256.from(data.id);
      extra = data;
    }
    return new this(id, extra);
  }
  constructor(id, extra) {
    this.id = id;
    this.extra = extra;
  }
  get transaction() {
    if (this.extra.packed_trx) {
      return Serializer.decode({ data: this.extra.packed_trx, type: Transaction });
    }
  }
  get signatures() {
    if (this.extra.signatures) {
      return this.extra.signatures.map(Signature.from);
    }
  }
  equals(other) {
    return this.id.equals(other.id);
  }
  toJSON() {
    return this.id;
  }
};
TrxVariant$1.abiName = "trx_variant";
var GetBlockResponseTransactionReceipt = class GetBlockResponseTransactionReceipt2 extends TransactionReceipt {
  get id() {
    return this.trx.id;
  }
};
__decorate([
  Struct.field(TrxVariant$1)
], GetBlockResponseTransactionReceipt.prototype, "trx", void 0);
GetBlockResponseTransactionReceipt = __decorate([
  Struct.type("get_block_response_receipt")
], GetBlockResponseTransactionReceipt);
var GetBlockResponse = class GetBlockResponse2 extends Struct {
};
__decorate([
  Struct.field("time_point")
], GetBlockResponse.prototype, "timestamp", void 0);
__decorate([
  Struct.field("name")
], GetBlockResponse.prototype, "producer", void 0);
__decorate([
  Struct.field("uint16")
], GetBlockResponse.prototype, "confirmed", void 0);
__decorate([
  Struct.field("checksum256")
], GetBlockResponse.prototype, "previous", void 0);
__decorate([
  Struct.field("checksum256")
], GetBlockResponse.prototype, "transaction_mroot", void 0);
__decorate([
  Struct.field("checksum256")
], GetBlockResponse.prototype, "action_mroot", void 0);
__decorate([
  Struct.field("uint32")
], GetBlockResponse.prototype, "schedule_version", void 0);
__decorate([
  Struct.field(NewProducers$1, { optional: true })
], GetBlockResponse.prototype, "new_producers", void 0);
__decorate([
  Struct.field("header_extension", { optional: true })
], GetBlockResponse.prototype, "header_extensions", void 0);
__decorate([
  Struct.field("any", { optional: true })
], GetBlockResponse.prototype, "new_protocol_features", void 0);
__decorate([
  Struct.field("signature")
], GetBlockResponse.prototype, "producer_signature", void 0);
__decorate([
  Struct.field(GetBlockResponseTransactionReceipt, { array: true })
], GetBlockResponse.prototype, "transactions", void 0);
__decorate([
  Struct.field("block_extension", { optional: true })
], GetBlockResponse.prototype, "block_extensions", void 0);
__decorate([
  Struct.field("checksum256")
], GetBlockResponse.prototype, "id", void 0);
__decorate([
  Struct.field("uint32")
], GetBlockResponse.prototype, "block_num", void 0);
__decorate([
  Struct.field("uint32")
], GetBlockResponse.prototype, "ref_block_prefix", void 0);
GetBlockResponse = __decorate([
  Struct.type("get_block_response")
], GetBlockResponse);
var ActiveScheduleProducerAuthority = class ActiveScheduleProducerAuthority2 extends Struct {
};
__decorate([
  Struct.field("name")
], ActiveScheduleProducerAuthority.prototype, "producer_name", void 0);
__decorate([
  Struct.field("any")
], ActiveScheduleProducerAuthority.prototype, "authority", void 0);
ActiveScheduleProducerAuthority = __decorate([
  Struct.type("active_schedule_producer_authority")
], ActiveScheduleProducerAuthority);
var ActiveScheduleProducer = class ActiveScheduleProducer2 extends Struct {
};
__decorate([
  Struct.field("name")
], ActiveScheduleProducer.prototype, "producer_name", void 0);
__decorate([
  Struct.field(ActiveScheduleProducerAuthority)
], ActiveScheduleProducer.prototype, "authority", void 0);
ActiveScheduleProducer = __decorate([
  Struct.type("active_schedule_producer")
], ActiveScheduleProducer);
var ActiveSchedule = class ActiveSchedule2 extends Struct {
};
__decorate([
  Struct.field("uint32")
], ActiveSchedule.prototype, "version", void 0);
__decorate([
  Struct.field(ActiveScheduleProducer, { array: true })
], ActiveSchedule.prototype, "producers", void 0);
ActiveSchedule = __decorate([
  Struct.type("active_schedule")
], ActiveSchedule);
var BlockStateHeader = class BlockStateHeader2 extends Struct {
};
__decorate([
  Struct.field("time_point")
], BlockStateHeader.prototype, "timestamp", void 0);
__decorate([
  Struct.field("name")
], BlockStateHeader.prototype, "producer", void 0);
__decorate([
  Struct.field("uint16")
], BlockStateHeader.prototype, "confirmed", void 0);
__decorate([
  Struct.field("checksum256")
], BlockStateHeader.prototype, "previous", void 0);
__decorate([
  Struct.field("checksum256")
], BlockStateHeader.prototype, "transaction_mroot", void 0);
__decorate([
  Struct.field("checksum256")
], BlockStateHeader.prototype, "action_mroot", void 0);
__decorate([
  Struct.field("uint32")
], BlockStateHeader.prototype, "schedule_version", void 0);
__decorate([
  Struct.field(HeaderExtension$1, { array: true, optional: true })
], BlockStateHeader.prototype, "header_extensions", void 0);
__decorate([
  Struct.field("signature")
], BlockStateHeader.prototype, "producer_signature", void 0);
BlockStateHeader = __decorate([
  Struct.type("block_state_header")
], BlockStateHeader);
var GetBlockHeaderStateResponse = class GetBlockHeaderStateResponse2 extends Struct {
};
__decorate([
  Struct.field("uint32")
], GetBlockHeaderStateResponse.prototype, "block_num", void 0);
__decorate([
  Struct.field("uint32")
], GetBlockHeaderStateResponse.prototype, "dpos_proposed_irreversible_blocknum", void 0);
__decorate([
  Struct.field("uint32")
], GetBlockHeaderStateResponse.prototype, "dpos_irreversible_blocknum", void 0);
__decorate([
  Struct.field("checksum256")
], GetBlockHeaderStateResponse.prototype, "id", void 0);
__decorate([
  Struct.field(BlockStateHeader)
], GetBlockHeaderStateResponse.prototype, "header", void 0);
__decorate([
  Struct.field("any")
], GetBlockHeaderStateResponse.prototype, "active_schedule", void 0);
__decorate([
  Struct.field("any")
], GetBlockHeaderStateResponse.prototype, "blockroot_merkle", void 0);
__decorate([
  Struct.field("any")
], GetBlockHeaderStateResponse.prototype, "producer_to_last_produced", void 0);
__decorate([
  Struct.field("any")
], GetBlockHeaderStateResponse.prototype, "producer_to_last_implied_irb", void 0);
__decorate([
  Struct.field("any")
], GetBlockHeaderStateResponse.prototype, "valid_block_signing_authority", void 0);
__decorate([
  Struct.field("any")
], GetBlockHeaderStateResponse.prototype, "confirm_count", void 0);
__decorate([
  Struct.field("any")
], GetBlockHeaderStateResponse.prototype, "pending_schedule", void 0);
__decorate([
  Struct.field("any")
], GetBlockHeaderStateResponse.prototype, "activated_protocol_features", void 0);
__decorate([
  Struct.field("any")
], GetBlockHeaderStateResponse.prototype, "additional_signatures", void 0);
GetBlockHeaderStateResponse = __decorate([
  Struct.type("get_block_header_state_response")
], GetBlockHeaderStateResponse);
var GetInfoResponse = class GetInfoResponse2 extends Struct {
  getTransactionHeader(secondsAhead = 120) {
    const expiration = TimePointSec.fromMilliseconds(this.head_block_time.toMilliseconds() + secondsAhead * 1e3);
    const id = this.last_irreversible_block_id;
    const prefixArray = id.array.subarray(8, 12);
    const prefix = new Uint32Array(prefixArray.buffer, prefixArray.byteOffset, 1)[0];
    return TransactionHeader.from({
      expiration,
      ref_block_num: Number(this.last_irreversible_block_num) & 65535,
      ref_block_prefix: prefix
    });
  }
};
__decorate([
  Struct.field("string")
], GetInfoResponse.prototype, "server_version", void 0);
__decorate([
  Struct.field("checksum256")
], GetInfoResponse.prototype, "chain_id", void 0);
__decorate([
  Struct.field("uint32")
], GetInfoResponse.prototype, "head_block_num", void 0);
__decorate([
  Struct.field("uint32")
], GetInfoResponse.prototype, "last_irreversible_block_num", void 0);
__decorate([
  Struct.field("checksum256")
], GetInfoResponse.prototype, "last_irreversible_block_id", void 0);
__decorate([
  Struct.field("checksum256")
], GetInfoResponse.prototype, "head_block_id", void 0);
__decorate([
  Struct.field("time_point")
], GetInfoResponse.prototype, "head_block_time", void 0);
__decorate([
  Struct.field("name")
], GetInfoResponse.prototype, "head_block_producer", void 0);
__decorate([
  Struct.field("uint64")
], GetInfoResponse.prototype, "virtual_block_cpu_limit", void 0);
__decorate([
  Struct.field("uint64")
], GetInfoResponse.prototype, "virtual_block_net_limit", void 0);
__decorate([
  Struct.field("uint64")
], GetInfoResponse.prototype, "block_cpu_limit", void 0);
__decorate([
  Struct.field("uint64")
], GetInfoResponse.prototype, "block_net_limit", void 0);
__decorate([
  Struct.field("string?")
], GetInfoResponse.prototype, "server_version_string", void 0);
__decorate([
  Struct.field("uint32?")
], GetInfoResponse.prototype, "fork_db_head_block_num", void 0);
__decorate([
  Struct.field("checksum256?")
], GetInfoResponse.prototype, "fork_db_head_block_id", void 0);
GetInfoResponse = __decorate([
  Struct.type("get_info_response")
], GetInfoResponse);
var GetTableByScopeResponseRow = class GetTableByScopeResponseRow2 extends Struct {
};
__decorate([
  Struct.field("name")
], GetTableByScopeResponseRow.prototype, "code", void 0);
__decorate([
  Struct.field("name")
], GetTableByScopeResponseRow.prototype, "scope", void 0);
__decorate([
  Struct.field("name")
], GetTableByScopeResponseRow.prototype, "table", void 0);
__decorate([
  Struct.field("name")
], GetTableByScopeResponseRow.prototype, "payer", void 0);
__decorate([
  Struct.field("uint32")
], GetTableByScopeResponseRow.prototype, "count", void 0);
GetTableByScopeResponseRow = __decorate([
  Struct.type("get_table_by_scope_response_row")
], GetTableByScopeResponseRow);
var GetTableByScopeResponse = class GetTableByScopeResponse2 extends Struct {
};
__decorate([
  Struct.field(GetTableByScopeResponseRow, { array: true })
], GetTableByScopeResponse.prototype, "rows", void 0);
__decorate([
  Struct.field("string")
], GetTableByScopeResponse.prototype, "more", void 0);
GetTableByScopeResponse = __decorate([
  Struct.type("get_table_by_scope_response")
], GetTableByScopeResponse);
var OrderedActionsResult = class OrderedActionsResult2 extends Struct {
};
__decorate([
  Struct.field(UInt64)
], OrderedActionsResult.prototype, "global_action_seq", void 0);
__decorate([
  Struct.field(Int64)
], OrderedActionsResult.prototype, "account_action_seq", void 0);
__decorate([
  Struct.field(UInt32)
], OrderedActionsResult.prototype, "block_num", void 0);
__decorate([
  Struct.field(BlockTimestamp)
], OrderedActionsResult.prototype, "block_time", void 0);
__decorate([
  Struct.field("any")
], OrderedActionsResult.prototype, "action_trace", void 0);
__decorate([
  Struct.field("boolean?")
], OrderedActionsResult.prototype, "irrevirsible", void 0);
OrderedActionsResult = __decorate([
  Struct.type("ordered_action_result")
], OrderedActionsResult);
var GetActionsResponse = class GetActionsResponse2 extends Struct {
};
__decorate([
  Struct.field(OrderedActionsResult, { array: true })
], GetActionsResponse.prototype, "actions", void 0);
__decorate([
  Struct.field(Int32)
], GetActionsResponse.prototype, "last_irreversible_block", void 0);
__decorate([
  Struct.field(Int32)
], GetActionsResponse.prototype, "head_block_num", void 0);
__decorate([
  Struct.field("boolean?")
], GetActionsResponse.prototype, "time_limit_exceeded_error", void 0);
GetActionsResponse = __decorate([
  Struct.type("get_actions_response")
], GetActionsResponse);
var TransactionTrace = class TransactionTrace2 extends Struct {
};
TransactionTrace = __decorate([
  Struct.type("transaction_trace")
], TransactionTrace);
var Trx = class Trx2 extends Struct {
};
__decorate([
  Struct.field("any")
], Trx.prototype, "actions", void 0);
__decorate([
  Struct.field("any")
], Trx.prototype, "context_free_actions", void 0);
__decorate([
  Struct.field("any")
], Trx.prototype, "context_free_data", void 0);
__decorate([
  Struct.field("number")
], Trx.prototype, "delay_sec", void 0);
__decorate([
  Struct.field("string")
], Trx.prototype, "expiration", void 0);
__decorate([
  Struct.field("number")
], Trx.prototype, "max_cpu_usage_ms", void 0);
__decorate([
  Struct.field("number")
], Trx.prototype, "max_net_usage_words", void 0);
__decorate([
  Struct.field("number")
], Trx.prototype, "ref_block_num", void 0);
__decorate([
  Struct.field("number")
], Trx.prototype, "ref_block_prefix", void 0);
__decorate([
  Struct.field("string", { array: true })
], Trx.prototype, "signatures", void 0);
Trx = __decorate([
  Struct.type("trx")
], Trx);
var TransactionInfo = class TransactionInfo2 extends Struct {
};
__decorate([
  Struct.field(TransactionReceipt)
], TransactionInfo.prototype, "receipt", void 0);
__decorate([
  Struct.field("trx")
], TransactionInfo.prototype, "trx", void 0);
TransactionInfo = __decorate([
  Struct.type("transaction_info")
], TransactionInfo);
var GetTransactionResponse = class GetTransactionResponse2 extends Struct {
};
__decorate([
  Struct.field(Checksum256)
], GetTransactionResponse.prototype, "id", void 0);
__decorate([
  Struct.field(UInt32)
], GetTransactionResponse.prototype, "block_num", void 0);
__decorate([
  Struct.field(BlockTimestamp)
], GetTransactionResponse.prototype, "block_time", void 0);
__decorate([
  Struct.field(UInt32)
], GetTransactionResponse.prototype, "last_irreversible_block", void 0);
__decorate([
  Struct.field("any?")
], GetTransactionResponse.prototype, "traces", void 0);
__decorate([
  Struct.field("any")
], GetTransactionResponse.prototype, "trx", void 0);
GetTransactionResponse = __decorate([
  Struct.type("get_transaction_response")
], GetTransactionResponse);
var GetKeyAccountsResponse = class GetKeyAccountsResponse2 extends Struct {
};
__decorate([
  Struct.field("name", { array: true })
], GetKeyAccountsResponse.prototype, "account_names", void 0);
GetKeyAccountsResponse = __decorate([
  Struct.type("get_key_accounts_response")
], GetKeyAccountsResponse);
var GetControlledAccountsResponse = class GetControlledAccountsResponse2 extends Struct {
};
__decorate([
  Struct.field("name", { array: true })
], GetControlledAccountsResponse.prototype, "controlled_accounts", void 0);
GetControlledAccountsResponse = __decorate([
  Struct.type("get_controlled_accounts_response")
], GetControlledAccountsResponse);
var GetTransactionStatusResponse = class GetTransactionStatusResponse2 extends Struct {
};
__decorate([
  Struct.field("string")
], GetTransactionStatusResponse.prototype, "state", void 0);
__decorate([
  Struct.field("uint32")
], GetTransactionStatusResponse.prototype, "head_number", void 0);
__decorate([
  Struct.field("checksum256")
], GetTransactionStatusResponse.prototype, "head_id", void 0);
__decorate([
  Struct.field("time_point")
], GetTransactionStatusResponse.prototype, "head_timestamp", void 0);
__decorate([
  Struct.field("uint32")
], GetTransactionStatusResponse.prototype, "irreversible_number", void 0);
__decorate([
  Struct.field("checksum256")
], GetTransactionStatusResponse.prototype, "irreversible_id", void 0);
__decorate([
  Struct.field("time_point")
], GetTransactionStatusResponse.prototype, "irreversible_timestamp", void 0);
__decorate([
  Struct.field("checksum256")
], GetTransactionStatusResponse.prototype, "earliest_tracked_block_id", void 0);
__decorate([
  Struct.field("uint32")
], GetTransactionStatusResponse.prototype, "earliest_tracked_block_number", void 0);
GetTransactionStatusResponse = __decorate([
  Struct.type("get_transaction_status_response")
], GetTransactionStatusResponse);
var ProducerAuthority = class ProducerAuthority2 extends Struct {
};
__decorate([
  Struct.field(UInt32)
], ProducerAuthority.prototype, "threshold", void 0);
__decorate([
  Struct.field(KeyWeight, { array: true })
], ProducerAuthority.prototype, "keys", void 0);
ProducerAuthority = __decorate([
  Struct.type("producer_authority")
], ProducerAuthority);
var Producer = class Producer2 extends Struct {
  static from(data) {
    return super.from({
      ...data,
      authority: [data.authority[0], ProducerAuthority.from(data.authority[1])]
    });
  }
};
__decorate([
  Struct.field("name")
], Producer.prototype, "producer_name", void 0);
__decorate([
  Struct.field("any", { array: true })
], Producer.prototype, "authority", void 0);
Producer = __decorate([
  Struct.type("producer")
], Producer);
var ProducerSchedule = class ProducerSchedule2 extends Struct {
};
__decorate([
  Struct.field("uint32")
], ProducerSchedule.prototype, "version", void 0);
__decorate([
  Struct.field(Producer, { array: true })
], ProducerSchedule.prototype, "producers", void 0);
ProducerSchedule = __decorate([
  Struct.type("producer_schedule")
], ProducerSchedule);
var GetProducerScheduleResponse = class GetProducerScheduleResponse2 extends Struct {
};
__decorate([
  Struct.field(ProducerSchedule, { optional: true })
], GetProducerScheduleResponse.prototype, "active", void 0);
__decorate([
  Struct.field(ProducerSchedule, { optional: true })
], GetProducerScheduleResponse.prototype, "pending", void 0);
__decorate([
  Struct.field(ProducerSchedule, { optional: true })
], GetProducerScheduleResponse.prototype, "proposed", void 0);
GetProducerScheduleResponse = __decorate([
  Struct.type("get_producer_schedule_response")
], GetProducerScheduleResponse);
var ProtocolFeature = class ProtocolFeature2 extends Struct {
};
__decorate([
  Struct.field("checksum256")
], ProtocolFeature.prototype, "feature_digest", void 0);
__decorate([
  Struct.field("uint32")
], ProtocolFeature.prototype, "activation_ordinal", void 0);
__decorate([
  Struct.field("uint32")
], ProtocolFeature.prototype, "activation_block_num", void 0);
__decorate([
  Struct.field("checksum256")
], ProtocolFeature.prototype, "description_digest", void 0);
__decorate([
  Struct.field("string", { array: true })
], ProtocolFeature.prototype, "dependencies", void 0);
__decorate([
  Struct.field("string")
], ProtocolFeature.prototype, "protocol_feature_type", void 0);
__decorate([
  Struct.field("any", { array: true })
], ProtocolFeature.prototype, "specification", void 0);
ProtocolFeature = __decorate([
  Struct.type("protocol_feature")
], ProtocolFeature);
var GetProtocolFeaturesResponse = class GetProtocolFeaturesResponse2 extends Struct {
};
__decorate([
  Struct.field(ProtocolFeature, { array: true })
], GetProtocolFeaturesResponse.prototype, "activated_protocol_features", void 0);
__decorate([
  Struct.field("uint32", { optional: true })
], GetProtocolFeaturesResponse.prototype, "more", void 0);
GetProtocolFeaturesResponse = __decorate([
  Struct.type("get_protocol_features_response")
], GetProtocolFeaturesResponse);
var types$2 = Object.freeze({
  __proto__: null,
  get AccountByAuthorizersRow() {
    return AccountByAuthorizersRow;
  },
  get AccountLinkedAction() {
    return AccountLinkedAction;
  },
  get AccountObject() {
    return AccountObject;
  },
  get AccountPermission() {
    return AccountPermission;
  },
  get AccountRefundRequest() {
    return AccountRefundRequest;
  },
  get AccountResourceLimit() {
    return AccountResourceLimit;
  },
  get AccountRexInfo() {
    return AccountRexInfo;
  },
  get AccountRexInfoMaturities() {
    return AccountRexInfoMaturities;
  },
  get AccountSelfDelegatedBandwidth() {
    return AccountSelfDelegatedBandwidth;
  },
  get AccountTotalResources() {
    return AccountTotalResources;
  },
  get AccountVoterInfo() {
    return AccountVoterInfo;
  },
  get AccountsByAuthorizers() {
    return AccountsByAuthorizers;
  },
  get ActiveSchedule() {
    return ActiveSchedule;
  },
  get ActiveScheduleProducer() {
    return ActiveScheduleProducer;
  },
  get ActiveScheduleProducerAuthority() {
    return ActiveScheduleProducerAuthority;
  },
  get BlockExtension() {
    return BlockExtension$1;
  },
  get BlockStateHeader() {
    return BlockStateHeader;
  },
  get GetActionsResponse() {
    return GetActionsResponse;
  },
  get GetBlockHeaderStateResponse() {
    return GetBlockHeaderStateResponse;
  },
  get GetBlockResponse() {
    return GetBlockResponse;
  },
  get GetBlockResponseTransactionReceipt() {
    return GetBlockResponseTransactionReceipt;
  },
  get GetControlledAccountsResponse() {
    return GetControlledAccountsResponse;
  },
  get GetInfoResponse() {
    return GetInfoResponse;
  },
  get GetKeyAccountsResponse() {
    return GetKeyAccountsResponse;
  },
  get GetProducerScheduleResponse() {
    return GetProducerScheduleResponse;
  },
  get GetProtocolFeaturesResponse() {
    return GetProtocolFeaturesResponse;
  },
  get GetTableByScopeResponse() {
    return GetTableByScopeResponse;
  },
  get GetTableByScopeResponseRow() {
    return GetTableByScopeResponseRow;
  },
  get GetTransactionResponse() {
    return GetTransactionResponse;
  },
  get GetTransactionStatusResponse() {
    return GetTransactionStatusResponse;
  },
  get HeaderExtension() {
    return HeaderExtension$1;
  },
  get NewProducers() {
    return NewProducers$1;
  },
  get NewProducersEntry() {
    return NewProducersEntry$1;
  },
  get OrderedActionsResult() {
    return OrderedActionsResult;
  },
  get Producer() {
    return Producer;
  },
  get ProducerAuthority() {
    return ProducerAuthority;
  },
  get ProducerSchedule() {
    return ProducerSchedule;
  },
  get ProtocolFeature() {
    return ProtocolFeature;
  },
  get TransactionInfo() {
    return TransactionInfo;
  },
  get TransactionTrace() {
    return TransactionTrace;
  },
  get Trx() {
    return Trx;
  },
  TrxVariant: TrxVariant$1
});
var ChainAPI = class {
  constructor(client) {
    this.client = client;
  }
  async get_abi(accountName) {
    return this.client.call({
      path: "/v1/chain/get_abi",
      params: { account_name: Name.from(accountName) }
    });
  }
  async get_account(accountName) {
    return this.client.call({
      path: "/v1/chain/get_account",
      params: { account_name: Name.from(accountName) },
      responseType: AccountObject
    });
  }
  async get_accounts_by_authorizers(keys) {
    return this.client.call({
      path: "/v1/chain/get_accounts_by_authorizers",
      params: { keys },
      responseType: AccountsByAuthorizers
    });
  }
  async get_activated_protocol_features(params) {
    return this.client.call({
      path: "/v1/chain/get_activated_protocol_features",
      params,
      responseType: GetProtocolFeaturesResponse
    });
  }
  async get_block(block_num_or_id) {
    return this.client.call({
      path: "/v1/chain/get_block",
      params: { block_num_or_id },
      responseType: GetBlockResponse
    });
  }
  async get_block_header_state(block_num_or_id) {
    return this.client.call({
      path: "/v1/chain/get_block_header_state",
      params: { block_num_or_id },
      responseType: GetBlockHeaderStateResponse
    });
  }
  async get_currency_balance(contract, accountName, symbol) {
    const params = {
      account: Name.from(accountName),
      code: Name.from(contract)
    };
    if (symbol) {
      params.symbol = symbol;
    }
    return this.client.call({
      path: "/v1/chain/get_currency_balance",
      params,
      responseType: "asset[]"
    });
  }
  async get_info() {
    return this.client.call({
      path: "/v1/chain/get_info",
      responseType: GetInfoResponse
    });
  }
  async get_producer_schedule() {
    return this.client.call({
      path: "/v1/chain/get_producer_schedule",
      responseType: GetProducerScheduleResponse
    });
  }
  async compute_transaction(tx) {
    if (!isInstanceOf(tx, PackedTransaction)) {
      tx = PackedTransaction.fromSigned(SignedTransaction.from(tx));
    }
    return this.client.call({
      path: "/v1/chain/compute_transaction",
      params: {
        transaction: tx
      }
    });
  }
  async push_transaction(tx) {
    if (!isInstanceOf(tx, PackedTransaction)) {
      tx = PackedTransaction.fromSigned(SignedTransaction.from(tx));
    }
    return this.client.call({
      path: "/v1/chain/push_transaction",
      params: tx
    });
  }
  async send_transaction(tx) {
    if (!isInstanceOf(tx, PackedTransaction)) {
      tx = PackedTransaction.fromSigned(SignedTransaction.from(tx));
    }
    return this.client.call({
      path: "/v1/chain/send_transaction",
      params: tx
    });
  }
  async send_transaction2(tx, options) {
    if (!isInstanceOf(tx, PackedTransaction)) {
      tx = PackedTransaction.fromSigned(SignedTransaction.from(tx));
    }
    return this.client.call({
      path: "/v1/chain/send_transaction2",
      params: {
        return_failure_trace: true,
        retry_trx: false,
        retry_trx_num_blocks: 0,
        transaction: tx,
        ...options
      }
    });
  }
  async get_table_rows(params) {
    const type = params.type;
    let key_type = params.key_type;
    const someBound = params.lower_bound || params.upper_bound;
    if (!key_type && someBound) {
      if (isInstanceOf(someBound, UInt64)) {
        key_type = "i64";
      } else if (isInstanceOf(someBound, UInt128)) {
        key_type = "i128";
      } else if (isInstanceOf(someBound, Checksum256)) {
        key_type = "sha256";
      } else if (isInstanceOf(someBound, Checksum160)) {
        key_type = "ripemd160";
      }
    }
    if (!key_type) {
      key_type = "name";
    }
    let json = params.json;
    if (json === void 0) {
      json = type === void 0;
    }
    let upper_bound = params.upper_bound;
    if (upper_bound && typeof upper_bound !== "string") {
      upper_bound = String(upper_bound);
    }
    let lower_bound = params.lower_bound;
    if (lower_bound && typeof lower_bound !== "string") {
      lower_bound = String(lower_bound);
    }
    let scope = params.scope;
    if (typeof scope === "undefined") {
      scope = String(Name.from(params.code));
    } else if (typeof scope !== "string") {
      scope = String(scope);
    }
    let { rows, more, next_key } = await this.client.call({
      path: "/v1/chain/get_table_rows",
      params: {
        ...params,
        code: Name.from(params.code),
        table: Name.from(params.table),
        limit: params.limit !== void 0 ? UInt32.from(params.limit) : void 0,
        scope,
        key_type,
        json,
        upper_bound,
        lower_bound
      }
    });
    let ram_payers;
    if (params.show_payer) {
      ram_payers = [];
      rows = rows.map(({ data, payer }) => {
        ram_payers.push(Name.from(payer));
        return data;
      });
    }
    if (type) {
      if (json) {
        rows = rows.map((value) => {
          if (typeof value === "string" && Bytes.isBytes(value)) {
            return Serializer.decode({ data: Bytes.from(value), type });
          } else {
            return Serializer.decode({ object: value, type });
          }
        });
      } else {
        rows = rows.map((hex) => Bytes.from(hex)).map((data) => Serializer.decode({ data, type }));
      }
    }
    if (next_key && next_key.length > 0) {
      let indexType;
      switch (key_type) {
        case "i64":
          indexType = UInt64;
          break;
        case "i128":
          indexType = UInt128;
          break;
        case "name":
          indexType = Name;
          break;
        case "float64":
          indexType = Float64;
          break;
        case "float128":
          indexType = Float128;
          break;
        case "sha256":
          indexType = Checksum256;
          break;
        case "ripemd160":
          indexType = Checksum160;
          break;
        default:
          throw new Error(`Unsupported key type: ${key_type}`);
      }
      if (indexType === Name) {
        next_key = Name.from(Serializer.decode({ object: next_key, type: UInt64 }));
      } else {
        next_key = Serializer.decode({ object: next_key, type: indexType });
      }
    } else {
      next_key = void 0;
    }
    return { rows, more, next_key, ram_payers };
  }
  async get_table_by_scope(params) {
    return this.client.call({
      path: "/v1/chain/get_table_by_scope",
      params,
      responseType: GetTableByScopeResponse
    });
  }
  async get_transaction_status(id) {
    return this.client.call({
      path: "/v1/chain/get_transaction_status",
      params: {
        id: Checksum256.from(id)
      },
      responseType: GetTransactionStatusResponse
    });
  }
};
var HistoryAPI = class {
  constructor(client) {
    this.client = client;
  }
  async get_actions(accountName, pos, offset) {
    return this.client.call({
      path: "/v1/history/get_actions",
      params: {
        account_name: Name.from(accountName),
        pos: Int32.from(pos),
        offset: Int32.from(offset)
      },
      responseType: GetActionsResponse
    });
  }
  async get_transaction(id, options = {}) {
    return this.client.call({
      path: "/v1/history/get_transaction",
      params: {
        id: Checksum256.from(id),
        block_num_hint: options.blockNumHint && UInt32.from(options.blockNumHint),
        traces: options.excludeTraces === true ? false : void 0
      },
      responseType: GetTransactionResponse
    });
  }
  async get_key_accounts(publicKey) {
    return this.client.call({
      path: "/v1/history/get_key_accounts",
      params: { public_key: PublicKey.from(publicKey) },
      responseType: GetKeyAccountsResponse
    });
  }
  async get_controlled_accounts(controllingAccount) {
    return this.client.call({
      path: "/v1/history/get_controlled_accounts",
      params: { controlling_account: Name.from(controllingAccount) },
      responseType: GetControlledAccountsResponse
    });
  }
};
var APIError = class extends Error {
  static formatError(error) {
    if (error.what === "unspecified" && error.details[0].file && error.details[0].file === "http_plugin.cpp" && error.details[0].message.slice(0, 11) === "unknown key") {
      return "Account not found";
    } else if (error.what === "unspecified" && error.details && error.details.length > 0) {
      return error.details[0].message;
    } else if (error.what && error.what.length > 0) {
      return error.what;
    } else {
      return "Unknown API error";
    }
  }
  constructor(path, response) {
    let message;
    if (response.json && response.json.error) {
      message = `${APIError.formatError(response.json.error)} at ${path}`;
    } else {
      message = `HTTP ${response.status} at ${path}`;
    }
    super(message);
    this.path = path;
    this.response = response;
  }
  /** The nodeos error object. */
  get error() {
    const { json } = this.response;
    return json ? json.error : void 0;
  }
  /** The nodeos error name, e.g. `tx_net_usage_exceeded` */
  get name() {
    const { error } = this;
    return error ? error.name : "unspecified";
  }
  /** The nodeos error code, e.g. `3080002`. */
  get code() {
    const { error } = this;
    return error ? error.code : 0;
  }
  /** List of exceptions, if any. */
  get details() {
    const { error } = this;
    return error ? error.details : [];
  }
};
APIError.__className = "APIError";
var APIClient = class {
  constructor(options) {
    this.v1 = {
      chain: new ChainAPI(this),
      history: new HistoryAPI(this)
    };
    if (options.provider) {
      this.provider = options.provider;
    } else if (options.url) {
      this.provider = new FetchProvider(options.url, options);
    } else {
      throw new Error("Missing url or provider");
    }
  }
  async call(args) {
    const response = await this.provider.call(args.path, args.params);
    const { json } = response;
    if (Math.floor(response.status / 100) !== 2 || json && typeof json.error === "object") {
      throw new APIError(args.path, response);
    }
    if (args.responseType) {
      return abiDecode({ type: args.responseType, object: response.json });
    }
    return response.json || response.text;
  }
};
APIClient.__className = "APIClient";
var types$1 = Object.freeze({
  __proto__: null,
  v1: types$2
});
var BlockHeader_1;
var HandshakeMessage = class HandshakeMessage2 extends Struct {
};
__decorate([
  Struct.field("uint16")
], HandshakeMessage.prototype, "networkVersion", void 0);
__decorate([
  Struct.field("checksum256")
], HandshakeMessage.prototype, "chainId", void 0);
__decorate([
  Struct.field("checksum256")
], HandshakeMessage.prototype, "nodeId", void 0);
__decorate([
  Struct.field("public_key")
], HandshakeMessage.prototype, "key", void 0);
__decorate([
  Struct.field("int64")
], HandshakeMessage.prototype, "time", void 0);
__decorate([
  Struct.field("checksum256")
], HandshakeMessage.prototype, "token", void 0);
__decorate([
  Struct.field("signature")
], HandshakeMessage.prototype, "sig", void 0);
__decorate([
  Struct.field("string")
], HandshakeMessage.prototype, "p2pAddress", void 0);
__decorate([
  Struct.field("uint32")
], HandshakeMessage.prototype, "lastIrreversibleBlockNumber", void 0);
__decorate([
  Struct.field("checksum256")
], HandshakeMessage.prototype, "lastIrreversibleBlockId", void 0);
__decorate([
  Struct.field("uint32")
], HandshakeMessage.prototype, "headNum", void 0);
__decorate([
  Struct.field("checksum256")
], HandshakeMessage.prototype, "headId", void 0);
__decorate([
  Struct.field("string")
], HandshakeMessage.prototype, "os", void 0);
__decorate([
  Struct.field("string")
], HandshakeMessage.prototype, "agent", void 0);
__decorate([
  Struct.field("int16")
], HandshakeMessage.prototype, "generation", void 0);
HandshakeMessage = __decorate([
  Struct.type("handshake_message")
], HandshakeMessage);
var ChainSizeMessage = class ChainSizeMessage2 extends Struct {
};
__decorate([
  Struct.field("uint32")
], ChainSizeMessage.prototype, "lastIrreversibleBlockNumber", void 0);
__decorate([
  Struct.field("checksum256")
], ChainSizeMessage.prototype, "lastIrreversibleBlockId", void 0);
__decorate([
  Struct.field("uint32")
], ChainSizeMessage.prototype, "headNum", void 0);
__decorate([
  Struct.field("checksum256")
], ChainSizeMessage.prototype, "headId", void 0);
ChainSizeMessage = __decorate([
  Struct.type("chain_size_message")
], ChainSizeMessage);
var GoAwayMessage = class GoAwayMessage2 extends Struct {
};
__decorate([
  Struct.field("uint8")
], GoAwayMessage.prototype, "reason", void 0);
__decorate([
  Struct.field("checksum256")
], GoAwayMessage.prototype, "nodeId", void 0);
GoAwayMessage = __decorate([
  Struct.type("go_away_message")
], GoAwayMessage);
var TimeMessage = class TimeMessage2 extends Struct {
};
__decorate([
  Struct.field("int64")
], TimeMessage.prototype, "org", void 0);
__decorate([
  Struct.field("int64")
], TimeMessage.prototype, "rec", void 0);
__decorate([
  Struct.field("int64")
], TimeMessage.prototype, "xmt", void 0);
__decorate([
  Struct.field("int64")
], TimeMessage.prototype, "dst", void 0);
TimeMessage = __decorate([
  Struct.type("time_message")
], TimeMessage);
var NoticeMessage = class NoticeMessage2 extends Struct {
};
__decorate([
  Struct.field("checksum256", { array: true })
], NoticeMessage.prototype, "knownTrx", void 0);
__decorate([
  Struct.field("checksum256", { array: true })
], NoticeMessage.prototype, "knownBlocks", void 0);
NoticeMessage = __decorate([
  Struct.type("notice_message")
], NoticeMessage);
var RequestMessage = class RequestMessage2 extends Struct {
};
__decorate([
  Struct.field("checksum256", { array: true })
], RequestMessage.prototype, "reqTrx", void 0);
__decorate([
  Struct.field("checksum256", { array: true })
], RequestMessage.prototype, "reqBlocks", void 0);
RequestMessage = __decorate([
  Struct.type("request_message")
], RequestMessage);
var SyncRequestMessage = class SyncRequestMessage2 extends Struct {
};
__decorate([
  Struct.field("uint32")
], SyncRequestMessage.prototype, "startBlock", void 0);
__decorate([
  Struct.field("uint32")
], SyncRequestMessage.prototype, "endBlock", void 0);
SyncRequestMessage = __decorate([
  Struct.type("sync_request_message")
], SyncRequestMessage);
var NewProducersEntry2 = class NewProducersEntry3 extends Struct {
};
__decorate([
  Struct.field("name")
], NewProducersEntry2.prototype, "producer_name", void 0);
__decorate([
  Struct.field("public_key")
], NewProducersEntry2.prototype, "block_signing_key", void 0);
NewProducersEntry2 = __decorate([
  Struct.type("new_producers_entry")
], NewProducersEntry2);
var NewProducers2 = class NewProducers3 extends Struct {
};
__decorate([
  Struct.field("uint32")
], NewProducers2.prototype, "version", void 0);
__decorate([
  Struct.field(NewProducersEntry2, { array: true })
], NewProducers2.prototype, "producers", void 0);
NewProducers2 = __decorate([
  Struct.type("new_producers")
], NewProducers2);
var BlockExtension2 = class BlockExtension3 extends Struct {
};
__decorate([
  Struct.field("uint16")
], BlockExtension2.prototype, "type", void 0);
__decorate([
  Struct.field("bytes")
], BlockExtension2.prototype, "data", void 0);
BlockExtension2 = __decorate([
  Struct.type("block_extension")
], BlockExtension2);
var HeaderExtension2 = class HeaderExtension3 extends Struct {
};
__decorate([
  Struct.field("uint16")
], HeaderExtension2.prototype, "type", void 0);
__decorate([
  Struct.field("bytes")
], HeaderExtension2.prototype, "data", void 0);
HeaderExtension2 = __decorate([
  Struct.type("header_extension")
], HeaderExtension2);
var TrxVariant2 = class TrxVariant3 extends Variant {
};
TrxVariant2 = __decorate([
  Variant.type("trx_variant", [Checksum256, PackedTransaction])
], TrxVariant2);
var FullTransactionReceipt = class FullTransactionReceipt2 extends Struct {
};
__decorate([
  Struct.field(UInt8)
], FullTransactionReceipt.prototype, "status", void 0);
__decorate([
  Struct.field(UInt32)
], FullTransactionReceipt.prototype, "cpu_usage_us", void 0);
__decorate([
  Struct.field(VarUInt)
], FullTransactionReceipt.prototype, "net_usage_words", void 0);
__decorate([
  Struct.field(TrxVariant2)
], FullTransactionReceipt.prototype, "trx", void 0);
FullTransactionReceipt = __decorate([
  Struct.type("full_transaction_receipt")
], FullTransactionReceipt);
var BlockHeader = BlockHeader_1 = class BlockHeader2 extends Struct {
  get blockNum() {
    const bytes = this.previous.array.slice(0, 4);
    let num = 0;
    for (let i = 0; i < 4; i++) {
      num = (num << 8) + bytes[i];
    }
    return num + 1;
  }
  get id() {
    const id = Checksum256.hash(Serializer.encode({ object: this, type: BlockHeader_1 }));
    const numBuffer = new Uint8Array(4);
    numBuffer[0] = this.blockNum >> 24 & 255;
    numBuffer[1] = this.blockNum >> 16 & 255;
    numBuffer[2] = this.blockNum >> 8 & 255;
    numBuffer[3] = this.blockNum & 255;
    id.array.set(numBuffer, 0);
    return id;
  }
};
__decorate([
  Struct.field("uint32")
], BlockHeader.prototype, "timeSlot", void 0);
__decorate([
  Struct.field("name")
], BlockHeader.prototype, "producer", void 0);
__decorate([
  Struct.field("uint16")
], BlockHeader.prototype, "confirmed", void 0);
__decorate([
  Struct.field("checksum256")
], BlockHeader.prototype, "previous", void 0);
__decorate([
  Struct.field("checksum256")
], BlockHeader.prototype, "transaction_mroot", void 0);
__decorate([
  Struct.field("checksum256")
], BlockHeader.prototype, "action_mroot", void 0);
__decorate([
  Struct.field("uint32")
], BlockHeader.prototype, "schedule_version", void 0);
__decorate([
  Struct.field(NewProducers2, { optional: true })
], BlockHeader.prototype, "new_producers", void 0);
__decorate([
  Struct.field(HeaderExtension2, { array: true })
], BlockHeader.prototype, "header_extensions", void 0);
BlockHeader = BlockHeader_1 = __decorate([
  Struct.type("block_header")
], BlockHeader);
var SignedBlock = class SignedBlock2 extends BlockHeader {
};
__decorate([
  Struct.field("signature")
], SignedBlock.prototype, "producer_signature", void 0);
__decorate([
  Struct.field(FullTransactionReceipt, { array: true })
], SignedBlock.prototype, "transactions", void 0);
__decorate([
  Struct.field(BlockExtension2, { array: true })
], SignedBlock.prototype, "block_extensions", void 0);
SignedBlock = __decorate([
  Struct.type("signed_block")
], SignedBlock);
var NetMessage = class NetMessage2 extends Variant {
};
NetMessage = __decorate([
  Variant.type("net_message", [
    HandshakeMessage,
    ChainSizeMessage,
    GoAwayMessage,
    TimeMessage,
    NoticeMessage,
    RequestMessage,
    SyncRequestMessage,
    SignedBlock,
    PackedTransaction
  ])
], NetMessage);
var types = Object.freeze({
  __proto__: null,
  get BlockExtension() {
    return BlockExtension2;
  },
  get BlockHeader() {
    return BlockHeader;
  },
  get ChainSizeMessage() {
    return ChainSizeMessage;
  },
  get FullTransactionReceipt() {
    return FullTransactionReceipt;
  },
  get GoAwayMessage() {
    return GoAwayMessage;
  },
  get HandshakeMessage() {
    return HandshakeMessage;
  },
  get HeaderExtension() {
    return HeaderExtension2;
  },
  get NetMessage() {
    return NetMessage;
  },
  get NewProducers() {
    return NewProducers2;
  },
  get NewProducersEntry() {
    return NewProducersEntry2;
  },
  get NoticeMessage() {
    return NoticeMessage;
  },
  get RequestMessage() {
    return RequestMessage;
  },
  get SignedBlock() {
    return SignedBlock;
  },
  get SyncRequestMessage() {
    return SyncRequestMessage;
  },
  get TimeMessage() {
    return TimeMessage;
  }
});
var P2PClient = class {
  constructor(options) {
    if (options.provider) {
      this.provider = options.provider;
    } else {
      throw new Error("Missing provider");
    }
    if (options.setTimeoutImpl !== void 0) {
      this.setTimeoutImpl = options.setTimeoutImpl;
    } else {
      this.setTimeoutImpl = setTimeout;
    }
    if (options.heartbeatTimoutMs !== void 0) {
      this.heartbeatTimoutMs = options.heartbeatTimoutMs;
      this.resetHeartbeat();
    }
    this.provider.on("data", (data) => {
      this.handleData(data);
    });
    this.provider.on("error", (e) => {
      this.emit("error", [e]);
    });
    this.provider.on("close", () => {
      this.emit("close", []);
    });
    this.eventListeners = {};
  }
  send(message, done) {
    const wrappedMessage = NetMessage.from(message);
    const messageBuffer = Serializer.encode({ object: wrappedMessage });
    this.provider.write(messageBuffer.array, done);
  }
  end(cb) {
    this.endHeartbeat();
    this.provider.end(cb);
  }
  destroy(err2) {
    this.endHeartbeat();
    this.provider.destroy(err2);
  }
  handleData(data) {
    try {
      const message = Serializer.decode({ type: NetMessage, data });
      this.emit("message", [message]);
    } catch (e) {
      this.emit("error", [e]);
    }
  }
  endHeartbeat() {
    if (this.heartbeatTimoutId !== void 0) {
      clearTimeout(this.heartbeatTimoutId);
      this.heartbeatTimoutId = void 0;
    }
  }
  resetHeartbeat() {
    this.endHeartbeat();
    if (this.heartbeatTimoutMs !== void 0) {
      this.setTimeoutImpl(() => {
        this.handleHeartbeat();
      }, this.heartbeatTimoutMs);
    }
  }
  handleHeartbeat() {
    const now = Date.now();
    const timeMessage = TimeMessage.from({
      org: now,
      rec: 0,
      xmt: 0,
      dst: 0
    });
    this.send(timeMessage, () => {
      this.resetHeartbeat();
    });
  }
  on(event, handler) {
    return this.addListenerInternal(event, handler, false, false);
  }
  once(event, handler) {
    return this.addListenerInternal(event, handler, true, false);
  }
  addListener(event, handler) {
    return this.addListenerInternal(event, handler, false, false);
  }
  prependListener(event, handler) {
    return this.addListenerInternal(event, handler, false, true);
  }
  removeListener(event, handler) {
    if (this.eventListeners[event] !== void 0) {
      this.eventListeners[event] = this.eventListeners[event].filter((e) => {
        return e.handler !== handler;
      });
    }
    return this;
  }
  addListenerInternal(event, handler, once, prepend) {
    if (this.eventListeners[event] === void 0) {
      this.eventListeners[event] = [];
    }
    if (!prepend) {
      this.eventListeners[event].push({ once, handler });
    } else {
      this.eventListeners[event].unshift({ once, handler });
    }
    return this;
  }
  emit(event, args) {
    if (this.eventListeners[event] === void 0) {
      return;
    }
    for (const { handler } of this.eventListeners[event]) {
      const erasedHandler = handler;
      erasedHandler(...args);
    }
    this.eventListeners[event] = this.eventListeners[event].filter((e) => {
      return e.once !== true;
    });
  }
};
P2PClient.__className = "P2PClient";
var SimpleEnvelopeP2PProvider = class {
  constructor(nextProvider) {
    this.nextProvider = nextProvider;
    this.remainingData = new Uint8Array(0);
    this.dataHandlers = [];
    this.errorHandlers = [];
    this.nextProvider.on("data", (data) => {
      const newData = new Uint8Array(this.remainingData.byteLength + data.byteLength);
      newData.set(this.remainingData, 0);
      newData.set(data, this.remainingData.byteLength);
      this.remainingData = newData;
      while (this.remainingData.byteLength >= 4) {
        const view = new DataView(this.remainingData.buffer);
        const messageLength = view.getUint32(0, true);
        if (messageLength > SimpleEnvelopeP2PProvider.maxReadLength) {
          this.emitError(new Error("Incoming Message too long"));
        }
        if (this.remainingData.byteLength < 4 + messageLength) {
          break;
        }
        const messageBuffer = this.remainingData.subarray(4, 4 + messageLength);
        this.remainingData = this.remainingData.slice(4 + messageLength);
        this.emitData(messageBuffer);
      }
    });
    this.nextProvider.on("error", (err2) => {
      this.emitError(err2);
    });
  }
  write(data, done) {
    const nextBuffer = new Uint8Array(4 + data.byteLength);
    const view = new DataView(nextBuffer.buffer);
    view.setUint32(0, data.byteLength, true);
    nextBuffer.set(data, 4);
    this.nextProvider.write(nextBuffer, done);
  }
  end(cb) {
    this.nextProvider.end(cb);
  }
  destroy(err2) {
    this.nextProvider.destroy(err2);
  }
  on(event, handler) {
    if (event === "data") {
      this.dataHandlers.push(handler);
    } else if (event === "error") {
      this.errorHandlers.push(handler);
    } else {
      this.nextProvider.on(event, handler);
    }
    return this;
  }
  emitData(messageBuffer) {
    for (const handler of this.dataHandlers) {
      handler(messageBuffer);
    }
  }
  emitError(err2) {
    for (const handler of this.errorHandlers) {
      handler(err2);
    }
  }
};
SimpleEnvelopeP2PProvider.maxReadLength = 8 * 1024 * 1024;

// node_modules/pako/dist/pako.esm.mjs
var Z_FIXED$1 = 4;
var Z_BINARY = 0;
var Z_TEXT = 1;
var Z_UNKNOWN$1 = 2;
function zero$1(buf) {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
}
var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES = 2;
var MIN_MATCH$1 = 3;
var MAX_MATCH$1 = 258;
var LENGTH_CODES$1 = 29;
var LITERALS$1 = 256;
var L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
var D_CODES$1 = 30;
var BL_CODES$1 = 19;
var HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
var MAX_BITS$1 = 15;
var Buf_size = 16;
var MAX_BL_BITS = 7;
var END_BLOCK = 256;
var REP_3_6 = 16;
var REPZ_3_10 = 17;
var REPZ_11_138 = 18;
var extra_lbits = (
  /* extra bits for each length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
);
var extra_dbits = (
  /* extra bits for each distance code */
  new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
);
var extra_blbits = (
  /* extra bits for each bit length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
);
var bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var DIST_CODE_LEN = 512;
var static_ltree = new Array((L_CODES$1 + 2) * 2);
zero$1(static_ltree);
var static_dtree = new Array(D_CODES$1 * 2);
zero$1(static_dtree);
var _dist_code = new Array(DIST_CODE_LEN);
zero$1(_dist_code);
var _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
zero$1(_length_code);
var base_length = new Array(LENGTH_CODES$1);
zero$1(base_length);
var base_dist = new Array(D_CODES$1);
zero$1(base_dist);
function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
  this.static_tree = static_tree;
  this.extra_bits = extra_bits;
  this.extra_base = extra_base;
  this.elems = elems;
  this.max_length = max_length;
  this.has_stree = static_tree && static_tree.length;
}
var static_l_desc;
var static_d_desc;
var static_bl_desc;
function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;
  this.max_code = 0;
  this.stat_desc = stat_desc;
}
var d_code = (dist) => {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
};
var put_short = (s, w) => {
  s.pending_buf[s.pending++] = w & 255;
  s.pending_buf[s.pending++] = w >>> 8 & 255;
};
var send_bits = (s, value, length) => {
  if (s.bi_valid > Buf_size - length) {
    s.bi_buf |= value << s.bi_valid & 65535;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> Buf_size - s.bi_valid;
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= value << s.bi_valid & 65535;
    s.bi_valid += length;
  }
};
var send_code = (s, c, tree) => {
  send_bits(
    s,
    tree[c * 2],
    tree[c * 2 + 1]
    /*.Len*/
  );
};
var bi_reverse = (code, len) => {
  let res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
};
var bi_flush = (s) => {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;
  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 255;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
};
var gen_bitlen = (s, desc) => {
  const tree = desc.dyn_tree;
  const max_code = desc.max_code;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const extra = desc.stat_desc.extra_bits;
  const base = desc.stat_desc.extra_base;
  const max_length = desc.stat_desc.max_length;
  let h;
  let n, m;
  let bits;
  let xbits;
  let f;
  let overflow = 0;
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    s.bl_count[bits] = 0;
  }
  tree[s.heap[s.heap_max] * 2 + 1] = 0;
  for (h = s.heap_max + 1; h < HEAP_SIZE$1; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1] = bits;
    if (n > max_code) {
      continue;
    }
    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2];
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1] + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) {
      bits--;
    }
    s.bl_count[bits]--;
    s.bl_count[bits + 1] += 2;
    s.bl_count[max_length]--;
    overflow -= 2;
  } while (overflow > 0);
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) {
        continue;
      }
      if (tree[m * 2 + 1] !== bits) {
        s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
        tree[m * 2 + 1] = bits;
      }
      n--;
    }
  }
};
var gen_codes = (tree, max_code, bl_count) => {
  const next_code = new Array(MAX_BITS$1 + 1);
  let code = 0;
  let bits;
  let n;
  for (bits = 1; bits <= MAX_BITS$1; bits++) {
    code = code + bl_count[bits - 1] << 1;
    next_code[bits] = code;
  }
  for (n = 0; n <= max_code; n++) {
    let len = tree[n * 2 + 1];
    if (len === 0) {
      continue;
    }
    tree[n * 2] = bi_reverse(next_code[len]++, len);
  }
};
var tr_static_init = () => {
  let n;
  let bits;
  let length;
  let code;
  let dist;
  const bl_count = new Array(MAX_BITS$1 + 1);
  length = 0;
  for (code = 0; code < LENGTH_CODES$1 - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < 1 << extra_lbits[code]; n++) {
      _length_code[length++] = code;
    }
  }
  _length_code[length - 1] = code;
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < 1 << extra_dbits[code]; n++) {
      _dist_code[dist++] = code;
    }
  }
  dist >>= 7;
  for (; code < D_CODES$1; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    bl_count[bits] = 0;
  }
  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1] = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1] = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1] = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1] = 8;
    n++;
    bl_count[8]++;
  }
  gen_codes(static_ltree, L_CODES$1 + 1, bl_count);
  for (n = 0; n < D_CODES$1; n++) {
    static_dtree[n * 2 + 1] = 5;
    static_dtree[n * 2] = bi_reverse(n, 5);
  }
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);
};
var init_block = (s) => {
  let n;
  for (n = 0; n < L_CODES$1; n++) {
    s.dyn_ltree[n * 2] = 0;
  }
  for (n = 0; n < D_CODES$1; n++) {
    s.dyn_dtree[n * 2] = 0;
  }
  for (n = 0; n < BL_CODES$1; n++) {
    s.bl_tree[n * 2] = 0;
  }
  s.dyn_ltree[END_BLOCK * 2] = 1;
  s.opt_len = s.static_len = 0;
  s.sym_next = s.matches = 0;
};
var bi_windup = (s) => {
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
};
var smaller = (tree, n, m, depth) => {
  const _n2 = n * 2;
  const _m2 = m * 2;
  return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
};
var pqdownheap = (s, tree, k) => {
  const v = s.heap[k];
  let j = k << 1;
  while (j <= s.heap_len) {
    if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    if (smaller(tree, v, s.heap[j], s.depth)) {
      break;
    }
    s.heap[k] = s.heap[j];
    k = j;
    j <<= 1;
  }
  s.heap[k] = v;
};
var compress_block = (s, ltree, dtree) => {
  let dist;
  let lc;
  let sx = 0;
  let code;
  let extra;
  if (s.sym_next !== 0) {
    do {
      dist = s.pending_buf[s.sym_buf + sx++] & 255;
      dist += (s.pending_buf[s.sym_buf + sx++] & 255) << 8;
      lc = s.pending_buf[s.sym_buf + sx++];
      if (dist === 0) {
        send_code(s, lc, ltree);
      } else {
        code = _length_code[lc];
        send_code(s, code + LITERALS$1 + 1, ltree);
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);
        }
        dist--;
        code = d_code(dist);
        send_code(s, code, dtree);
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);
        }
      }
    } while (sx < s.sym_next);
  }
  send_code(s, END_BLOCK, ltree);
};
var build_tree = (s, desc) => {
  const tree = desc.dyn_tree;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const elems = desc.stat_desc.elems;
  let n, m;
  let max_code = -1;
  let node;
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE$1;
  for (n = 0; n < elems; n++) {
    if (tree[n * 2] !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;
    } else {
      tree[n * 2 + 1] = 0;
    }
  }
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
    tree[node * 2] = 1;
    s.depth[node] = 0;
    s.opt_len--;
    if (has_stree) {
      s.static_len -= stree[node * 2 + 1];
    }
  }
  desc.max_code = max_code;
  for (n = s.heap_len >> 1; n >= 1; n--) {
    pqdownheap(s, tree, n);
  }
  node = elems;
  do {
    n = s.heap[
      1
      /*SMALLEST*/
    ];
    s.heap[
      1
      /*SMALLEST*/
    ] = s.heap[s.heap_len--];
    pqdownheap(
      s,
      tree,
      1
      /*SMALLEST*/
    );
    m = s.heap[
      1
      /*SMALLEST*/
    ];
    s.heap[--s.heap_max] = n;
    s.heap[--s.heap_max] = m;
    tree[node * 2] = tree[n * 2] + tree[m * 2];
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1] = tree[m * 2 + 1] = node;
    s.heap[
      1
      /*SMALLEST*/
    ] = node++;
    pqdownheap(
      s,
      tree,
      1
      /*SMALLEST*/
    );
  } while (s.heap_len >= 2);
  s.heap[--s.heap_max] = s.heap[
    1
    /*SMALLEST*/
  ];
  gen_bitlen(s, desc);
  gen_codes(tree, max_code, s.bl_count);
};
var scan_tree = (s, tree, max_code) => {
  let n;
  let prevlen = -1;
  let curlen;
  let nextlen = tree[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1] = 65535;
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      s.bl_tree[curlen * 2] += count;
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        s.bl_tree[curlen * 2]++;
      }
      s.bl_tree[REP_3_6 * 2]++;
    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]++;
    } else {
      s.bl_tree[REPZ_11_138 * 2]++;
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
var send_tree = (s, tree, max_code) => {
  let n;
  let prevlen = -1;
  let curlen;
  let nextlen = tree[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      do {
        send_code(s, curlen, s.bl_tree);
      } while (--count !== 0);
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);
    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);
    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
var build_bl_tree = (s) => {
  let max_blindex;
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
  build_tree(s, s.bl_desc);
  for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
      break;
    }
  }
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  return max_blindex;
};
var send_all_trees = (s, lcodes, dcodes, blcodes) => {
  let rank2;
  send_bits(s, lcodes - 257, 5);
  send_bits(s, dcodes - 1, 5);
  send_bits(s, blcodes - 4, 4);
  for (rank2 = 0; rank2 < blcodes; rank2++) {
    send_bits(s, s.bl_tree[bl_order[rank2] * 2 + 1], 3);
  }
  send_tree(s, s.dyn_ltree, lcodes - 1);
  send_tree(s, s.dyn_dtree, dcodes - 1);
};
var detect_data_type = (s) => {
  let block_mask = 4093624447;
  let n;
  for (n = 0; n <= 31; n++, block_mask >>>= 1) {
    if (block_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
      return Z_BINARY;
    }
  }
  if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS$1; n++) {
    if (s.dyn_ltree[n * 2] !== 0) {
      return Z_TEXT;
    }
  }
  return Z_BINARY;
};
var static_init_done = false;
var _tr_init$1 = (s) => {
  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }
  s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
  s.bi_buf = 0;
  s.bi_valid = 0;
  init_block(s);
};
var _tr_stored_block$1 = (s, buf, stored_len, last) => {
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
  bi_windup(s);
  put_short(s, stored_len);
  put_short(s, ~stored_len);
  if (stored_len) {
    s.pending_buf.set(s.window.subarray(buf, buf + stored_len), s.pending);
  }
  s.pending += stored_len;
};
var _tr_align$1 = (s) => {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
};
var _tr_flush_block$1 = (s, buf, stored_len, last) => {
  let opt_lenb, static_lenb;
  let max_blindex = 0;
  if (s.level > 0) {
    if (s.strm.data_type === Z_UNKNOWN$1) {
      s.strm.data_type = detect_data_type(s);
    }
    build_tree(s, s.l_desc);
    build_tree(s, s.d_desc);
    max_blindex = build_bl_tree(s);
    opt_lenb = s.opt_len + 3 + 7 >>> 3;
    static_lenb = s.static_len + 3 + 7 >>> 3;
    if (static_lenb <= opt_lenb) {
      opt_lenb = static_lenb;
    }
  } else {
    opt_lenb = static_lenb = stored_len + 5;
  }
  if (stored_len + 4 <= opt_lenb && buf !== -1) {
    _tr_stored_block$1(s, buf, stored_len, last);
  } else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {
    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);
  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  init_block(s);
  if (last) {
    bi_windup(s);
  }
};
var _tr_tally$1 = (s, dist, lc) => {
  s.pending_buf[s.sym_buf + s.sym_next++] = dist;
  s.pending_buf[s.sym_buf + s.sym_next++] = dist >> 8;
  s.pending_buf[s.sym_buf + s.sym_next++] = lc;
  if (dist === 0) {
    s.dyn_ltree[lc * 2]++;
  } else {
    s.matches++;
    dist--;
    s.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]++;
    s.dyn_dtree[d_code(dist) * 2]++;
  }
  return s.sym_next === s.sym_end;
};
var _tr_init_1 = _tr_init$1;
var _tr_stored_block_1 = _tr_stored_block$1;
var _tr_flush_block_1 = _tr_flush_block$1;
var _tr_tally_1 = _tr_tally$1;
var _tr_align_1 = _tr_align$1;
var trees = {
  _tr_init: _tr_init_1,
  _tr_stored_block: _tr_stored_block_1,
  _tr_flush_block: _tr_flush_block_1,
  _tr_tally: _tr_tally_1,
  _tr_align: _tr_align_1
};
var adler32 = (adler, buf, len, pos) => {
  let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
  while (len !== 0) {
    n = len > 2e3 ? 2e3 : len;
    len -= n;
    do {
      s1 = s1 + buf[pos++] | 0;
      s2 = s2 + s1 | 0;
    } while (--n);
    s1 %= 65521;
    s2 %= 65521;
  }
  return s1 | s2 << 16 | 0;
};
var adler32_1 = adler32;
var makeTable = () => {
  let c, table = [];
  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
    }
    table[n] = c;
  }
  return table;
};
var crcTable = new Uint32Array(makeTable());
var crc32 = (crc, buf, len, pos) => {
  const t = crcTable;
  const end = pos + len;
  crc ^= -1;
  for (let i = pos; i < end; i++) {
    crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
  }
  return crc ^ -1;
};
var crc32_1 = crc32;
var messages = {
  2: "need dictionary",
  /* Z_NEED_DICT       2  */
  1: "stream end",
  /* Z_STREAM_END      1  */
  0: "",
  /* Z_OK              0  */
  "-1": "file error",
  /* Z_ERRNO         (-1) */
  "-2": "stream error",
  /* Z_STREAM_ERROR  (-2) */
  "-3": "data error",
  /* Z_DATA_ERROR    (-3) */
  "-4": "insufficient memory",
  /* Z_MEM_ERROR     (-4) */
  "-5": "buffer error",
  /* Z_BUF_ERROR     (-5) */
  "-6": "incompatible version"
  /* Z_VERSION_ERROR (-6) */
};
var constants$2 = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  //Z_VERSION_ERROR: -6,
  /* compression levels */
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY: 0,
  Z_TEXT: 1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,
  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};
var { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees;
var {
  Z_NO_FLUSH: Z_NO_FLUSH$2,
  Z_PARTIAL_FLUSH,
  Z_FULL_FLUSH: Z_FULL_FLUSH$1,
  Z_FINISH: Z_FINISH$3,
  Z_BLOCK: Z_BLOCK$1,
  Z_OK: Z_OK$3,
  Z_STREAM_END: Z_STREAM_END$3,
  Z_STREAM_ERROR: Z_STREAM_ERROR$2,
  Z_DATA_ERROR: Z_DATA_ERROR$2,
  Z_BUF_ERROR: Z_BUF_ERROR$1,
  Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,
  Z_FILTERED,
  Z_HUFFMAN_ONLY,
  Z_RLE,
  Z_FIXED,
  Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,
  Z_UNKNOWN,
  Z_DEFLATED: Z_DEFLATED$2
} = constants$2;
var MAX_MEM_LEVEL = 9;
var MAX_WBITS$1 = 15;
var DEF_MEM_LEVEL = 8;
var LENGTH_CODES = 29;
var LITERALS = 256;
var L_CODES = LITERALS + 1 + LENGTH_CODES;
var D_CODES = 30;
var BL_CODES = 19;
var HEAP_SIZE = 2 * L_CODES + 1;
var MAX_BITS = 15;
var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
var PRESET_DICT = 32;
var INIT_STATE = 42;
var GZIP_STATE = 57;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;
var BS_NEED_MORE = 1;
var BS_BLOCK_DONE = 2;
var BS_FINISH_STARTED = 3;
var BS_FINISH_DONE = 4;
var OS_CODE = 3;
var err = (strm, errorCode) => {
  strm.msg = messages[errorCode];
  return errorCode;
};
var rank = (f) => {
  return f * 2 - (f > 4 ? 9 : 0);
};
var zero = (buf) => {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
};
var slide_hash = (s) => {
  let n, m;
  let p;
  let wsize = s.w_size;
  n = s.hash_size;
  p = n;
  do {
    m = s.head[--p];
    s.head[p] = m >= wsize ? m - wsize : 0;
  } while (--n);
  n = wsize;
  p = n;
  do {
    m = s.prev[--p];
    s.prev[p] = m >= wsize ? m - wsize : 0;
  } while (--n);
};
var HASH_ZLIB = (s, prev, data) => (prev << s.hash_shift ^ data) & s.hash_mask;
var HASH = HASH_ZLIB;
var flush_pending = (strm) => {
  const s = strm.state;
  let len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) {
    return;
  }
  strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
};
var flush_block_only = (s, last) => {
  _tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
};
var put_byte = (s, b) => {
  s.pending_buf[s.pending++] = b;
};
var putShortMSB = (s, b) => {
  s.pending_buf[s.pending++] = b >>> 8 & 255;
  s.pending_buf[s.pending++] = b & 255;
};
var read_buf = (strm, buf, start, size) => {
  let len = strm.avail_in;
  if (len > size) {
    len = size;
  }
  if (len === 0) {
    return 0;
  }
  strm.avail_in -= len;
  buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32_1(strm.adler, buf, len, start);
  } else if (strm.state.wrap === 2) {
    strm.adler = crc32_1(strm.adler, buf, len, start);
  }
  strm.next_in += len;
  strm.total_in += len;
  return len;
};
var longest_match = (s, cur_match) => {
  let chain_length = s.max_chain_length;
  let scan = s.strstart;
  let match;
  let len;
  let best_len = s.prev_length;
  let nice_match = s.nice_match;
  const limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
  const _win = s.window;
  const wmask = s.w_mask;
  const prev = s.prev;
  const strend = s.strstart + MAX_MATCH;
  let scan_end1 = _win[scan + best_len - 1];
  let scan_end = _win[scan + best_len];
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  if (nice_match > s.lookahead) {
    nice_match = s.lookahead;
  }
  do {
    match = cur_match;
    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
      continue;
    }
    scan += 2;
    match++;
    do {
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;
    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1 = _win[scan + best_len - 1];
      scan_end = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
};
var fill_window = (s) => {
  const _w_size = s.w_size;
  let n, more, str;
  do {
    more = s.window_size - s.lookahead - s.strstart;
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
      s.window.set(s.window.subarray(_w_size, _w_size + _w_size - more), 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      s.block_start -= _w_size;
      if (s.insert > s.strstart) {
        s.insert = s.strstart;
      }
      slide_hash(s);
      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];
      s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);
      while (s.insert) {
        s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
};
var deflate_stored = (s, flush) => {
  let min_block = s.pending_buf_size - 5 > s.w_size ? s.w_size : s.pending_buf_size - 5;
  let len, left, have, last = 0;
  let used = s.strm.avail_in;
  do {
    len = 65535;
    have = s.bi_valid + 42 >> 3;
    if (s.strm.avail_out < have) {
      break;
    }
    have = s.strm.avail_out - have;
    left = s.strstart - s.block_start;
    if (len > left + s.strm.avail_in) {
      len = left + s.strm.avail_in;
    }
    if (len > have) {
      len = have;
    }
    if (len < min_block && (len === 0 && flush !== Z_FINISH$3 || flush === Z_NO_FLUSH$2 || len !== left + s.strm.avail_in)) {
      break;
    }
    last = flush === Z_FINISH$3 && len === left + s.strm.avail_in ? 1 : 0;
    _tr_stored_block(s, 0, 0, last);
    s.pending_buf[s.pending - 4] = len;
    s.pending_buf[s.pending - 3] = len >> 8;
    s.pending_buf[s.pending - 2] = ~len;
    s.pending_buf[s.pending - 1] = ~len >> 8;
    flush_pending(s.strm);
    if (left) {
      if (left > len) {
        left = len;
      }
      s.strm.output.set(s.window.subarray(s.block_start, s.block_start + left), s.strm.next_out);
      s.strm.next_out += left;
      s.strm.avail_out -= left;
      s.strm.total_out += left;
      s.block_start += left;
      len -= left;
    }
    if (len) {
      read_buf(s.strm, s.strm.output, s.strm.next_out, len);
      s.strm.next_out += len;
      s.strm.avail_out -= len;
      s.strm.total_out += len;
    }
  } while (last === 0);
  used -= s.strm.avail_in;
  if (used) {
    if (used >= s.w_size) {
      s.matches = 2;
      s.window.set(s.strm.input.subarray(s.strm.next_in - s.w_size, s.strm.next_in), 0);
      s.strstart = s.w_size;
      s.insert = s.strstart;
    } else {
      if (s.window_size - s.strstart <= used) {
        s.strstart -= s.w_size;
        s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
        if (s.matches < 2) {
          s.matches++;
        }
        if (s.insert > s.strstart) {
          s.insert = s.strstart;
        }
      }
      s.window.set(s.strm.input.subarray(s.strm.next_in - used, s.strm.next_in), s.strstart);
      s.strstart += used;
      s.insert += used > s.w_size - s.insert ? s.w_size - s.insert : used;
    }
    s.block_start = s.strstart;
  }
  if (s.high_water < s.strstart) {
    s.high_water = s.strstart;
  }
  if (last) {
    return BS_FINISH_DONE;
  }
  if (flush !== Z_NO_FLUSH$2 && flush !== Z_FINISH$3 && s.strm.avail_in === 0 && s.strstart === s.block_start) {
    return BS_BLOCK_DONE;
  }
  have = s.window_size - s.strstart;
  if (s.strm.avail_in > have && s.block_start >= s.w_size) {
    s.block_start -= s.w_size;
    s.strstart -= s.w_size;
    s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
    if (s.matches < 2) {
      s.matches++;
    }
    have += s.w_size;
    if (s.insert > s.strstart) {
      s.insert = s.strstart;
    }
  }
  if (have > s.strm.avail_in) {
    have = s.strm.avail_in;
  }
  if (have) {
    read_buf(s.strm, s.window, s.strstart, have);
    s.strstart += have;
    s.insert += have > s.w_size - s.insert ? s.w_size - s.insert : have;
  }
  if (s.high_water < s.strstart) {
    s.high_water = s.strstart;
  }
  have = s.bi_valid + 42 >> 3;
  have = s.pending_buf_size - have > 65535 ? 65535 : s.pending_buf_size - have;
  min_block = have > s.w_size ? s.w_size : have;
  left = s.strstart - s.block_start;
  if (left >= min_block || (left || flush === Z_FINISH$3) && flush !== Z_NO_FLUSH$2 && s.strm.avail_in === 0 && left <= have) {
    len = left > have ? have : left;
    last = flush === Z_FINISH$3 && s.strm.avail_in === 0 && len === left ? 1 : 0;
    _tr_stored_block(s, s.block_start, len, last);
    s.block_start += len;
    flush_pending(s.strm);
  }
  return last ? BS_FINISH_STARTED : BS_NEED_MORE;
};
var deflate_fast = (s, flush) => {
  let hash_head;
  let bflush;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH) {
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
    }
    if (s.match_length >= MIN_MATCH) {
      bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
        s.match_length--;
        do {
          s.strstart++;
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        } while (--s.match_length !== 0);
        s.strstart++;
      } else {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);
      }
    } else {
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
var deflate_slow = (s, flush) => {
  let hash_head;
  let bflush;
  let max_insert;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH) {
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;
    if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
      if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
        s.match_length = MIN_MATCH - 1;
      }
    }
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    } else if (s.match_available) {
      bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
      if (bflush) {
        flush_block_only(s, false);
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  if (s.match_available) {
    bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
var deflate_rle = (s, flush) => {
  let bflush;
  let prev;
  let scan, strend;
  const _win = s.window;
  for (; ; ) {
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
        } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
    }
    if (s.match_length >= MIN_MATCH) {
      bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
var deflate_huff = (s, flush) => {
  let bflush;
  for (; ; ) {
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH$2) {
          return BS_NEED_MORE;
        }
        break;
      }
    }
    s.match_length = 0;
    bflush = _tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}
var configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),
  /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),
  /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),
  /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),
  /* 3 */
  new Config(4, 4, 16, 16, deflate_slow),
  /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),
  /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),
  /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),
  /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),
  /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)
  /* 9 max compression */
];
var lm_init = (s) => {
  s.window_size = 2 * s.w_size;
  zero(s.head);
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;
  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
};
function DeflateState() {
  this.strm = null;
  this.status = 0;
  this.pending_buf = null;
  this.pending_buf_size = 0;
  this.pending_out = 0;
  this.pending = 0;
  this.wrap = 0;
  this.gzhead = null;
  this.gzindex = 0;
  this.method = Z_DEFLATED$2;
  this.last_flush = -1;
  this.w_size = 0;
  this.w_bits = 0;
  this.w_mask = 0;
  this.window = null;
  this.window_size = 0;
  this.prev = null;
  this.head = null;
  this.ins_h = 0;
  this.hash_size = 0;
  this.hash_bits = 0;
  this.hash_mask = 0;
  this.hash_shift = 0;
  this.block_start = 0;
  this.match_length = 0;
  this.prev_match = 0;
  this.match_available = 0;
  this.strstart = 0;
  this.match_start = 0;
  this.lookahead = 0;
  this.prev_length = 0;
  this.max_chain_length = 0;
  this.max_lazy_match = 0;
  this.level = 0;
  this.strategy = 0;
  this.good_match = 0;
  this.nice_match = 0;
  this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
  this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
  this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);
  this.l_desc = null;
  this.d_desc = null;
  this.bl_desc = null;
  this.bl_count = new Uint16Array(MAX_BITS + 1);
  this.heap = new Uint16Array(2 * L_CODES + 1);
  zero(this.heap);
  this.heap_len = 0;
  this.heap_max = 0;
  this.depth = new Uint16Array(2 * L_CODES + 1);
  zero(this.depth);
  this.sym_buf = 0;
  this.lit_bufsize = 0;
  this.sym_next = 0;
  this.sym_end = 0;
  this.opt_len = 0;
  this.static_len = 0;
  this.matches = 0;
  this.insert = 0;
  this.bi_buf = 0;
  this.bi_valid = 0;
}
var deflateStateCheck = (strm) => {
  if (!strm) {
    return 1;
  }
  const s = strm.state;
  if (!s || s.strm !== strm || s.status !== INIT_STATE && //#ifdef GZIP
  s.status !== GZIP_STATE && //#endif
  s.status !== EXTRA_STATE && s.status !== NAME_STATE && s.status !== COMMENT_STATE && s.status !== HCRC_STATE && s.status !== BUSY_STATE && s.status !== FINISH_STATE) {
    return 1;
  }
  return 0;
};
var deflateResetKeep = (strm) => {
  if (deflateStateCheck(strm)) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;
  const s = strm.state;
  s.pending = 0;
  s.pending_out = 0;
  if (s.wrap < 0) {
    s.wrap = -s.wrap;
  }
  s.status = //#ifdef GZIP
  s.wrap === 2 ? GZIP_STATE : (
    //#endif
    s.wrap ? INIT_STATE : BUSY_STATE
  );
  strm.adler = s.wrap === 2 ? 0 : 1;
  s.last_flush = -2;
  _tr_init(s);
  return Z_OK$3;
};
var deflateReset = (strm) => {
  const ret = deflateResetKeep(strm);
  if (ret === Z_OK$3) {
    lm_init(strm.state);
  }
  return ret;
};
var deflateSetHeader = (strm, head) => {
  if (deflateStateCheck(strm) || strm.state.wrap !== 2) {
    return Z_STREAM_ERROR$2;
  }
  strm.state.gzhead = head;
  return Z_OK$3;
};
var deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {
  if (!strm) {
    return Z_STREAM_ERROR$2;
  }
  let wrap = 1;
  if (level === Z_DEFAULT_COMPRESSION$1) {
    level = 6;
  }
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else if (windowBits > 15) {
    wrap = 2;
    windowBits -= 16;
  }
  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED || windowBits === 8 && wrap !== 1) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  if (windowBits === 8) {
    windowBits = 9;
  }
  const s = new DeflateState();
  strm.state = s;
  s.strm = strm;
  s.status = INIT_STATE;
  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;
  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
  s.window = new Uint8Array(s.w_size * 2);
  s.head = new Uint16Array(s.hash_size);
  s.prev = new Uint16Array(s.w_size);
  s.lit_bufsize = 1 << memLevel + 6;
  s.pending_buf_size = s.lit_bufsize * 4;
  s.pending_buf = new Uint8Array(s.pending_buf_size);
  s.sym_buf = s.lit_bufsize;
  s.sym_end = (s.lit_bufsize - 1) * 3;
  s.level = level;
  s.strategy = strategy;
  s.method = method;
  return deflateReset(strm);
};
var deflateInit = (strm, level) => {
  return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
};
var deflate$2 = (strm, flush) => {
  if (deflateStateCheck(strm) || flush > Z_BLOCK$1 || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
  }
  const s = strm.state;
  if (!strm.output || strm.avail_in !== 0 && !strm.input || s.status === FINISH_STATE && flush !== Z_FINISH$3) {
    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
  }
  const old_flush = s.last_flush;
  s.last_flush = flush;
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH$3) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (s.status === INIT_STATE && s.wrap === 0) {
    s.status = BUSY_STATE;
  }
  if (s.status === INIT_STATE) {
    let header = Z_DEFLATED$2 + (s.w_bits - 8 << 4) << 8;
    let level_flags = -1;
    if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
      level_flags = 0;
    } else if (s.level < 6) {
      level_flags = 1;
    } else if (s.level === 6) {
      level_flags = 2;
    } else {
      level_flags = 3;
    }
    header |= level_flags << 6;
    if (s.strstart !== 0) {
      header |= PRESET_DICT;
    }
    header += 31 - header % 31;
    putShortMSB(s, header);
    if (s.strstart !== 0) {
      putShortMSB(s, strm.adler >>> 16);
      putShortMSB(s, strm.adler & 65535);
    }
    strm.adler = 1;
    s.status = BUSY_STATE;
    flush_pending(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  }
  if (s.status === GZIP_STATE) {
    strm.adler = 0;
    put_byte(s, 31);
    put_byte(s, 139);
    put_byte(s, 8);
    if (!s.gzhead) {
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
      put_byte(s, OS_CODE);
      s.status = BUSY_STATE;
      flush_pending(strm);
      if (s.pending !== 0) {
        s.last_flush = -1;
        return Z_OK$3;
      }
    } else {
      put_byte(
        s,
        (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
      );
      put_byte(s, s.gzhead.time & 255);
      put_byte(s, s.gzhead.time >> 8 & 255);
      put_byte(s, s.gzhead.time >> 16 & 255);
      put_byte(s, s.gzhead.time >> 24 & 255);
      put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
      put_byte(s, s.gzhead.os & 255);
      if (s.gzhead.extra && s.gzhead.extra.length) {
        put_byte(s, s.gzhead.extra.length & 255);
        put_byte(s, s.gzhead.extra.length >> 8 & 255);
      }
      if (s.gzhead.hcrc) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);
      }
      s.gzindex = 0;
      s.status = EXTRA_STATE;
    }
  }
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra) {
      let beg = s.pending;
      let left = (s.gzhead.extra.length & 65535) - s.gzindex;
      while (s.pending + left > s.pending_buf_size) {
        let copy = s.pending_buf_size - s.pending;
        s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex, s.gzindex + copy), s.pending);
        s.pending = s.pending_buf_size;
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        s.gzindex += copy;
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
        beg = 0;
        left -= copy;
      }
      let gzhead_extra = new Uint8Array(s.gzhead.extra);
      s.pending_buf.set(gzhead_extra.subarray(s.gzindex, s.gzindex + left), s.pending);
      s.pending += left;
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      s.gzindex = 0;
    }
    s.status = NAME_STATE;
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name) {
      let beg = s.pending;
      let val;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      s.gzindex = 0;
    }
    s.status = COMMENT_STATE;
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment) {
      let beg = s.pending;
      let val;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
    }
    s.status = HCRC_STATE;
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
      }
      put_byte(s, strm.adler & 255);
      put_byte(s, strm.adler >> 8 & 255);
      strm.adler = 0;
    }
    s.status = BUSY_STATE;
    flush_pending(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  }
  if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH$2 && s.status !== FINISH_STATE) {
    let bstate = s.level === 0 ? deflate_stored(s, flush) : s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
      }
      return Z_OK$3;
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        _tr_align(s);
      } else if (flush !== Z_BLOCK$1) {
        _tr_stored_block(s, 0, 0, false);
        if (flush === Z_FULL_FLUSH$1) {
          zero(s.head);
          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return Z_OK$3;
      }
    }
  }
  if (flush !== Z_FINISH$3) {
    return Z_OK$3;
  }
  if (s.wrap <= 0) {
    return Z_STREAM_END$3;
  }
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 255);
    put_byte(s, strm.adler >> 8 & 255);
    put_byte(s, strm.adler >> 16 & 255);
    put_byte(s, strm.adler >> 24 & 255);
    put_byte(s, strm.total_in & 255);
    put_byte(s, strm.total_in >> 8 & 255);
    put_byte(s, strm.total_in >> 16 & 255);
    put_byte(s, strm.total_in >> 24 & 255);
  } else {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 65535);
  }
  flush_pending(strm);
  if (s.wrap > 0) {
    s.wrap = -s.wrap;
  }
  return s.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
};
var deflateEnd = (strm) => {
  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }
  const status = strm.state.status;
  strm.state = null;
  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;
};
var deflateSetDictionary = (strm, dictionary) => {
  let dictLength = dictionary.length;
  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }
  const s = strm.state;
  const wrap = s.wrap;
  if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
    return Z_STREAM_ERROR$2;
  }
  if (wrap === 1) {
    strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
  }
  s.wrap = 0;
  if (dictLength >= s.w_size) {
    if (wrap === 0) {
      zero(s.head);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    let tmpDict = new Uint8Array(s.w_size);
    tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  const avail = strm.avail_in;
  const next = strm.next_in;
  const input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    let str = s.strstart;
    let n = s.lookahead - (MIN_MATCH - 1);
    do {
      s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
      s.prev[str & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK$3;
};
var deflateInit_1 = deflateInit;
var deflateInit2_1 = deflateInit2;
var deflateReset_1 = deflateReset;
var deflateResetKeep_1 = deflateResetKeep;
var deflateSetHeader_1 = deflateSetHeader;
var deflate_2$1 = deflate$2;
var deflateEnd_1 = deflateEnd;
var deflateSetDictionary_1 = deflateSetDictionary;
var deflateInfo = "pako deflate (from Nodeca project)";
var deflate_1$2 = {
  deflateInit: deflateInit_1,
  deflateInit2: deflateInit2_1,
  deflateReset: deflateReset_1,
  deflateResetKeep: deflateResetKeep_1,
  deflateSetHeader: deflateSetHeader_1,
  deflate: deflate_2$1,
  deflateEnd: deflateEnd_1,
  deflateSetDictionary: deflateSetDictionary_1,
  deflateInfo
};
var _has = (obj, key) => {
  return Object.prototype.hasOwnProperty.call(obj, key);
};
var assign = function(obj) {
  const sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    const source = sources.shift();
    if (!source) {
      continue;
    }
    if (typeof source !== "object") {
      throw new TypeError(source + "must be non-object");
    }
    for (const p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }
  return obj;
};
var flattenChunks = (chunks) => {
  let len = 0;
  for (let i = 0, l = chunks.length; i < l; i++) {
    len += chunks[i].length;
  }
  const result = new Uint8Array(len);
  for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
    let chunk = chunks[i];
    result.set(chunk, pos);
    pos += chunk.length;
  }
  return result;
};
var common = {
  assign,
  flattenChunks
};
var STR_APPLY_UIA_OK = true;
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch (__) {
  STR_APPLY_UIA_OK = false;
}
var _utf8len = new Uint8Array(256);
for (let q = 0; q < 256; q++) {
  _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
}
_utf8len[254] = _utf8len[254] = 1;
var string2buf = (str) => {
  if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) {
    return new TextEncoder().encode(str);
  }
  let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
  }
  buf = new Uint8Array(buf_len);
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    if (c < 128) {
      buf[i++] = c;
    } else if (c < 2048) {
      buf[i++] = 192 | c >>> 6;
      buf[i++] = 128 | c & 63;
    } else if (c < 65536) {
      buf[i++] = 224 | c >>> 12;
      buf[i++] = 128 | c >>> 6 & 63;
      buf[i++] = 128 | c & 63;
    } else {
      buf[i++] = 240 | c >>> 18;
      buf[i++] = 128 | c >>> 12 & 63;
      buf[i++] = 128 | c >>> 6 & 63;
      buf[i++] = 128 | c & 63;
    }
  }
  return buf;
};
var buf2binstring = (buf, len) => {
  if (len < 65534) {
    if (buf.subarray && STR_APPLY_UIA_OK) {
      return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
    }
  }
  let result = "";
  for (let i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
};
var buf2string = (buf, max) => {
  const len = max || buf.length;
  if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) {
    return new TextDecoder().decode(buf.subarray(0, max));
  }
  let i, out;
  const utf16buf = new Array(len * 2);
  for (out = 0, i = 0; i < len; ) {
    let c = buf[i++];
    if (c < 128) {
      utf16buf[out++] = c;
      continue;
    }
    let c_len = _utf8len[c];
    if (c_len > 4) {
      utf16buf[out++] = 65533;
      i += c_len - 1;
      continue;
    }
    c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
    while (c_len > 1 && i < len) {
      c = c << 6 | buf[i++] & 63;
      c_len--;
    }
    if (c_len > 1) {
      utf16buf[out++] = 65533;
      continue;
    }
    if (c < 65536) {
      utf16buf[out++] = c;
    } else {
      c -= 65536;
      utf16buf[out++] = 55296 | c >> 10 & 1023;
      utf16buf[out++] = 56320 | c & 1023;
    }
  }
  return buf2binstring(utf16buf, out);
};
var utf8border = (buf, max) => {
  max = max || buf.length;
  if (max > buf.length) {
    max = buf.length;
  }
  let pos = max - 1;
  while (pos >= 0 && (buf[pos] & 192) === 128) {
    pos--;
  }
  if (pos < 0) {
    return max;
  }
  if (pos === 0) {
    return max;
  }
  return pos + _utf8len[buf[pos]] > max ? pos : max;
};
var strings = {
  string2buf,
  buf2string,
  utf8border
};
function ZStream() {
  this.input = null;
  this.next_in = 0;
  this.avail_in = 0;
  this.total_in = 0;
  this.output = null;
  this.next_out = 0;
  this.avail_out = 0;
  this.total_out = 0;
  this.msg = "";
  this.state = null;
  this.data_type = 2;
  this.adler = 0;
}
var zstream = ZStream;
var toString$1 = Object.prototype.toString;
var {
  Z_NO_FLUSH: Z_NO_FLUSH$1,
  Z_SYNC_FLUSH,
  Z_FULL_FLUSH,
  Z_FINISH: Z_FINISH$2,
  Z_OK: Z_OK$2,
  Z_STREAM_END: Z_STREAM_END$2,
  Z_DEFAULT_COMPRESSION,
  Z_DEFAULT_STRATEGY,
  Z_DEFLATED: Z_DEFLATED$1
} = constants$2;
function Deflate$1(options) {
  this.options = common.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED$1,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY
  }, options || {});
  let opt = this.options;
  if (opt.raw && opt.windowBits > 0) {
    opt.windowBits = -opt.windowBits;
  } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
    opt.windowBits += 16;
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = deflate_1$2.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );
  if (status !== Z_OK$2) {
    throw new Error(messages[status]);
  }
  if (opt.header) {
    deflate_1$2.deflateSetHeader(this.strm, opt.header);
  }
  if (opt.dictionary) {
    let dict;
    if (typeof opt.dictionary === "string") {
      dict = strings.string2buf(opt.dictionary);
    } else if (toString$1.call(opt.dictionary) === "[object ArrayBuffer]") {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }
    status = deflate_1$2.deflateSetDictionary(this.strm, dict);
    if (status !== Z_OK$2) {
      throw new Error(messages[status]);
    }
    this._dict_set = true;
  }
}
Deflate$1.prototype.push = function(data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  let status, _flush_mode;
  if (this.ended) {
    return false;
  }
  if (flush_mode === ~~flush_mode)
    _flush_mode = flush_mode;
  else
    _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;
  if (typeof data === "string") {
    strm.input = strings.string2buf(data);
  } else if (toString$1.call(data) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    status = deflate_1$2.deflate(strm, _flush_mode);
    if (status === Z_STREAM_END$2) {
      if (strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
      }
      status = deflate_1$2.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK$2;
    }
    if (strm.avail_out === 0) {
      this.onData(strm.output);
      continue;
    }
    if (_flush_mode > 0 && strm.next_out > 0) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    if (strm.avail_in === 0)
      break;
  }
  return true;
};
Deflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Deflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK$2) {
    this.result = common.flattenChunks(this.chunks);
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function deflate$1(input, options) {
  const deflator = new Deflate$1(options);
  deflator.push(input, true);
  if (deflator.err) {
    throw deflator.msg || messages[deflator.err];
  }
  return deflator.result;
}
function deflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return deflate$1(input, options);
}
function gzip$1(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate$1(input, options);
}
var Deflate_1$1 = Deflate$1;
var deflate_2 = deflate$1;
var deflateRaw_1$1 = deflateRaw$1;
var gzip_1$1 = gzip$1;
var constants$1 = constants$2;
var deflate_1$1 = {
  Deflate: Deflate_1$1,
  deflate: deflate_2,
  deflateRaw: deflateRaw_1$1,
  gzip: gzip_1$1,
  constants: constants$1
};
var BAD$1 = 16209;
var TYPE$1 = 16191;
var inffast = function inflate_fast(strm, start) {
  let _in;
  let last;
  let _out;
  let beg;
  let end;
  let dmax;
  let wsize;
  let whave;
  let wnext;
  let s_window;
  let hold;
  let bits;
  let lcode;
  let dcode;
  let lmask;
  let dmask;
  let here;
  let op;
  let len;
  let dist;
  let from;
  let from_source;
  let input, output;
  const state = strm.state;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
  dmax = state.dmax;
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;
  top:
    do {
      if (bits < 15) {
        hold += input[_in++] << bits;
        bits += 8;
        hold += input[_in++] << bits;
        bits += 8;
      }
      here = lcode[hold & lmask];
      dolen:
        for (; ; ) {
          op = here >>> 24;
          hold >>>= op;
          bits -= op;
          op = here >>> 16 & 255;
          if (op === 0) {
            output[_out++] = here & 65535;
          } else if (op & 16) {
            len = here & 65535;
            op &= 15;
            if (op) {
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
              len += hold & (1 << op) - 1;
              hold >>>= op;
              bits -= op;
            }
            if (bits < 15) {
              hold += input[_in++] << bits;
              bits += 8;
              hold += input[_in++] << bits;
              bits += 8;
            }
            here = dcode[hold & dmask];
            dodist:
              for (; ; ) {
                op = here >>> 24;
                hold >>>= op;
                bits -= op;
                op = here >>> 16 & 255;
                if (op & 16) {
                  dist = here & 65535;
                  op &= 15;
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                    }
                  }
                  dist += hold & (1 << op) - 1;
                  if (dist > dmax) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD$1;
                    break top;
                  }
                  hold >>>= op;
                  bits -= op;
                  op = _out - beg;
                  if (dist > op) {
                    op = dist - op;
                    if (op > whave) {
                      if (state.sane) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD$1;
                        break top;
                      }
                    }
                    from = 0;
                    from_source = s_window;
                    if (wnext === 0) {
                      from += wsize - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output;
                      }
                    } else if (wnext < op) {
                      from += wsize + wnext - op;
                      op -= wnext;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = 0;
                        if (wnext < len) {
                          op = wnext;
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      }
                    } else {
                      from += wnext - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output;
                      }
                    }
                    while (len > 2) {
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      len -= 3;
                    }
                    if (len) {
                      output[_out++] = from_source[from++];
                      if (len > 1) {
                        output[_out++] = from_source[from++];
                      }
                    }
                  } else {
                    from = _out - dist;
                    do {
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      len -= 3;
                    } while (len > 2);
                    if (len) {
                      output[_out++] = output[from++];
                      if (len > 1) {
                        output[_out++] = output[from++];
                      }
                    }
                  }
                } else if ((op & 64) === 0) {
                  here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                  continue dodist;
                } else {
                  strm.msg = "invalid distance code";
                  state.mode = BAD$1;
                  break top;
                }
                break;
              }
          } else if ((op & 64) === 0) {
            here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
            continue dolen;
          } else if (op & 32) {
            state.mode = TYPE$1;
            break top;
          } else {
            strm.msg = "invalid literal/length code";
            state.mode = BAD$1;
            break top;
          }
          break;
        }
    } while (_in < last && _out < end);
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
  strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
  state.hold = hold;
  state.bits = bits;
  return;
};
var MAXBITS = 15;
var ENOUGH_LENS$1 = 852;
var ENOUGH_DISTS$1 = 592;
var CODES$1 = 0;
var LENS$1 = 1;
var DISTS$1 = 2;
var lbase = new Uint16Array([
  /* Length codes 257..285 base */
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]);
var lext = new Uint8Array([
  /* Length codes 257..285 extra */
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]);
var dbase = new Uint16Array([
  /* Distance codes 0..29 base */
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]);
var dext = new Uint8Array([
  /* Distance codes 0..29 extra */
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]);
var inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) => {
  const bits = opts.bits;
  let len = 0;
  let sym = 0;
  let min = 0, max = 0;
  let root = 0;
  let curr = 0;
  let drop = 0;
  let left = 0;
  let used = 0;
  let huff = 0;
  let incr;
  let fill;
  let low;
  let mask;
  let next;
  let base = null;
  let match;
  const count = new Uint16Array(MAXBITS + 1);
  const offs = new Uint16Array(MAXBITS + 1);
  let extra = null;
  let here_bits, here_op, here_val;
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) {
      break;
    }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    opts.bits = 1;
    return 0;
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) {
      break;
    }
  }
  if (root < min) {
    root = min;
  }
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }
  }
  if (left > 0 && (type === CODES$1 || max !== 1)) {
    return -1;
  }
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }
  if (type === CODES$1) {
    base = extra = work;
    match = 20;
  } else if (type === LENS$1) {
    base = lbase;
    extra = lext;
    match = 257;
  } else {
    base = dbase;
    extra = dext;
    match = 0;
  }
  huff = 0;
  sym = 0;
  len = min;
  next = table_index;
  curr = root;
  drop = 0;
  low = -1;
  used = 1 << root;
  mask = used - 1;
  if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
    return 1;
  }
  for (; ; ) {
    here_bits = len - drop;
    if (work[sym] + 1 < match) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] >= match) {
      here_op = extra[work[sym] - match];
      here_val = base[work[sym] - match];
    } else {
      here_op = 32 + 64;
      here_val = 0;
    }
    incr = 1 << len - drop;
    fill = 1 << curr;
    min = fill;
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill !== 0);
    incr = 1 << len - 1;
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }
    sym++;
    if (--count[len] === 0) {
      if (len === max) {
        break;
      }
      len = lens[lens_index + work[sym]];
    }
    if (len > root && (huff & mask) !== low) {
      if (drop === 0) {
        drop = root;
      }
      next += min;
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) {
          break;
        }
        curr++;
        left <<= 1;
      }
      used += 1 << curr;
      if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
        return 1;
      }
      low = huff & mask;
      table[low] = root << 24 | curr << 16 | next - table_index | 0;
    }
  }
  if (huff !== 0) {
    table[next + huff] = len - drop << 24 | 64 << 16 | 0;
  }
  opts.bits = root;
  return 0;
};
var inftrees = inflate_table;
var CODES = 0;
var LENS = 1;
var DISTS = 2;
var {
  Z_FINISH: Z_FINISH$1,
  Z_BLOCK,
  Z_TREES,
  Z_OK: Z_OK$1,
  Z_STREAM_END: Z_STREAM_END$1,
  Z_NEED_DICT: Z_NEED_DICT$1,
  Z_STREAM_ERROR: Z_STREAM_ERROR$1,
  Z_DATA_ERROR: Z_DATA_ERROR$1,
  Z_MEM_ERROR: Z_MEM_ERROR$1,
  Z_BUF_ERROR,
  Z_DEFLATED
} = constants$2;
var HEAD = 16180;
var FLAGS = 16181;
var TIME = 16182;
var OS = 16183;
var EXLEN = 16184;
var EXTRA = 16185;
var NAME = 16186;
var COMMENT = 16187;
var HCRC = 16188;
var DICTID = 16189;
var DICT = 16190;
var TYPE = 16191;
var TYPEDO = 16192;
var STORED = 16193;
var COPY_ = 16194;
var COPY = 16195;
var TABLE = 16196;
var LENLENS = 16197;
var CODELENS = 16198;
var LEN_ = 16199;
var LEN = 16200;
var LENEXT = 16201;
var DIST = 16202;
var DISTEXT = 16203;
var MATCH = 16204;
var LIT = 16205;
var CHECK = 16206;
var LENGTH = 16207;
var DONE = 16208;
var BAD = 16209;
var MEM = 16210;
var SYNC = 16211;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
var MAX_WBITS = 15;
var DEF_WBITS = MAX_WBITS;
var zswap32 = (q) => {
  return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
};
function InflateState() {
  this.strm = null;
  this.mode = 0;
  this.last = false;
  this.wrap = 0;
  this.havedict = false;
  this.flags = 0;
  this.dmax = 0;
  this.check = 0;
  this.total = 0;
  this.head = null;
  this.wbits = 0;
  this.wsize = 0;
  this.whave = 0;
  this.wnext = 0;
  this.window = null;
  this.hold = 0;
  this.bits = 0;
  this.length = 0;
  this.offset = 0;
  this.extra = 0;
  this.lencode = null;
  this.distcode = null;
  this.lenbits = 0;
  this.distbits = 0;
  this.ncode = 0;
  this.nlen = 0;
  this.ndist = 0;
  this.have = 0;
  this.next = null;
  this.lens = new Uint16Array(320);
  this.work = new Uint16Array(288);
  this.lendyn = null;
  this.distdyn = null;
  this.sane = 0;
  this.back = 0;
  this.was = 0;
}
var inflateStateCheck = (strm) => {
  if (!strm) {
    return 1;
  }
  const state = strm.state;
  if (!state || state.strm !== strm || state.mode < HEAD || state.mode > SYNC) {
    return 1;
  }
  return 0;
};
var inflateResetKeep = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = "";
  if (state.wrap) {
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.flags = -1;
  state.dmax = 32768;
  state.head = null;
  state.hold = 0;
  state.bits = 0;
  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
  state.sane = 1;
  state.back = -1;
  return Z_OK$1;
};
var inflateReset = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);
};
var inflateReset2 = (strm, windowBits) => {
  let wrap;
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else {
    wrap = (windowBits >> 4) + 5;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR$1;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
};
var inflateInit2 = (strm, windowBits) => {
  if (!strm) {
    return Z_STREAM_ERROR$1;
  }
  const state = new InflateState();
  strm.state = state;
  state.strm = strm;
  state.window = null;
  state.mode = HEAD;
  const ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK$1) {
    strm.state = null;
  }
  return ret;
};
var inflateInit = (strm) => {
  return inflateInit2(strm, DEF_WBITS);
};
var virgin = true;
var lenfix;
var distfix;
var fixedtables = (state) => {
  if (virgin) {
    lenfix = new Int32Array(512);
    distfix = new Int32Array(32);
    let sym = 0;
    while (sym < 144) {
      state.lens[sym++] = 8;
    }
    while (sym < 256) {
      state.lens[sym++] = 9;
    }
    while (sym < 280) {
      state.lens[sym++] = 7;
    }
    while (sym < 288) {
      state.lens[sym++] = 8;
    }
    inftrees(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
    sym = 0;
    while (sym < 32) {
      state.lens[sym++] = 5;
    }
    inftrees(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
    virgin = false;
  }
  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
};
var updatewindow = (strm, src, end, copy) => {
  let dist;
  const state = strm.state;
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;
    state.window = new Uint8Array(state.wsize);
  }
  if (copy >= state.wsize) {
    state.window.set(src.subarray(end - state.wsize, end), 0);
    state.wnext = 0;
    state.whave = state.wsize;
  } else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
    copy -= dist;
    if (copy) {
      state.window.set(src.subarray(end - copy, end), 0);
      state.wnext = copy;
      state.whave = state.wsize;
    } else {
      state.wnext += dist;
      if (state.wnext === state.wsize) {
        state.wnext = 0;
      }
      if (state.whave < state.wsize) {
        state.whave += dist;
      }
    }
  }
  return 0;
};
var inflate$2 = (strm, flush) => {
  let state;
  let input, output;
  let next;
  let put;
  let have, left;
  let hold;
  let bits;
  let _in, _out;
  let copy;
  let from;
  let from_source;
  let here = 0;
  let here_bits, here_op, here_val;
  let last_bits, last_op, last_val;
  let len;
  let ret;
  const hbuf = new Uint8Array(4);
  let opts;
  let n;
  const order = (
    /* permutation of code lengths */
    new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
  );
  if (inflateStateCheck(strm) || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.mode === TYPE) {
    state.mode = TYPEDO;
  }
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  _in = have;
  _out = left;
  ret = Z_OK$1;
  inf_leave:
    for (; ; ) {
      switch (state.mode) {
        case HEAD:
          if (state.wrap === 0) {
            state.mode = TYPEDO;
            break;
          }
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.wrap & 2 && hold === 35615) {
            if (state.wbits === 0) {
              state.wbits = 15;
            }
            state.check = 0;
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
            hold = 0;
            bits = 0;
            state.mode = FLAGS;
            break;
          }
          if (state.head) {
            state.head.done = false;
          }
          if (!(state.wrap & 1) || /* check if zlib header allowed */
          (((hold & 255) << 8) + (hold >> 8)) % 31) {
            strm.msg = "incorrect header check";
            state.mode = BAD;
            break;
          }
          if ((hold & 15) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          hold >>>= 4;
          bits -= 4;
          len = (hold & 15) + 8;
          if (state.wbits === 0) {
            state.wbits = len;
          }
          if (len > 15 || len > state.wbits) {
            strm.msg = "invalid window size";
            state.mode = BAD;
            break;
          }
          state.dmax = 1 << state.wbits;
          state.flags = 0;
          strm.adler = state.check = 1;
          state.mode = hold & 512 ? DICTID : TYPE;
          hold = 0;
          bits = 0;
          break;
        case FLAGS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.flags = hold;
          if ((state.flags & 255) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          if (state.flags & 57344) {
            strm.msg = "unknown header flags set";
            state.mode = BAD;
            break;
          }
          if (state.head) {
            state.head.text = hold >> 8 & 1;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = TIME;
        case TIME:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.time = hold;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            hbuf[2] = hold >>> 16 & 255;
            hbuf[3] = hold >>> 24 & 255;
            state.check = crc32_1(state.check, hbuf, 4, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = OS;
        case OS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.xflags = hold & 255;
            state.head.os = hold >> 8;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = EXLEN;
        case EXLEN:
          if (state.flags & 1024) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.length = hold;
            if (state.head) {
              state.head.extra_len = hold;
            }
            if (state.flags & 512 && state.wrap & 4) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32_1(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
          } else if (state.head) {
            state.head.extra = null;
          }
          state.mode = EXTRA;
        case EXTRA:
          if (state.flags & 1024) {
            copy = state.length;
            if (copy > have) {
              copy = have;
            }
            if (copy) {
              if (state.head) {
                len = state.head.extra_len - state.length;
                if (!state.head.extra) {
                  state.head.extra = new Uint8Array(state.head.extra_len);
                }
                state.head.extra.set(
                  input.subarray(
                    next,
                    // extra field is limited to 65536 bytes
                    // - no need for additional size check
                    next + copy
                  ),
                  /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                  len
                );
              }
              if (state.flags & 512 && state.wrap & 4) {
                state.check = crc32_1(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              state.length -= copy;
            }
            if (state.length) {
              break inf_leave;
            }
          }
          state.length = 0;
          state.mode = NAME;
        case NAME:
          if (state.flags & 2048) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len = input[next + copy++];
              if (state.head && len && state.length < 65536) {
                state.head.name += String.fromCharCode(len);
              }
            } while (len && copy < have);
            if (state.flags & 512 && state.wrap & 4) {
              state.check = crc32_1(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.name = null;
          }
          state.length = 0;
          state.mode = COMMENT;
        case COMMENT:
          if (state.flags & 4096) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len = input[next + copy++];
              if (state.head && len && state.length < 65536) {
                state.head.comment += String.fromCharCode(len);
              }
            } while (len && copy < have);
            if (state.flags & 512 && state.wrap & 4) {
              state.check = crc32_1(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.comment = null;
          }
          state.mode = HCRC;
        case HCRC:
          if (state.flags & 512) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 4 && hold !== (state.check & 65535)) {
              strm.msg = "header crc mismatch";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          if (state.head) {
            state.head.hcrc = state.flags >> 9 & 1;
            state.head.done = true;
          }
          strm.adler = state.check = 0;
          state.mode = TYPE;
          break;
        case DICTID:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          strm.adler = state.check = zswap32(hold);
          hold = 0;
          bits = 0;
          state.mode = DICT;
        case DICT:
          if (state.havedict === 0) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            return Z_NEED_DICT$1;
          }
          strm.adler = state.check = 1;
          state.mode = TYPE;
        case TYPE:
          if (flush === Z_BLOCK || flush === Z_TREES) {
            break inf_leave;
          }
        case TYPEDO:
          if (state.last) {
            hold >>>= bits & 7;
            bits -= bits & 7;
            state.mode = CHECK;
            break;
          }
          while (bits < 3) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.last = hold & 1;
          hold >>>= 1;
          bits -= 1;
          switch (hold & 3) {
            case 0:
              state.mode = STORED;
              break;
            case 1:
              fixedtables(state);
              state.mode = LEN_;
              if (flush === Z_TREES) {
                hold >>>= 2;
                bits -= 2;
                break inf_leave;
              }
              break;
            case 2:
              state.mode = TABLE;
              break;
            case 3:
              strm.msg = "invalid block type";
              state.mode = BAD;
          }
          hold >>>= 2;
          bits -= 2;
          break;
        case STORED:
          hold >>>= bits & 7;
          bits -= bits & 7;
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
            strm.msg = "invalid stored block lengths";
            state.mode = BAD;
            break;
          }
          state.length = hold & 65535;
          hold = 0;
          bits = 0;
          state.mode = COPY_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        case COPY_:
          state.mode = COPY;
        case COPY:
          copy = state.length;
          if (copy) {
            if (copy > have) {
              copy = have;
            }
            if (copy > left) {
              copy = left;
            }
            if (copy === 0) {
              break inf_leave;
            }
            output.set(input.subarray(next, next + copy), put);
            have -= copy;
            next += copy;
            left -= copy;
            put += copy;
            state.length -= copy;
            break;
          }
          state.mode = TYPE;
          break;
        case TABLE:
          while (bits < 14) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.nlen = (hold & 31) + 257;
          hold >>>= 5;
          bits -= 5;
          state.ndist = (hold & 31) + 1;
          hold >>>= 5;
          bits -= 5;
          state.ncode = (hold & 15) + 4;
          hold >>>= 4;
          bits -= 4;
          if (state.nlen > 286 || state.ndist > 30) {
            strm.msg = "too many length or distance symbols";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = LENLENS;
        case LENLENS:
          while (state.have < state.ncode) {
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.lens[order[state.have++]] = hold & 7;
            hold >>>= 3;
            bits -= 3;
          }
          while (state.have < 19) {
            state.lens[order[state.have++]] = 0;
          }
          state.lencode = state.lendyn;
          state.lenbits = 7;
          opts = { bits: state.lenbits };
          ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid code lengths set";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = CODELENS;
        case CODELENS:
          while (state.have < state.nlen + state.ndist) {
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_val < 16) {
              hold >>>= here_bits;
              bits -= here_bits;
              state.lens[state.have++] = here_val;
            } else {
              if (here_val === 16) {
                n = here_bits + 2;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                if (state.have === 0) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD;
                  break;
                }
                len = state.lens[state.have - 1];
                copy = 3 + (hold & 3);
                hold >>>= 2;
                bits -= 2;
              } else if (here_val === 17) {
                n = here_bits + 3;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy = 3 + (hold & 7);
                hold >>>= 3;
                bits -= 3;
              } else {
                n = here_bits + 7;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy = 11 + (hold & 127);
                hold >>>= 7;
                bits -= 7;
              }
              if (state.have + copy > state.nlen + state.ndist) {
                strm.msg = "invalid bit length repeat";
                state.mode = BAD;
                break;
              }
              while (copy--) {
                state.lens[state.have++] = len;
              }
            }
          }
          if (state.mode === BAD) {
            break;
          }
          if (state.lens[256] === 0) {
            strm.msg = "invalid code -- missing end-of-block";
            state.mode = BAD;
            break;
          }
          state.lenbits = 9;
          opts = { bits: state.lenbits };
          ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid literal/lengths set";
            state.mode = BAD;
            break;
          }
          state.distbits = 6;
          state.distcode = state.distdyn;
          opts = { bits: state.distbits };
          ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
          state.distbits = opts.bits;
          if (ret) {
            strm.msg = "invalid distances set";
            state.mode = BAD;
            break;
          }
          state.mode = LEN_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        case LEN_:
          state.mode = LEN;
        case LEN:
          if (have >= 6 && left >= 258) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            inffast(strm, _out);
            put = strm.next_out;
            output = strm.output;
            left = strm.avail_out;
            next = strm.next_in;
            input = strm.input;
            have = strm.avail_in;
            hold = state.hold;
            bits = state.bits;
            if (state.mode === TYPE) {
              state.back = -1;
            }
            break;
          }
          state.back = 0;
          for (; ; ) {
            here = state.lencode[hold & (1 << state.lenbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (here_op && (here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          state.length = here_val;
          if (here_op === 0) {
            state.mode = LIT;
            break;
          }
          if (here_op & 32) {
            state.back = -1;
            state.mode = TYPE;
            break;
          }
          if (here_op & 64) {
            strm.msg = "invalid literal/length code";
            state.mode = BAD;
            break;
          }
          state.extra = here_op & 15;
          state.mode = LENEXT;
        case LENEXT:
          if (state.extra) {
            n = state.extra;
            while (bits < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.length += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          state.was = state.length;
          state.mode = DIST;
        case DIST:
          for (; ; ) {
            here = state.distcode[hold & (1 << state.distbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          if (here_op & 64) {
            strm.msg = "invalid distance code";
            state.mode = BAD;
            break;
          }
          state.offset = here_val;
          state.extra = here_op & 15;
          state.mode = DISTEXT;
        case DISTEXT:
          if (state.extra) {
            n = state.extra;
            while (bits < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.offset += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          if (state.offset > state.dmax) {
            strm.msg = "invalid distance too far back";
            state.mode = BAD;
            break;
          }
          state.mode = MATCH;
        case MATCH:
          if (left === 0) {
            break inf_leave;
          }
          copy = _out - left;
          if (state.offset > copy) {
            copy = state.offset - copy;
            if (copy > state.whave) {
              if (state.sane) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
            }
            if (copy > state.wnext) {
              copy -= state.wnext;
              from = state.wsize - copy;
            } else {
              from = state.wnext - copy;
            }
            if (copy > state.length) {
              copy = state.length;
            }
            from_source = state.window;
          } else {
            from_source = output;
            from = put - state.offset;
            copy = state.length;
          }
          if (copy > left) {
            copy = left;
          }
          left -= copy;
          state.length -= copy;
          do {
            output[put++] = from_source[from++];
          } while (--copy);
          if (state.length === 0) {
            state.mode = LEN;
          }
          break;
        case LIT:
          if (left === 0) {
            break inf_leave;
          }
          output[put++] = state.length;
          left--;
          state.mode = LEN;
          break;
        case CHECK:
          if (state.wrap) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold |= input[next++] << bits;
              bits += 8;
            }
            _out -= left;
            strm.total_out += _out;
            state.total += _out;
            if (state.wrap & 4 && _out) {
              strm.adler = state.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
              state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out);
            }
            _out = left;
            if (state.wrap & 4 && (state.flags ? hold : zswap32(hold)) !== state.check) {
              strm.msg = "incorrect data check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = LENGTH;
        case LENGTH:
          if (state.wrap && state.flags) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 4 && hold !== (state.total & 4294967295)) {
              strm.msg = "incorrect length check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = DONE;
        case DONE:
          ret = Z_STREAM_END$1;
          break inf_leave;
        case BAD:
          ret = Z_DATA_ERROR$1;
          break inf_leave;
        case MEM:
          return Z_MEM_ERROR$1;
        case SYNC:
        default:
          return Z_STREAM_ERROR$1;
      }
    }
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH$1)) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out))
      ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap & 4 && _out) {
    strm.adler = state.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
    state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out);
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if ((_in === 0 && _out === 0 || flush === Z_FINISH$1) && ret === Z_OK$1) {
    ret = Z_BUF_ERROR;
  }
  return ret;
};
var inflateEnd = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  let state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK$1;
};
var inflateGetHeader = (strm, head) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if ((state.wrap & 2) === 0) {
    return Z_STREAM_ERROR$1;
  }
  state.head = head;
  head.done = false;
  return Z_OK$1;
};
var inflateSetDictionary = (strm, dictionary) => {
  const dictLength = dictionary.length;
  let state;
  let dictid;
  let ret;
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR$1;
  }
  if (state.mode === DICT) {
    dictid = 1;
    dictid = adler32_1(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR$1;
    }
  }
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR$1;
  }
  state.havedict = 1;
  return Z_OK$1;
};
var inflateReset_1 = inflateReset;
var inflateReset2_1 = inflateReset2;
var inflateResetKeep_1 = inflateResetKeep;
var inflateInit_1 = inflateInit;
var inflateInit2_1 = inflateInit2;
var inflate_2$1 = inflate$2;
var inflateEnd_1 = inflateEnd;
var inflateGetHeader_1 = inflateGetHeader;
var inflateSetDictionary_1 = inflateSetDictionary;
var inflateInfo = "pako inflate (from Nodeca project)";
var inflate_1$2 = {
  inflateReset: inflateReset_1,
  inflateReset2: inflateReset2_1,
  inflateResetKeep: inflateResetKeep_1,
  inflateInit: inflateInit_1,
  inflateInit2: inflateInit2_1,
  inflate: inflate_2$1,
  inflateEnd: inflateEnd_1,
  inflateGetHeader: inflateGetHeader_1,
  inflateSetDictionary: inflateSetDictionary_1,
  inflateInfo
};
function GZheader() {
  this.text = 0;
  this.time = 0;
  this.xflags = 0;
  this.os = 0;
  this.extra = null;
  this.extra_len = 0;
  this.name = "";
  this.comment = "";
  this.hcrc = 0;
  this.done = false;
}
var gzheader = GZheader;
var toString = Object.prototype.toString;
var {
  Z_NO_FLUSH,
  Z_FINISH,
  Z_OK,
  Z_STREAM_END,
  Z_NEED_DICT,
  Z_STREAM_ERROR,
  Z_DATA_ERROR,
  Z_MEM_ERROR
} = constants$2;
function Inflate$1(options) {
  this.options = common.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ""
  }, options || {});
  const opt = this.options;
  if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) {
      opt.windowBits = -15;
    }
  }
  if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
    opt.windowBits += 32;
  }
  if (opt.windowBits > 15 && opt.windowBits < 48) {
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = inflate_1$2.inflateInit2(
    this.strm,
    opt.windowBits
  );
  if (status !== Z_OK) {
    throw new Error(messages[status]);
  }
  this.header = new gzheader();
  inflate_1$2.inflateGetHeader(this.strm, this.header);
  if (opt.dictionary) {
    if (typeof opt.dictionary === "string") {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) {
      status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== Z_OK) {
        throw new Error(messages[status]);
      }
    }
  }
}
Inflate$1.prototype.push = function(data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  const dictionary = this.options.dictionary;
  let status, _flush_mode, last_avail_out;
  if (this.ended)
    return false;
  if (flush_mode === ~~flush_mode)
    _flush_mode = flush_mode;
  else
    _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
  if (toString.call(data) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = inflate_1$2.inflate(strm, _flush_mode);
    if (status === Z_NEED_DICT && dictionary) {
      status = inflate_1$2.inflateSetDictionary(strm, dictionary);
      if (status === Z_OK) {
        status = inflate_1$2.inflate(strm, _flush_mode);
      } else if (status === Z_DATA_ERROR) {
        status = Z_NEED_DICT;
      }
    }
    while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
      inflate_1$2.inflateReset(strm);
      status = inflate_1$2.inflate(strm, _flush_mode);
    }
    switch (status) {
      case Z_STREAM_ERROR:
      case Z_DATA_ERROR:
      case Z_NEED_DICT:
      case Z_MEM_ERROR:
        this.onEnd(status);
        this.ended = true;
        return false;
    }
    last_avail_out = strm.avail_out;
    if (strm.next_out) {
      if (strm.avail_out === 0 || status === Z_STREAM_END) {
        if (this.options.to === "string") {
          let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
          let tail = strm.next_out - next_out_utf8;
          let utf8str = strings.buf2string(strm.output, next_out_utf8);
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail)
            strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
          this.onData(utf8str);
        } else {
          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
        }
      }
    }
    if (status === Z_OK && last_avail_out === 0)
      continue;
    if (status === Z_STREAM_END) {
      status = inflate_1$2.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return true;
    }
    if (strm.avail_in === 0)
      break;
  }
  return true;
};
Inflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Inflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK) {
    if (this.options.to === "string") {
      this.result = this.chunks.join("");
    } else {
      this.result = common.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function inflate$1(input, options) {
  const inflator = new Inflate$1(options);
  inflator.push(input);
  if (inflator.err)
    throw inflator.msg || messages[inflator.err];
  return inflator.result;
}
function inflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return inflate$1(input, options);
}
var Inflate_1$1 = Inflate$1;
var inflate_2 = inflate$1;
var inflateRaw_1$1 = inflateRaw$1;
var ungzip$1 = inflate$1;
var constants = constants$2;
var inflate_1$1 = {
  Inflate: Inflate_1$1,
  inflate: inflate_2,
  inflateRaw: inflateRaw_1$1,
  ungzip: ungzip$1,
  constants
};
var { Deflate, deflate, deflateRaw, gzip } = deflate_1$1;
var { Inflate, inflate, inflateRaw, ungzip } = inflate_1$1;
var Deflate_1 = Deflate;
var deflate_1 = deflate;
var deflateRaw_1 = deflateRaw;
var gzip_1 = gzip;
var Inflate_1 = Inflate;
var inflate_1 = inflate;
var inflateRaw_1 = inflateRaw;
var ungzip_1 = ungzip;
var constants_1 = constants$2;
var pako = {
  Deflate: Deflate_1,
  deflate: deflate_1,
  deflateRaw: deflateRaw_1,
  gzip: gzip_1,
  Inflate: Inflate_1,
  inflate: inflate_1,
  inflateRaw: inflateRaw_1,
  ungzip: ungzip_1,
  constants: constants_1
};

// node_modules/eosio-signing-request/lib/esr.m.js
var baseCharset = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
var lookup = new Uint8Array(256);
for (let i = 0; i < 62; i++) {
  lookup[baseCharset.charCodeAt(i)] = i;
}
lookup[43] = lookup[45] = 62;
lookup[47] = lookup[95] = 63;
function encode(data, urlSafe = true) {
  const byteLength = data.byteLength;
  const byteRemainder = byteLength % 3;
  const mainLength = byteLength - byteRemainder;
  const charset = baseCharset + (urlSafe ? "-_" : "+/");
  const parts = [];
  let a;
  let b;
  let c;
  let d;
  let chunk;
  for (let i = 0; i < mainLength; i += 3) {
    chunk = data[i] << 16 | data[i + 1] << 8 | data[i + 2];
    a = (chunk & 16515072) >> 18;
    b = (chunk & 258048) >> 12;
    c = (chunk & 4032) >> 6;
    d = chunk & 63;
    parts.push(charset[a] + charset[b] + charset[c] + charset[d]);
  }
  if (byteRemainder === 1) {
    chunk = data[mainLength];
    a = (chunk & 252) >> 2;
    b = (chunk & 3) << 4;
    parts.push(charset[a] + charset[b]);
  } else if (byteRemainder === 2) {
    chunk = data[mainLength] << 8 | data[mainLength + 1];
    a = (chunk & 64512) >> 10;
    b = (chunk & 1008) >> 4;
    c = (chunk & 15) << 2;
    parts.push(charset[a] + charset[b] + charset[c]);
  }
  return parts.join("");
}
function decode(input) {
  const byteLength = input.length * 0.75;
  const data = new Uint8Array(byteLength);
  let a;
  let b;
  let c;
  let d;
  let p = 0;
  for (let i = 0; i < input.length; i += 4) {
    a = lookup[input.charCodeAt(i)];
    b = lookup[input.charCodeAt(i + 1)];
    c = lookup[input.charCodeAt(i + 2)];
    d = lookup[input.charCodeAt(i + 3)];
    data[p++] = a << 2 | b >> 4;
    data[p++] = (b & 15) << 4 | c >> 2;
    data[p++] = (c & 3) << 6 | d & 63;
  }
  return data;
}
var base64u = Object.freeze({
  __proto__: null,
  encode,
  decode
});
var ChainName;
(function(ChainName2) {
  ChainName2[ChainName2["UNKNOWN"] = 0] = "UNKNOWN";
  ChainName2[ChainName2["EOS"] = 1] = "EOS";
  ChainName2[ChainName2["TELOS"] = 2] = "TELOS";
  ChainName2[ChainName2["JUNGLE"] = 3] = "JUNGLE";
  ChainName2[ChainName2["KYLIN"] = 4] = "KYLIN";
  ChainName2[ChainName2["WORBLI"] = 5] = "WORBLI";
  ChainName2[ChainName2["BOS"] = 6] = "BOS";
  ChainName2[ChainName2["MEETONE"] = 7] = "MEETONE";
  ChainName2[ChainName2["INSIGHTS"] = 8] = "INSIGHTS";
  ChainName2[ChainName2["BEOS"] = 9] = "BEOS";
  ChainName2[ChainName2["WAX"] = 10] = "WAX";
  ChainName2[ChainName2["PROTON"] = 11] = "PROTON";
  ChainName2[ChainName2["FIO"] = 12] = "FIO";
})(ChainName || (ChainName = {}));
var ChainId = class ChainId2 extends Checksum256 {
  static from(value) {
    if (isInstanceOf(value, this)) {
      return value;
    }
    if (typeof value === "number") {
      value = ChainIdLookup.get(value);
      if (!value) {
        throw new Error("Unknown chain id alias");
      }
    }
    return super.from(value);
  }
  get chainVariant() {
    const name = this.chainName;
    if (name !== ChainName.UNKNOWN) {
      return ChainIdVariant.from(["chain_alias", name]);
    }
    return ChainIdVariant.from(this);
  }
  get chainName() {
    const cid = this.hexString;
    for (const [n, id] of ChainIdLookup) {
      if (id === cid) {
        return n;
      }
    }
    return ChainName.UNKNOWN;
  }
};
ChainId = __decorate([
  TypeAlias("chain_id")
], ChainId);
var ChainAlias = class ChainAlias2 extends UInt8 {
};
ChainAlias = __decorate([
  TypeAlias("chain_alias")
], ChainAlias);
var ChainIdVariant = class ChainIdVariant2 extends Variant {
  get chainId() {
    if (isInstanceOf(this.value, ChainId)) {
      return this.value;
    }
    return ChainId.from(Number(this.value.value));
  }
};
ChainIdVariant = __decorate([
  Variant.type("variant_id", [ChainAlias, ChainId])
], ChainIdVariant);
var ChainIdLookup = /* @__PURE__ */ new Map([
  [ChainName.EOS, "aca376f206b8fc25a6ed44dbdc66547c36c6c33e3a119ffbeaef943642f0e906"],
  [ChainName.TELOS, "4667b205c6838ef70ff7988f6e8257e8be0e1284a2f59699054a018f743b1d11"],
  [ChainName.JUNGLE, "e70aaab8997e1dfce58fbfac80cbbb8fecec7b99cf982a9444273cbc64c41473"],
  [ChainName.KYLIN, "5fff1dae8dc8e2fc4d5b23b2c7665c97f9e9d8edf2b6485a86ba311c25639191"],
  [ChainName.WORBLI, "73647cde120091e0a4b85bced2f3cfdb3041e266cbbe95cee59b73235a1b3b6f"],
  [ChainName.BOS, "d5a3d18fbb3c084e3b1f3fa98c21014b5f3db536cc15d08f9f6479517c6a3d86"],
  [ChainName.MEETONE, "cfe6486a83bad4962f232d48003b1824ab5665c36778141034d75e57b956e422"],
  [ChainName.INSIGHTS, "b042025541e25a472bffde2d62edd457b7e70cee943412b1ea0f044f88591664"],
  [ChainName.BEOS, "b912d19a6abd2b1b05611ae5be473355d64d95aeff0c09bedc8c166cd6468fe4"],
  [ChainName.WAX, "1064487b3cd1a897ce03ae5b6a865651747e2e152090f99c1d19d44e01aea5a4"],
  [ChainName.PROTON, "384da888112027f0321850a169f737c33e53b388aad48b5adace4bab97f437e0"],
  [ChainName.FIO, "21dcae42c0182200e93f954a074011f9048a7624c6fe81d3c9541a614a88bd1c"]
]);
var RequestFlags_1;
var AccountName = class AccountName2 extends Name {
};
AccountName = __decorate([
  TypeAlias("account_name")
], AccountName);
var PermissionName = class PermissionName2 extends Name {
};
PermissionName = __decorate([
  TypeAlias("permission_name")
], PermissionName);
var IdentityV2 = class IdentityV22 extends Struct {
};
__decorate([
  Struct.field(PermissionLevel, { optional: true })
], IdentityV2.prototype, "permission", void 0);
IdentityV2 = __decorate([
  Struct.type("identity")
], IdentityV2);
var IdentityV3 = class IdentityV32 extends Struct {
};
__decorate([
  Struct.field("name")
], IdentityV3.prototype, "scope", void 0);
__decorate([
  Struct.field(PermissionLevel, { optional: true })
], IdentityV3.prototype, "permission", void 0);
IdentityV3 = __decorate([
  Struct.type("identity")
], IdentityV3);
var RequestVariantV2 = class RequestVariantV22 extends Variant {
};
RequestVariantV2 = __decorate([
  Variant.type("variant_req", [Action, { type: Action, array: true }, Transaction, IdentityV2])
], RequestVariantV2);
var RequestVariantV3 = class RequestVariantV32 extends Variant {
};
RequestVariantV3 = __decorate([
  Variant.type("variant_req", [Action, { type: Action, array: true }, Transaction, IdentityV3])
], RequestVariantV3);
var RequestFlags = RequestFlags_1 = class RequestFlags2 extends UInt8 {
  get broadcast() {
    return (Number(this) & RequestFlags_1.broadcast) !== 0;
  }
  set broadcast(enabled) {
    this.setFlag(RequestFlags_1.broadcast, enabled);
  }
  get background() {
    return (Number(this) & RequestFlags_1.background) !== 0;
  }
  set background(enabled) {
    this.setFlag(RequestFlags_1.background, enabled);
  }
  setFlag(flag, enabled) {
    if (enabled) {
      this.value = UInt8.from(Number(this) | flag).value;
    } else {
      this.value = UInt8.from(Number(this) & ~flag).value;
    }
  }
};
RequestFlags.broadcast = 1 << 0;
RequestFlags.background = 1 << 1;
RequestFlags = RequestFlags_1 = __decorate([
  TypeAlias("request_flags")
], RequestFlags);
var InfoPair = class InfoPair2 extends Struct {
};
__decorate([
  Struct.field("string")
], InfoPair.prototype, "key", void 0);
__decorate([
  Struct.field("bytes")
], InfoPair.prototype, "value", void 0);
InfoPair = __decorate([
  Struct.type("info_pair")
], InfoPair);
var RequestDataV2 = class RequestDataV22 extends Struct {
};
__decorate([
  Struct.field(ChainIdVariant)
], RequestDataV2.prototype, "chain_id", void 0);
__decorate([
  Struct.field(RequestVariantV2)
], RequestDataV2.prototype, "req", void 0);
__decorate([
  Struct.field(RequestFlags)
], RequestDataV2.prototype, "flags", void 0);
__decorate([
  Struct.field("string")
], RequestDataV2.prototype, "callback", void 0);
__decorate([
  Struct.field(InfoPair, { array: true })
], RequestDataV2.prototype, "info", void 0);
RequestDataV2 = __decorate([
  Struct.type("signing_request")
], RequestDataV2);
var RequestDataV3 = class RequestDataV32 extends Struct {
};
__decorate([
  Struct.field(ChainIdVariant)
], RequestDataV3.prototype, "chain_id", void 0);
__decorate([
  Struct.field(RequestVariantV3)
], RequestDataV3.prototype, "req", void 0);
__decorate([
  Struct.field(RequestFlags)
], RequestDataV3.prototype, "flags", void 0);
__decorate([
  Struct.field("string")
], RequestDataV3.prototype, "callback", void 0);
__decorate([
  Struct.field(InfoPair, { array: true })
], RequestDataV3.prototype, "info", void 0);
RequestDataV3 = __decorate([
  Struct.type("signing_request")
], RequestDataV3);
var RequestSignature = class RequestSignature2 extends Struct {
};
__decorate([
  Struct.field("name")
], RequestSignature.prototype, "signer", void 0);
__decorate([
  Struct.field("signature")
], RequestSignature.prototype, "signature", void 0);
RequestSignature = __decorate([
  Struct.type("request_signature")
], RequestSignature);
var IdentityProof_1;
var IdentityProof = IdentityProof_1 = class IdentityProof2 extends Struct {
  static from(value) {
    if (isInstanceOf(value, IdentityProof_1)) {
      return value;
    } else if (typeof value === "string") {
      return IdentityProof_1.fromString(value);
    } else {
      return super.from(value);
    }
  }
  /**
   * Create a new instance from an EOSIO authorization header string.
   * "EOSIO <base64payload>"
   */
  static fromString(string) {
    const parts = string.split(" ");
    if (parts.length !== 2 || parts[0] !== "EOSIO") {
      throw new Error("Invalid IdentityProof string");
    }
    const data = decode(parts[1]);
    return Serializer.decode({ data, type: IdentityProof_1 });
  }
  /** Create a new instance from a callback payload. */
  static fromPayload(payload, options = {}) {
    const request = SigningRequest.from(payload.req, options);
    if (!(request.version >= 3 && request.isIdentity())) {
      throw new Error("Not an identity request");
    }
    return this.from({
      chainId: payload.cid || request.getChainId(),
      scope: request.getIdentityScope(),
      expiration: payload.ex,
      signer: { actor: payload.sa, permission: payload.sp },
      signature: payload.sig
    });
  }
  /**
   * Transaction this proof resolves to.
   * @internal
   */
  get transaction() {
    const action = Action.from({
      account: "",
      name: "identity",
      authorization: [this.signer],
      data: IdentityV3.from({ scope: this.scope, permission: this.signer })
    });
    return Transaction.from({
      ref_block_num: 0,
      ref_block_prefix: 0,
      expiration: this.expiration,
      actions: [action]
    });
  }
  /**
   * Recover the public key that signed this proof.
   */
  recover() {
    return this.signature.recoverDigest(this.transaction.signingDigest(this.chainId));
  }
  /**
   * Verify that given authority signed this proof.
   * @param auth The accounts signing authority.
   * @param currentTime Time to verify expiry against, if unset will use system time.
   */
  verify(auth, currentTime) {
    const now = TimePointSec.from(currentTime || /* @__PURE__ */ new Date()).toMilliseconds();
    return now < this.expiration.toMilliseconds() && Authority.from(auth).hasPermission(this.recover());
  }
  /**
   * Encode the proof to an `EOSIO` auth header string.
   */
  toString() {
    const data = Serializer.encode({ object: this });
    return `EOSIO ${encode(data.array, false)}`;
  }
};
__decorate([
  Struct.field(ChainId)
], IdentityProof.prototype, "chainId", void 0);
__decorate([
  Struct.field(Name)
], IdentityProof.prototype, "scope", void 0);
__decorate([
  Struct.field(TimePointSec)
], IdentityProof.prototype, "expiration", void 0);
__decorate([
  Struct.field(PermissionLevel)
], IdentityProof.prototype, "signer", void 0);
__decorate([
  Struct.field(Signature)
], IdentityProof.prototype, "signature", void 0);
IdentityProof = IdentityProof_1 = __decorate([
  Struct.type("identity_proof")
], IdentityProof);
var ProtocolVersion = 3;
var PlaceholderName = Name.from("............1");
var PlaceholderPermission = Name.from("............2");
var PlaceholderAuth = PermissionLevel.from({
  actor: PlaceholderName,
  permission: PlaceholderPermission
});
var SigningRequest = class {
  /**
   * Create a new signing request.
   * Normally not used directly, see the `create` and `from` class methods.
   */
  constructor(version, data, zlib, abiProvider, signature) {
    if (data.flags.broadcast && data.req.variantName === "identity") {
      throw new Error("Invalid request (identity request cannot be broadcast)");
    }
    this.version = version;
    this.data = data;
    this.zlib = zlib;
    this.abiProvider = abiProvider;
    this.signature = signature;
  }
  /** Return the identity ABI for given version. */
  static identityAbi(version) {
    const abi = Serializer.synthesize(this.identityType(version));
    abi.actions = [{ name: "identity", type: "identity", ricardian_contract: "" }];
    return abi;
  }
  /** Return the ABISerializableType identity type for given version. */
  static identityType(version) {
    return version === 2 ? IdentityV2 : IdentityV3;
  }
  /** Return the ABISerializableType storage type for given version. */
  static storageType(version) {
    return version === 2 ? RequestDataV2 : RequestDataV3;
  }
  /** Create a new signing request. */
  static async create(args, options = {}) {
    let actions;
    if (args.action) {
      actions = [args.action];
    } else if (args.actions) {
      actions = args.actions;
    } else if (args.transaction) {
      actions = args.transaction.actions || [];
    } else {
      actions = [];
    }
    const requiredAbis = actions.filter((action) => !Bytes.isBytes(action.data) && action.data.constructor.abiName === void 0).map((action) => Name.from(action.account));
    const abis = {};
    if (requiredAbis.length > 0) {
      const provider = options.abiProvider;
      if (!provider) {
        throw new Error("Missing abi provider");
      }
      const accountAbis = await Promise.all(requiredAbis.map((account) => provider.getAbi(account)));
      for (const [idx, abi] of accountAbis.entries()) {
        abis[requiredAbis[idx].toString()] = abi;
      }
    }
    return this.createSync(args, options, abis);
  }
  /**
   * Synchronously create a new signing request.
   * @throws If an un-encoded action with no abi def is encountered.
   */
  static createSync(args, options = {}, abis = {}) {
    let version = 2;
    const data = {};
    const encode2 = (action) => encodeAction(action, abis);
    if (args.chainId === null) {
      version = 3;
    }
    if (args.identity !== void 0) {
      if (args.identity.scope) {
        version = 3;
      }
      data.req = ["identity", this.identityType(version).from(args.identity)];
    } else if (args.action && !args.actions && !args.transaction) {
      data.req = ["action", encode2(args.action)];
    } else if (args.actions && !args.action && !args.transaction) {
      if (args.actions.length === 1) {
        data.req = ["action", encode2(args.actions[0])];
      } else {
        data.req = ["action[]", args.actions.map(encode2)];
      }
    } else if (args.transaction && !args.action && !args.actions) {
      const tx = args.transaction;
      if (tx.expiration === void 0) {
        tx.expiration = "1970-01-01T00:00:00.000";
      }
      if (tx.ref_block_num === void 0) {
        tx.ref_block_num = 0;
      }
      if (tx.ref_block_prefix === void 0) {
        tx.ref_block_prefix = 0;
      }
      if (tx.context_free_actions === void 0) {
        tx.context_free_actions = [];
      }
      if (tx.transaction_extensions === void 0) {
        tx.transaction_extensions = [];
      }
      if (tx.delay_sec === void 0) {
        tx.delay_sec = 0;
      }
      if (tx.max_cpu_usage_ms === void 0) {
        tx.max_cpu_usage_ms = 0;
      }
      if (tx.max_net_usage_words === void 0) {
        tx.max_net_usage_words = 0;
      }
      if (tx.actions === void 0) {
        tx.actions = [];
      }
      if (tx.context_free_actions === void 0) {
        tx.context_free_actions = [];
      }
      tx.actions = tx.actions.map(encode2);
      data.req = ["transaction", tx];
    } else {
      throw new TypeError("Invalid arguments: Must have exactly one of action, actions or transaction");
    }
    if (args.chainId === null) {
      data.chain_id = ChainIdVariant.from(["chain_alias", 0]);
    } else {
      data.chain_id = ChainId.from(args.chainId || ChainName.EOS).chainVariant;
    }
    const flags = RequestFlags.from(0);
    let callback = "";
    flags.broadcast = args.broadcast !== void 0 ? args.broadcast : data.req[0] !== "identity";
    if (typeof args.callback === "string") {
      callback = args.callback;
    } else if (typeof args.callback === "object") {
      callback = args.callback.url;
      flags.background = args.callback.background || false;
    }
    data.flags = flags;
    data.callback = callback;
    data.info = [];
    if (typeof args.info === "object") {
      for (const key in args.info) {
        const isOwn = Object.prototype.hasOwnProperty.call(args.info, key);
        if (isOwn) {
          let value = args.info[key];
          if (typeof value === "string") {
            value = Bytes.from(value, "utf8");
          } else if (!(value instanceof Bytes)) {
            value = Serializer.encode({ object: value });
          }
          data.info.push({ key, value });
        }
      }
    }
    if (args.chainIds && args.chainId === null) {
      const ids = args.chainIds.map((id) => ChainId.from(id).chainVariant);
      data.info.push({
        key: "chain_ids",
        value: Serializer.encode({ object: ids, type: { type: ChainIdVariant, array: true } })
      });
    }
    const req = new SigningRequest(version, this.storageType(version).from(data), options.zlib, options.abiProvider);
    if (options.signatureProvider) {
      req.sign(options.signatureProvider);
    }
    return req;
  }
  /** Creates an identity request. */
  static identity(args, options = {}) {
    let permission = {
      actor: args.account || PlaceholderName,
      permission: args.permission || PlaceholderPermission
    };
    if (permission.actor === PlaceholderName && permission.permission === PlaceholderPermission) {
      permission = void 0;
    }
    return this.createSync({
      ...args,
      identity: {
        permission,
        scope: args.scope
      },
      broadcast: false
    }, options);
  }
  /**
   * Create a request from a chain id and serialized transaction.
   * @param chainId The chain id where the transaction is valid.
   * @param serializedTransaction The serialized transaction.
   * @param options Creation options.
   */
  static fromTransaction(chainId, serializedTransaction, options = {}) {
    const id = ChainId.from(chainId);
    serializedTransaction = Bytes.from(serializedTransaction);
    const encoder = new ABIEncoder();
    encoder.writeByte(2);
    encoder.writeArray(Serializer.encode({ object: id.chainVariant }).array);
    encoder.writeByte(2);
    encoder.writeArray(Bytes.from(serializedTransaction).array);
    encoder.writeByte(RequestFlags.broadcast);
    encoder.writeByte(0);
    encoder.writeByte(0);
    return SigningRequest.fromData(encoder.getData(), options);
  }
  /** Creates a signing request from encoded `esr:` uri string. */
  static from(uri, options = {}) {
    if (typeof uri !== "string") {
      throw new Error("Invalid request uri");
    }
    const [, path] = uri.split(":");
    const data = decode(path.startsWith("//") ? path.slice(2) : path);
    return SigningRequest.fromData(data, options);
  }
  static fromData(data, options = {}) {
    data = Bytes.from(data);
    const header = data.array[0];
    const version = header & ~(1 << 7);
    if (version !== 2 && version !== 3) {
      throw new Error("Unsupported protocol version");
    }
    let payload = data.droppingFirst(1);
    if ((header & 1 << 7) !== 0) {
      if (!options.zlib) {
        throw new Error("Compressed URI needs zlib");
      }
      payload = Bytes.from(options.zlib.inflateRaw(payload.array));
    }
    const decoder = new ABIDecoder(payload.array);
    const req = Serializer.decode({ data: decoder, type: this.storageType(version) });
    let sig;
    if (decoder.canRead()) {
      sig = Serializer.decode({ data: decoder, type: RequestSignature });
    }
    return new SigningRequest(version, req, options.zlib, options.abiProvider, sig);
  }
  /**
   * Sign the request, mutating.
   * @param signatureProvider The signature provider that provides a signature for the signer.
   */
  sign(signatureProvider) {
    const message = this.getSignatureDigest();
    this.signature = RequestSignature.from(signatureProvider.sign(message));
  }
  /**
   * Get the signature digest for this request.
   */
  getSignatureDigest() {
    const prefix = [this.version, 114, 101, 113, 117, 101, 115, 116];
    return Checksum256.hash(Bytes.from(prefix).appending(this.getData()));
  }
  /**
   * Set the signature data for this request, mutating.
   * @param signer Account name of signer.
   * @param signature The signature string.
   */
  setSignature(signer, signature) {
    this.signature = RequestSignature.from({ signer, signature });
  }
  /**
   * Set the request callback, mutating.
   * @param url Where the callback should be sent.
   * @param background Whether the callback should be sent in the background.
   */
  setCallback(url, background) {
    this.data.callback = url;
    this.data.flags.background = background;
  }
  /**
   * Set broadcast flag.
   * @param broadcast Whether the transaction should be broadcast by receiver.
   */
  setBroadcast(broadcast) {
    this.data.flags.broadcast = broadcast;
  }
  /**
   * Encode this request into an `esr:` uri.
   * @argument compress Whether to compress the request data using zlib,
   *                    defaults to true if omitted and zlib is present;
   *                    otherwise false.
   * @argument slashes Whether add slashes after the protocol scheme, i.e. `esr://`.
   *                   Defaults to true.
   * @returns An esr uri string.
   */
  encode(compress, slashes, scheme = "esr:") {
    const shouldCompress = compress !== void 0 ? compress : this.zlib !== void 0;
    if (shouldCompress && this.zlib === void 0) {
      throw new Error("Need zlib to compress");
    }
    let header = this.version;
    const data = this.getData();
    const sigData = this.getSignatureData();
    let array = new Uint8Array(data.byteLength + sigData.byteLength);
    array.set(data, 0);
    array.set(sigData, data.byteLength);
    if (shouldCompress) {
      const deflated = this.zlib.deflateRaw(array);
      if (array.byteLength > deflated.byteLength) {
        header |= 1 << 7;
        array = deflated;
      }
    }
    const out = new Uint8Array(1 + array.byteLength);
    out[0] = header;
    out.set(array, 1);
    if (slashes !== false) {
      scheme += "//";
    }
    return scheme + encode(out);
  }
  /** Get the request data without header or signature. */
  getData() {
    return Serializer.encode({ object: this.data }).array;
  }
  /** Get signature data, returns an empty array if request is not signed. */
  getSignatureData() {
    if (!this.signature) {
      return new Uint8Array(0);
    }
    return Serializer.encode({ object: this.signature }).array;
  }
  /** ABI definitions required to resolve request. */
  getRequiredAbis() {
    return this.getRawActions().filter((action) => !isIdentity(action)).map((action) => action.account).filter((value, index, self) => self.indexOf(value) === index);
  }
  /** Whether TaPoS values are required to resolve request. */
  requiresTapos() {
    const tx = this.getRawTransaction();
    return !this.isIdentity() && !hasTapos(tx);
  }
  /** Resolve required ABI definitions. */
  async fetchAbis(abiProvider) {
    const required = this.getRequiredAbis();
    if (required.length > 0) {
      const provider = abiProvider || this.abiProvider;
      if (!provider) {
        throw new Error("Missing ABI provider");
      }
      const abis = /* @__PURE__ */ new Map();
      await Promise.all(required.map(async (account) => {
        abis.set(account.toString(), ABI.from(await provider.getAbi(account)));
      }));
      return abis;
    } else {
      return /* @__PURE__ */ new Map();
    }
  }
  /**
   * Decode raw actions actions to object representations.
   * @param abis ABI defenitions required to decode all actions.
   * @param signer Placeholders in actions will be resolved to signer if set.
   */
  resolveActions(abis, signer) {
    return this.getRawActions().map((rawAction) => {
      let abi;
      if (isIdentity(rawAction)) {
        abi = this.constructor.identityAbi(this.version);
      } else {
        const rawAbi = abis.get(rawAction.account.toString());
        if (!rawAbi) {
          throw new Error(`Missing ABI definition for ${rawAction.account}`);
        }
        abi = ABI.from(rawAbi);
      }
      const type = abi.getActionType(rawAction.name);
      if (!type) {
        throw new Error(`Missing type for action ${rawAction.account}:${rawAction.name} in ABI`);
      }
      let data = rawAction.decodeData(abi);
      let authorization = rawAction.authorization;
      if (signer) {
        const signerPerm = PermissionLevel.from(signer);
        const resolve = (value) => {
          if (value instanceof Name) {
            if (value.equals(PlaceholderName)) {
              return signerPerm.actor;
            } else if (value.equals(PlaceholderPermission)) {
              return signerPerm.permission;
            } else {
              return value;
            }
          } else if (Array.isArray(value)) {
            return value.map(resolve);
          } else if (typeof value === "object" && value !== null) {
            for (const key of Object.keys(value)) {
              value[key] = resolve(value[key]);
            }
            return value;
          } else {
            return value;
          }
        };
        data = resolve(data);
        authorization = authorization.map((auth) => {
          let { actor, permission } = auth;
          if (actor.equals(PlaceholderName)) {
            actor = signerPerm.actor;
          }
          if (permission.equals(PlaceholderPermission)) {
            permission = signerPerm.permission;
          }
          if (permission.equals(PlaceholderName)) {
            permission = signerPerm.permission;
          }
          return PermissionLevel.from({ actor, permission });
        });
      }
      return {
        ...rawAction,
        authorization,
        data
      };
    });
  }
  resolveTransaction(abis, signer, ctx = {}) {
    const tx = this.getRawTransaction();
    if (!this.isIdentity() && !hasTapos(tx)) {
      if (ctx.expiration !== void 0 && ctx.ref_block_num !== void 0 && ctx.ref_block_prefix !== void 0) {
        tx.expiration = TimePointSec.from(ctx.expiration);
        tx.ref_block_num = UInt16.from(ctx.ref_block_num, "truncate");
        tx.ref_block_prefix = UInt32.from(ctx.ref_block_prefix);
      } else if (ctx.block_num !== void 0 && ctx.ref_block_prefix !== void 0 && ctx.timestamp !== void 0) {
        tx.expiration = expirationTime(ctx.timestamp, ctx.expire_seconds);
        tx.ref_block_num = UInt16.from(ctx.block_num, "truncate");
        tx.ref_block_prefix = UInt32.from(ctx.ref_block_prefix);
      } else {
        throw new Error("Invalid transaction context, need either a reference block or explicit TaPoS values");
      }
    } else if (this.isIdentity() && this.version > 2) {
      tx.expiration = ctx.expiration ? TimePointSec.from(ctx.expiration) : expirationTime(ctx.timestamp, ctx.expire_seconds);
    }
    const actions = this.resolveActions(abis, signer);
    const context_free_actions = tx.context_free_actions;
    return { ...tx, context_free_actions, actions };
  }
  resolve(abis, signer, ctx = {}) {
    const tx = this.resolveTransaction(abis, signer, ctx);
    const actions = tx.actions.map((action) => {
      let abi;
      if (isIdentity(action)) {
        abi = this.constructor.identityAbi(this.version);
      } else {
        abi = abis.get(action.account.toString());
      }
      if (!abi) {
        throw new Error(`Missing ABI definition for ${action.account}`);
      }
      const type = abi.getActionType(action.name);
      const data = Serializer.encode({ object: action.data, type, abi });
      return Action.from({ ...action, data });
    });
    const transaction = Transaction.from({ ...tx, actions });
    let chainId;
    if (this.isMultiChain()) {
      if (!ctx.chainId) {
        throw new Error("Missing chosen chain ID for multi-chain request");
      }
      chainId = ChainId.from(ctx.chainId);
      const ids = this.getChainIds();
      if (ids && !ids.some((id) => chainId.equals(id))) {
        throw new Error("Trying to resolve for chain ID not defined in request");
      }
    } else {
      chainId = this.getChainId();
    }
    return new ResolvedSigningRequest(this, PermissionLevel.from(signer), transaction, tx, chainId);
  }
  /**
   * Get the id of the chain where this request is valid.
   * @returns The 32-byte chain id as hex encoded string.
   */
  getChainId() {
    return this.data.chain_id.chainId;
  }
  /**
   * Chain IDs this request is valid for, only valid for multi chain requests. Value of `null` when `isMultiChain` is true denotes any chain.
   */
  getChainIds() {
    if (!this.isMultiChain()) {
      return null;
    }
    const ids = this.getInfoKey("chain_ids", { type: ChainIdVariant, array: true });
    if (ids) {
      return ids.map((id) => id.chainId);
    }
    return null;
  }
  /**
   * Set chain IDs this request is valid for, only considered for multi chain requests.
   */
  setChainIds(ids) {
    const value = ids.map((id) => ChainId.from(id).chainVariant);
    this.setInfoKey("chain_ids", value, { type: ChainIdVariant, array: true });
  }
  /**
   * True if chainId is set to chain alias `0` which indicates that the request is valid for any chain.
   */
  isMultiChain() {
    return this.data.chain_id.variantIdx === 0 && this.data.chain_id.value.equals(ChainName.UNKNOWN);
  }
  /** Return the actions in this request with action data encoded. */
  getRawActions() {
    const req = this.data.req;
    switch (req.variantName) {
      case "action":
        return [req.value];
      case "action[]":
        return req.value;
      case "identity": {
        if (this.version === 2) {
          const id = req.value;
          let data = "0101000000000000000200000000000000";
          let authorization = [PlaceholderAuth];
          if (id.permission) {
            data = Serializer.encode({ object: id });
            authorization = [id.permission];
          }
          return [
            Action.from({
              account: "",
              name: "identity",
              authorization,
              data
            })
          ];
        } else {
          let { scope, permission } = req.value;
          if (!permission) {
            permission = PlaceholderAuth;
          }
          const data = Serializer.encode({ object: { scope, permission }, type: IdentityV3 });
          return [
            Action.from({
              account: "",
              name: "identity",
              authorization: [permission],
              data
            })
          ];
        }
      }
      case "transaction":
        return req.value.actions;
      default:
        throw new Error("Invalid signing request data");
    }
  }
  /** Unresolved transaction. */
  getRawTransaction() {
    const req = this.data.req;
    switch (req.variantName) {
      case "transaction":
        return Transaction.from({ ...req.value });
      case "action":
      case "action[]":
      case "identity":
        return Transaction.from({
          actions: this.getRawActions(),
          context_free_actions: [],
          transaction_extensions: [],
          expiration: "1970-01-01T00:00:00.000",
          ref_block_num: 0,
          ref_block_prefix: 0,
          max_cpu_usage_ms: 0,
          max_net_usage_words: 0,
          delay_sec: 0
        });
      default:
        throw new Error("Invalid signing request data");
    }
  }
  /** Whether the request is an identity request. */
  isIdentity() {
    return this.data.req.variantName === "identity";
  }
  /** Whether the request should be broadcast by signer. */
  shouldBroadcast() {
    if (this.isIdentity()) {
      return false;
    }
    return this.data.flags.broadcast;
  }
  /**
   * Present if the request is an identity request and requests a specific account.
   * @note This returns `nil` unless a specific identity has been requested,
   *       use `isIdentity` to check id requests.
   */
  getIdentity() {
    if (!this.isIdentity()) {
      return null;
    }
    const id = this.data.req.value;
    if (id.permission && !id.permission.actor.equals(PlaceholderName)) {
      return id.permission.actor;
    }
    return null;
  }
  /**
   * Present if the request is an identity request and requests a specific permission.
   * @note This returns `nil` unless a specific permission has been requested,
   *       use `isIdentity` to check id requests.
   */
  getIdentityPermission() {
    if (!this.isIdentity()) {
      return null;
    }
    const id = this.data.req.value;
    if (id.permission && !id.permission.permission.equals(PlaceholderPermission)) {
      return id.permission.permission;
    }
    return null;
  }
  /**
   * Present if the request is an identity request and requests a specific permission.
   * @note This returns `nil` unless a specific permission has been requested,
   *       use `isIdentity` to check id requests.
   */
  getIdentityScope() {
    if (!this.isIdentity() || this.version <= 2) {
      return null;
    }
    const id = this.data.req.value;
    return id.scope;
  }
  /** Get raw info dict */
  getRawInfo() {
    const rv = {};
    for (const { key, value } of this.data.info) {
      rv[key] = value;
    }
    return rv;
  }
  getRawInfoKey(key) {
    const pair = this.data.info.find((pair2) => pair2.key === key);
    if (pair) {
      return pair.value;
    }
  }
  setRawInfoKey(key, value) {
    let pair = this.data.info.find((pair2) => pair2.key === key);
    if (!pair) {
      pair = InfoPair.from({ key, value });
      this.data.info.push(pair);
    } else {
      pair.value = Bytes.from(value);
    }
  }
  /** Set a metadata key. */
  setInfoKey(key, object, type) {
    let data;
    if (typeof object === "string" && !type) {
      data = Bytes.from(object, "utf8");
    } else {
      data = Serializer.encode({ object, type });
    }
    this.setRawInfoKey(key, data);
  }
  getInfoKey(key, type) {
    const data = this.getRawInfoKey(key);
    if (data) {
      if (type) {
        return Serializer.decode({ data, type });
      } else {
        return data.utf8String;
      }
    }
  }
  /** Return a deep copy of this request. */
  clone() {
    let signature;
    if (this.signature) {
      signature = RequestSignature.from(JSON.parse(JSON.stringify(this.signature)));
    }
    const RequestData = this.constructor.storageType(this.version);
    const data = RequestData.from(JSON.parse(JSON.stringify(this.data)));
    return new SigningRequest(this.version, data, this.zlib, this.abiProvider, signature);
  }
  // Convenience methods.
  toString() {
    return this.encode();
  }
  toJSON() {
    return this.encode();
  }
};
var ResolvedSigningRequest = class {
  constructor(request, signer, transaction, resolvedTransaction, chainId) {
    this.request = request;
    this.signer = signer;
    this.transaction = transaction;
    this.resolvedTransaction = resolvedTransaction;
    this.chainId = chainId;
  }
  /** Recreate a resolved request from a callback payload. */
  static async fromPayload(payload, options = {}) {
    const request = SigningRequest.from(payload.req, options);
    const abis = await request.fetchAbis();
    return request.resolve(abis, { actor: payload.sa, permission: payload.sp }, {
      ref_block_num: payload.rbn,
      ref_block_prefix: payload.rid,
      expiration: payload.ex,
      chainId: payload.cid || request.getChainId()
    });
  }
  get serializedTransaction() {
    return Serializer.encode({ object: this.transaction }).array;
  }
  get signingDigest() {
    return this.transaction.signingDigest(this.chainId);
  }
  get signingData() {
    return this.transaction.signingData(this.chainId);
  }
  getCallback(signatures, blockNum) {
    const { callback, flags } = this.request.data;
    if (!callback || callback.length === 0) {
      return null;
    }
    if (!signatures || signatures.length === 0) {
      throw new Error("Must have at least one signature to resolve callback");
    }
    const sigs = signatures.map((sig) => Signature.from(sig));
    const payload = {
      sig: String(sigs[0]),
      tx: String(this.transaction.id),
      rbn: String(this.transaction.ref_block_num),
      rid: String(this.transaction.ref_block_prefix),
      ex: String(this.transaction.expiration),
      req: this.request.encode(),
      sa: String(this.signer.actor),
      sp: String(this.signer.permission),
      cid: String(this.chainId)
    };
    for (const [n, sig] of sigs.slice(1).entries()) {
      payload[`sig${n}`] = String(sig);
    }
    if (blockNum) {
      payload.bn = String(UInt32.from(blockNum));
    }
    const url = callback.replace(/({{([a-z0-9]+)}})/g, (_1, _2, m) => {
      return payload[m] || "";
    });
    return {
      background: flags.background,
      payload,
      url
    };
  }
  getIdentityProof(signature) {
    if (!this.request.isIdentity()) {
      throw new Error("Not a identity request");
    }
    return IdentityProof.from({
      chainId: this.chainId,
      scope: this.request.getIdentityScope(),
      expiration: this.transaction.expiration,
      signer: this.signer,
      signature
    });
  }
};
function encodeAction(action, abis) {
  if (Bytes.isBytes(action.data) || action.data.constructor.abiName !== void 0) {
    return Action.from(action);
  }
  const abi = abis[String(Name.from(action.account))];
  if (!abi) {
    throw new Error(`Missing ABI for ${action.account}`);
  }
  return Action.from(action, abi);
}
function isIdentity(action) {
  const account = Name.from(action.account);
  const name = Name.from(action.name);
  return account.rawValue.equals(0) && name.equals("identity");
}
function hasTapos(tx) {
  return !(tx.expiration.equals(0) && tx.ref_block_num.equals(0) && tx.ref_block_prefix.equals(0));
}
function expirationTime(timestamp, expireSeconds = 60) {
  const ts = TimePointSec.from(timestamp || /* @__PURE__ */ new Date());
  const exp = UInt32.from(expireSeconds);
  return TimePointSec.fromInteger(ts.value.adding(exp));
}

export {
  __decorate,
  isInstanceOf,
  Bytes,
  Checksum256,
  Checksum512,
  Checksum160,
  KeyType,
  Int,
  Int8,
  Int16,
  Int32,
  Int64,
  Int128,
  UInt8,
  UInt16,
  UInt32,
  UInt64,
  UInt128,
  VarInt,
  VarUInt,
  ABIDecoder,
  ABIEncoder,
  Struct,
  TypeAlias,
  Variant,
  Float32,
  Float64,
  Float128,
  Name,
  TimePoint,
  TimePointSec,
  BlockTimestamp,
  ABI,
  Asset,
  ExtendedAsset,
  Base58,
  PublicKey,
  Signature,
  PrivateKey,
  PermissionLevel,
  Action,
  TransactionExtension,
  TransactionHeader,
  Transaction,
  SignedTransaction,
  PackedTransaction,
  TransactionReceipt,
  Weight,
  KeyWeight,
  PermissionLevelWeight,
  WaitWeight,
  Authority,
  Serializer,
  FetchProvider,
  ChainAPI,
  HistoryAPI,
  APIError,
  APIClient,
  types$1,
  types,
  P2PClient,
  SimpleEnvelopeP2PProvider,
  pako,
  base64u,
  ChainName,
  ChainId,
  ChainAlias,
  ChainIdVariant,
  AccountName,
  PermissionName,
  IdentityV2,
  IdentityV3,
  RequestVariantV2,
  RequestVariantV3,
  RequestFlags,
  InfoPair,
  RequestDataV2,
  RequestDataV3,
  RequestSignature,
  IdentityProof,
  ProtocolVersion,
  PlaceholderName,
  PlaceholderPermission,
  PlaceholderAuth,
  SigningRequest,
  ResolvedSigningRequest
};
/*! Bundled license information:

@greymass/eosio/lib/eosio-core.m.js:
  (**
   * EOSIO Core v0.6.11
   * https://github.com/greymass/eosio-core
   *
   * @license
   * Copyright (c) 2020 FFF00 Agents AB & Greymass Inc. All Rights Reserved.
   * 
   * Redistribution and use in source and binary forms, with or without modification,
   * are permitted provided that the following conditions are met:
   * 
   *  1. Redistribution of source code must retain the above copyright notice, this
   *     list of conditions and the following disclaimer.
   * 
   *  2. Redistribution in binary form must reproduce the above copyright notice,
   *     this list of conditions and the following disclaimer in the documentation
   *     and/or other materials provided with the distribution.
   * 
   *  3. Neither the name of the copyright holder nor the names of its contributors
   *     may be used to endorse or promote products derived from this software without
   *     specific prior written permission.
   * 
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
   * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
   * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
   * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
   * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
   * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
   * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
   * OF THE POSSIBILITY OF SUCH DAMAGE.
   * 
   * YOU ACKNOWLEDGE THAT THIS SOFTWARE IS NOT DESIGNED, LICENSED OR INTENDED FOR USE
   * IN THE DESIGN, CONSTRUCTION, OPERATION OR MAINTENANCE OF ANY MILITARY FACILITY.
   *)

pako/dist/pako.esm.mjs:
  (*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) *)

eosio-signing-request/lib/esr.m.js:
  (**
   * EOSIO Signing Request v2.5.3
   * https://github.com/greymass/eosio-signing-request
   *
   * @license
   * Copyright © 2021 Greymass Inc.
   * 
   * Permission is hereby granted, free of charge, to any person
   * obtaining a copy of this software and associated documentation
   * files (the “Software”), to deal in the Software without
   * restriction, including without limitation the rights to use,
   * copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the
   * Software is furnished to do so, subject to the following
   * conditions:
   * 
   * The above copyright notice and this permission notice shall be
   * included in all copies or substantial portions of the Software.
   * 
   * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
   * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
   * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
   * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
   * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
   * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
   * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
   * OTHER DEALINGS IN THE SOFTWARE.
   * 
   * YOU ACKNOWLEDGE THAT THIS SOFTWARE IS NOT DESIGNED, LICENSED OR
   * INTENDED FOR USE IN THE DESIGN, CONSTRUCTION, OPERATION OR
   * MAINTENANCE OF ANY MILITARY FACILITY.
   *)
*/
//# sourceMappingURL=chunk-ASC2VICD.js.map
