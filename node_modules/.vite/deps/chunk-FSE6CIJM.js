import {
  AES_CBC
} from "./chunk-K7QGI3Y5.js";
import {
  APIClient,
  Bytes,
  ChainId,
  Checksum256,
  Checksum512,
  Name,
  PermissionLevel,
  PlaceholderName,
  PlaceholderPermission,
  PrivateKey,
  PublicKey,
  ResolvedSigningRequest,
  Serializer,
  Signature,
  SignedTransaction,
  SigningRequest,
  Struct,
  UInt64,
  __decorate,
  pako
} from "./chunk-ASC2VICD.js";
import {
  __commonJS,
  __toESM
} from "./chunk-GKWPUQBP.js";

// node_modules/fetch-ponyfill/build/fetch-browser.js
var require_fetch_browser = __commonJS({
  "node_modules/fetch-ponyfill/build/fetch-browser.js"(exports, module) {
    (function(global2) {
      "use strict";
      function fetchPonyfill(options) {
        var Promise2 = options && options.Promise || global2.Promise;
        var XMLHttpRequest = options && options.XMLHttpRequest || global2.XMLHttpRequest;
        return function() {
          var globalThis2 = Object.create(global2, {
            fetch: {
              value: void 0,
              writable: true
            }
          });
          (function(global3, factory) {
            typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global3.WHATWGFetch = {});
          })(this, function(exports2) {
            "use strict";
            var global3 = typeof globalThis2 !== "undefined" && globalThis2 || typeof self !== "undefined" && self || typeof global3 !== "undefined" && global3;
            var support = {
              searchParams: "URLSearchParams" in global3,
              iterable: "Symbol" in global3 && "iterator" in Symbol,
              blob: "FileReader" in global3 && "Blob" in global3 && function() {
                try {
                  new Blob();
                  return true;
                } catch (e) {
                  return false;
                }
              }(),
              formData: "FormData" in global3,
              arrayBuffer: "ArrayBuffer" in global3
            };
            function isDataView(obj) {
              return obj && DataView.prototype.isPrototypeOf(obj);
            }
            if (support.arrayBuffer) {
              var viewClasses = [
                "[object Int8Array]",
                "[object Uint8Array]",
                "[object Uint8ClampedArray]",
                "[object Int16Array]",
                "[object Uint16Array]",
                "[object Int32Array]",
                "[object Uint32Array]",
                "[object Float32Array]",
                "[object Float64Array]"
              ];
              var isArrayBufferView = ArrayBuffer.isView || function(obj) {
                return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
              };
            }
            function normalizeName(name) {
              if (typeof name !== "string") {
                name = String(name);
              }
              if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === "") {
                throw new TypeError("Invalid character in header field name");
              }
              return name.toLowerCase();
            }
            function normalizeValue(value) {
              if (typeof value !== "string") {
                value = String(value);
              }
              return value;
            }
            function iteratorFor(items) {
              var iterator = {
                next: function() {
                  var value = items.shift();
                  return { done: value === void 0, value };
                }
              };
              if (support.iterable) {
                iterator[Symbol.iterator] = function() {
                  return iterator;
                };
              }
              return iterator;
            }
            function Headers(headers) {
              this.map = {};
              if (headers instanceof Headers) {
                headers.forEach(function(value, name) {
                  this.append(name, value);
                }, this);
              } else if (Array.isArray(headers)) {
                headers.forEach(function(header) {
                  this.append(header[0], header[1]);
                }, this);
              } else if (headers) {
                Object.getOwnPropertyNames(headers).forEach(function(name) {
                  this.append(name, headers[name]);
                }, this);
              }
            }
            Headers.prototype.append = function(name, value) {
              name = normalizeName(name);
              value = normalizeValue(value);
              var oldValue = this.map[name];
              this.map[name] = oldValue ? oldValue + ", " + value : value;
            };
            Headers.prototype["delete"] = function(name) {
              delete this.map[normalizeName(name)];
            };
            Headers.prototype.get = function(name) {
              name = normalizeName(name);
              return this.has(name) ? this.map[name] : null;
            };
            Headers.prototype.has = function(name) {
              return this.map.hasOwnProperty(normalizeName(name));
            };
            Headers.prototype.set = function(name, value) {
              this.map[normalizeName(name)] = normalizeValue(value);
            };
            Headers.prototype.forEach = function(callback, thisArg) {
              for (var name in this.map) {
                if (this.map.hasOwnProperty(name)) {
                  callback.call(thisArg, this.map[name], name, this);
                }
              }
            };
            Headers.prototype.keys = function() {
              var items = [];
              this.forEach(function(value, name) {
                items.push(name);
              });
              return iteratorFor(items);
            };
            Headers.prototype.values = function() {
              var items = [];
              this.forEach(function(value) {
                items.push(value);
              });
              return iteratorFor(items);
            };
            Headers.prototype.entries = function() {
              var items = [];
              this.forEach(function(value, name) {
                items.push([name, value]);
              });
              return iteratorFor(items);
            };
            if (support.iterable) {
              Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
            }
            function consumed(body) {
              if (body.bodyUsed) {
                return Promise2.reject(new TypeError("Already read"));
              }
              body.bodyUsed = true;
            }
            function fileReaderReady(reader) {
              return new Promise2(function(resolve, reject) {
                reader.onload = function() {
                  resolve(reader.result);
                };
                reader.onerror = function() {
                  reject(reader.error);
                };
              });
            }
            function readBlobAsArrayBuffer(blob) {
              var reader = new FileReader();
              var promise = fileReaderReady(reader);
              reader.readAsArrayBuffer(blob);
              return promise;
            }
            function readBlobAsText(blob) {
              var reader = new FileReader();
              var promise = fileReaderReady(reader);
              reader.readAsText(blob);
              return promise;
            }
            function readArrayBufferAsText(buf) {
              var view = new Uint8Array(buf);
              var chars = new Array(view.length);
              for (var i = 0; i < view.length; i++) {
                chars[i] = String.fromCharCode(view[i]);
              }
              return chars.join("");
            }
            function bufferClone(buf) {
              if (buf.slice) {
                return buf.slice(0);
              } else {
                var view = new Uint8Array(buf.byteLength);
                view.set(new Uint8Array(buf));
                return view.buffer;
              }
            }
            function Body() {
              this.bodyUsed = false;
              this._initBody = function(body) {
                this.bodyUsed = this.bodyUsed;
                this._bodyInit = body;
                if (!body) {
                  this._bodyText = "";
                } else if (typeof body === "string") {
                  this._bodyText = body;
                } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
                  this._bodyBlob = body;
                } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
                  this._bodyFormData = body;
                } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                  this._bodyText = body.toString();
                } else if (support.arrayBuffer && support.blob && isDataView(body)) {
                  this._bodyArrayBuffer = bufferClone(body.buffer);
                  this._bodyInit = new Blob([this._bodyArrayBuffer]);
                } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
                  this._bodyArrayBuffer = bufferClone(body);
                } else {
                  this._bodyText = body = Object.prototype.toString.call(body);
                }
                if (!this.headers.get("content-type")) {
                  if (typeof body === "string") {
                    this.headers.set("content-type", "text/plain;charset=UTF-8");
                  } else if (this._bodyBlob && this._bodyBlob.type) {
                    this.headers.set("content-type", this._bodyBlob.type);
                  } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                    this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
                  }
                }
              };
              if (support.blob) {
                this.blob = function() {
                  var rejected = consumed(this);
                  if (rejected) {
                    return rejected;
                  }
                  if (this._bodyBlob) {
                    return Promise2.resolve(this._bodyBlob);
                  } else if (this._bodyArrayBuffer) {
                    return Promise2.resolve(new Blob([this._bodyArrayBuffer]));
                  } else if (this._bodyFormData) {
                    throw new Error("could not read FormData body as blob");
                  } else {
                    return Promise2.resolve(new Blob([this._bodyText]));
                  }
                };
                this.arrayBuffer = function() {
                  if (this._bodyArrayBuffer) {
                    var isConsumed = consumed(this);
                    if (isConsumed) {
                      return isConsumed;
                    }
                    if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
                      return Promise2.resolve(
                        this._bodyArrayBuffer.buffer.slice(
                          this._bodyArrayBuffer.byteOffset,
                          this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
                        )
                      );
                    } else {
                      return Promise2.resolve(this._bodyArrayBuffer);
                    }
                  } else {
                    return this.blob().then(readBlobAsArrayBuffer);
                  }
                };
              }
              this.text = function() {
                var rejected = consumed(this);
                if (rejected) {
                  return rejected;
                }
                if (this._bodyBlob) {
                  return readBlobAsText(this._bodyBlob);
                } else if (this._bodyArrayBuffer) {
                  return Promise2.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
                } else if (this._bodyFormData) {
                  throw new Error("could not read FormData body as text");
                } else {
                  return Promise2.resolve(this._bodyText);
                }
              };
              if (support.formData) {
                this.formData = function() {
                  return this.text().then(decode);
                };
              }
              this.json = function() {
                return this.text().then(JSON.parse);
              };
              return this;
            }
            var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
            function normalizeMethod(method) {
              var upcased = method.toUpperCase();
              return methods.indexOf(upcased) > -1 ? upcased : method;
            }
            function Request(input, options2) {
              if (!(this instanceof Request)) {
                throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
              }
              options2 = options2 || {};
              var body = options2.body;
              if (input instanceof Request) {
                if (input.bodyUsed) {
                  throw new TypeError("Already read");
                }
                this.url = input.url;
                this.credentials = input.credentials;
                if (!options2.headers) {
                  this.headers = new Headers(input.headers);
                }
                this.method = input.method;
                this.mode = input.mode;
                this.signal = input.signal;
                if (!body && input._bodyInit != null) {
                  body = input._bodyInit;
                  input.bodyUsed = true;
                }
              } else {
                this.url = String(input);
              }
              this.credentials = options2.credentials || this.credentials || "same-origin";
              if (options2.headers || !this.headers) {
                this.headers = new Headers(options2.headers);
              }
              this.method = normalizeMethod(options2.method || this.method || "GET");
              this.mode = options2.mode || this.mode || null;
              this.signal = options2.signal || this.signal;
              this.referrer = null;
              if ((this.method === "GET" || this.method === "HEAD") && body) {
                throw new TypeError("Body not allowed for GET or HEAD requests");
              }
              this._initBody(body);
              if (this.method === "GET" || this.method === "HEAD") {
                if (options2.cache === "no-store" || options2.cache === "no-cache") {
                  var reParamSearch = /([?&])_=[^&]*/;
                  if (reParamSearch.test(this.url)) {
                    this.url = this.url.replace(reParamSearch, "$1_=" + (/* @__PURE__ */ new Date()).getTime());
                  } else {
                    var reQueryString = /\?/;
                    this.url += (reQueryString.test(this.url) ? "&" : "?") + "_=" + (/* @__PURE__ */ new Date()).getTime();
                  }
                }
              }
            }
            Request.prototype.clone = function() {
              return new Request(this, { body: this._bodyInit });
            };
            function decode(body) {
              var form = new FormData();
              body.trim().split("&").forEach(function(bytes) {
                if (bytes) {
                  var split = bytes.split("=");
                  var name = split.shift().replace(/\+/g, " ");
                  var value = split.join("=").replace(/\+/g, " ");
                  form.append(decodeURIComponent(name), decodeURIComponent(value));
                }
              });
              return form;
            }
            function parseHeaders(rawHeaders) {
              var headers = new Headers();
              var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
              preProcessedHeaders.split("\r").map(function(header) {
                return header.indexOf("\n") === 0 ? header.substr(1, header.length) : header;
              }).forEach(function(line) {
                var parts = line.split(":");
                var key = parts.shift().trim();
                if (key) {
                  var value = parts.join(":").trim();
                  headers.append(key, value);
                }
              });
              return headers;
            }
            Body.call(Request.prototype);
            function Response(bodyInit, options2) {
              if (!(this instanceof Response)) {
                throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
              }
              if (!options2) {
                options2 = {};
              }
              this.type = "default";
              this.status = options2.status === void 0 ? 200 : options2.status;
              this.ok = this.status >= 200 && this.status < 300;
              this.statusText = "statusText" in options2 ? options2.statusText : "";
              this.headers = new Headers(options2.headers);
              this.url = options2.url || "";
              this._initBody(bodyInit);
            }
            Body.call(Response.prototype);
            Response.prototype.clone = function() {
              return new Response(this._bodyInit, {
                status: this.status,
                statusText: this.statusText,
                headers: new Headers(this.headers),
                url: this.url
              });
            };
            Response.error = function() {
              var response = new Response(null, { status: 0, statusText: "" });
              response.type = "error";
              return response;
            };
            var redirectStatuses = [301, 302, 303, 307, 308];
            Response.redirect = function(url, status) {
              if (redirectStatuses.indexOf(status) === -1) {
                throw new RangeError("Invalid status code");
              }
              return new Response(null, { status, headers: { location: url } });
            };
            exports2.DOMException = global3.DOMException;
            try {
              new exports2.DOMException();
            } catch (err) {
              exports2.DOMException = function(message, name) {
                this.message = message;
                this.name = name;
                var error = Error(message);
                this.stack = error.stack;
              };
              exports2.DOMException.prototype = Object.create(Error.prototype);
              exports2.DOMException.prototype.constructor = exports2.DOMException;
            }
            function fetch2(input, init) {
              return new Promise2(function(resolve, reject) {
                var request = new Request(input, init);
                if (request.signal && request.signal.aborted) {
                  return reject(new exports2.DOMException("Aborted", "AbortError"));
                }
                var xhr = new XMLHttpRequest();
                function abortXhr() {
                  xhr.abort();
                }
                xhr.onload = function() {
                  var options2 = {
                    status: xhr.status,
                    statusText: xhr.statusText,
                    headers: parseHeaders(xhr.getAllResponseHeaders() || "")
                  };
                  options2.url = "responseURL" in xhr ? xhr.responseURL : options2.headers.get("X-Request-URL");
                  var body = "response" in xhr ? xhr.response : xhr.responseText;
                  setTimeout(function() {
                    resolve(new Response(body, options2));
                  }, 0);
                };
                xhr.onerror = function() {
                  setTimeout(function() {
                    reject(new TypeError("Network request failed"));
                  }, 0);
                };
                xhr.ontimeout = function() {
                  setTimeout(function() {
                    reject(new TypeError("Network request failed"));
                  }, 0);
                };
                xhr.onabort = function() {
                  setTimeout(function() {
                    reject(new exports2.DOMException("Aborted", "AbortError"));
                  }, 0);
                };
                function fixUrl(url) {
                  try {
                    return url === "" && global3.location.href ? global3.location.href : url;
                  } catch (e) {
                    return url;
                  }
                }
                xhr.open(request.method, fixUrl(request.url), true);
                if (request.credentials === "include") {
                  xhr.withCredentials = true;
                } else if (request.credentials === "omit") {
                  xhr.withCredentials = false;
                }
                if ("responseType" in xhr) {
                  if (support.blob) {
                    xhr.responseType = "blob";
                  } else if (support.arrayBuffer && request.headers.get("Content-Type") && request.headers.get("Content-Type").indexOf("application/octet-stream") !== -1) {
                    xhr.responseType = "arraybuffer";
                  }
                }
                if (init && typeof init.headers === "object" && !(init.headers instanceof Headers)) {
                  Object.getOwnPropertyNames(init.headers).forEach(function(name) {
                    xhr.setRequestHeader(name, normalizeValue(init.headers[name]));
                  });
                } else {
                  request.headers.forEach(function(value, name) {
                    xhr.setRequestHeader(name, value);
                  });
                }
                if (request.signal) {
                  request.signal.addEventListener("abort", abortXhr);
                  xhr.onreadystatechange = function() {
                    if (xhr.readyState === 4) {
                      request.signal.removeEventListener("abort", abortXhr);
                    }
                  };
                }
                xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
              });
            }
            fetch2.polyfill = true;
            if (!global3.fetch) {
              global3.fetch = fetch2;
              global3.Headers = Headers;
              global3.Request = Request;
              global3.Response = Response;
            }
            exports2.Headers = Headers;
            exports2.Request = Request;
            exports2.Response = Response;
            exports2.fetch = fetch2;
            Object.defineProperty(exports2, "__esModule", { value: true });
          });
          return {
            fetch: globalThis2.fetch,
            Headers: globalThis2.Headers,
            Request: globalThis2.Request,
            Response: globalThis2.Response,
            DOMException: globalThis2.DOMException
          };
        }();
      }
      if (typeof define === "function" && define.amd) {
        define(function() {
          return fetchPonyfill;
        });
      } else if (typeof exports === "object") {
        module.exports = fetchPonyfill;
      } else {
        global2.fetchPonyfill = fetchPonyfill;
      }
    })(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof global !== "undefined" ? global : exports);
  }
});

// node_modules/isomorphic-ws/browser.js
var require_browser = __commonJS({
  "node_modules/isomorphic-ws/browser.js"(exports, module) {
    var ws = null;
    if (typeof WebSocket !== "undefined") {
      ws = WebSocket;
    } else if (typeof MozWebSocket !== "undefined") {
      ws = MozWebSocket;
    } else if (typeof global !== "undefined") {
      ws = global.WebSocket || global.MozWebSocket;
    } else if (typeof window !== "undefined") {
      ws = window.WebSocket || window.MozWebSocket;
    } else if (typeof self !== "undefined") {
      ws = self.WebSocket || self.MozWebSocket;
    }
    module.exports = ws;
  }
});

// node_modules/anchor-link/lib/anchor-link.m.js
var import_fetch_ponyfill = __toESM(require_fetch_browser());

// node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/esm-browser/regex.js
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

// node_modules/uuid/dist/esm-browser/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default = validate;

// node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).substr(1));
}
var i;
function stringify(arr) {
  var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  if (!validate_default(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
var stringify_default = stringify;

// node_modules/uuid/dist/esm-browser/parse.js
function parse(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  var v;
  var arr = new Uint8Array(16);
  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 255;
  arr[2] = v >>> 8 & 255;
  arr[3] = v & 255;
  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 255;
  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 255;
  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 255;
  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v / 4294967296 & 255;
  arr[12] = v >>> 24 & 255;
  arr[13] = v >>> 16 & 255;
  arr[14] = v >>> 8 & 255;
  arr[15] = v & 255;
  return arr;
}
var parse_default = parse;

// node_modules/uuid/dist/esm-browser/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  var bytes = [];
  for (var i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }
  return bytes;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35_default(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === "string") {
      value = stringToBytes(value);
    }
    if (typeof namespace === "string") {
      namespace = parse_default(namespace);
    }
    if (namespace.length !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    var bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (var i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }
      return buf;
    }
    return stringify_default(bytes);
  }
  try {
    generateUUID.name = name;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}

// node_modules/uuid/dist/esm-browser/md5.js
function md5(bytes) {
  if (typeof bytes === "string") {
    var msg = unescape(encodeURIComponent(bytes));
    bytes = new Uint8Array(msg.length);
    for (var i = 0; i < msg.length; ++i) {
      bytes[i] = msg.charCodeAt(i);
    }
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
function md5ToHexEncodedArray(input) {
  var output = [];
  var length32 = input.length * 32;
  var hexTab = "0123456789abcdef";
  for (var i = 0; i < length32; i += 8) {
    var x = input[i >> 5] >>> i % 32 & 255;
    var hex = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);
    output.push(hex);
  }
  return output;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x, len) {
  x[len >> 5] |= 128 << len % 32;
  x[getOutputLength(len) - 1] = len;
  var a = 1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d = 271733878;
  for (var i = 0; i < x.length; i += 16) {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }
  return [a, b, c, d];
}
function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }
  var length8 = input.length * 8;
  var output = new Uint32Array(getOutputLength(length8));
  for (var i = 0; i < length8; i += 8) {
    output[i >> 5] |= (input[i / 8] & 255) << i % 32;
  }
  return output;
}
function safeAdd(x, y) {
  var lsw = (x & 65535) + (y & 65535);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}
function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}
function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}
function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}
var md5_default = md5;

// node_modules/uuid/dist/esm-browser/v3.js
var v3 = v35_default("v3", 48, md5_default);

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (var i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return stringify_default(rnds);
}
var v4_default = v4;

// node_modules/uuid/dist/esm-browser/sha1.js
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;
    case 1:
      return x ^ y ^ z;
    case 2:
      return x & y ^ x & z ^ y & z;
    case 3:
      return x ^ y ^ z;
  }
}
function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}
function sha1(bytes) {
  var K = [1518500249, 1859775393, 2400959708, 3395469782];
  var H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes === "string") {
    var msg = unescape(encodeURIComponent(bytes));
    bytes = [];
    for (var i = 0; i < msg.length; ++i) {
      bytes.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes)) {
    bytes = Array.prototype.slice.call(bytes);
  }
  bytes.push(128);
  var l = bytes.length / 4 + 2;
  var N = Math.ceil(l / 16);
  var M = new Array(N);
  for (var _i = 0; _i < N; ++_i) {
    var arr = new Uint32Array(16);
    for (var j = 0; j < 16; ++j) {
      arr[j] = bytes[_i * 64 + j * 4] << 24 | bytes[_i * 64 + j * 4 + 1] << 16 | bytes[_i * 64 + j * 4 + 2] << 8 | bytes[_i * 64 + j * 4 + 3];
    }
    M[_i] = arr;
  }
  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (var _i2 = 0; _i2 < N; ++_i2) {
    var W = new Uint32Array(80);
    for (var t = 0; t < 16; ++t) {
      W[t] = M[_i2][t];
    }
    for (var _t = 16; _t < 80; ++_t) {
      W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);
    }
    var a = H[0];
    var b = H[1];
    var c = H[2];
    var d = H[3];
    var e = H[4];
    for (var _t2 = 0; _t2 < 80; ++_t2) {
      var s = Math.floor(_t2 / 20);
      var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[_t2] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }
    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }
  return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];
}
var sha1_default = sha1;

// node_modules/uuid/dist/esm-browser/v5.js
var v5 = v35_default("v5", 80, sha1_default);

// node_modules/anchor-link/lib/anchor-link.m.js
var import_isomorphic_ws = __toESM(require_browser());
var CancelError = class extends Error {
  constructor(reason) {
    super(`User canceled request ${reason ? "(" + reason + ")" : ""}`);
    this.code = "E_CANCEL";
  }
};
var IdentityError = class extends Error {
  constructor(reason) {
    super(`Unable to verify identity ${reason ? "(" + reason + ")" : ""}`);
    this.code = "E_IDENTITY";
  }
};
var SessionError = class extends Error {
  constructor(reason, code, session) {
    super(reason);
    this.code = code;
    this.session = session;
  }
};
var LinkOptions;
(function(LinkOptions2) {
  LinkOptions2.defaults = {
    service: "https://cb.anchor.link",
    verifyProofs: false,
    encodeChainIds: true
  };
})(LinkOptions || (LinkOptions = {}));
var SealedMessage = class SealedMessage2 extends Struct {
};
__decorate([
  Struct.field("public_key")
], SealedMessage.prototype, "from", void 0);
__decorate([
  Struct.field("uint64")
], SealedMessage.prototype, "nonce", void 0);
__decorate([
  Struct.field("bytes")
], SealedMessage.prototype, "ciphertext", void 0);
__decorate([
  Struct.field("uint32")
], SealedMessage.prototype, "checksum", void 0);
SealedMessage = __decorate([
  Struct.type("sealed_message")
], SealedMessage);
var LinkCreate = class LinkCreate2 extends Struct {
};
__decorate([
  Struct.field("name")
], LinkCreate.prototype, "session_name", void 0);
__decorate([
  Struct.field("public_key")
], LinkCreate.prototype, "request_key", void 0);
__decorate([
  Struct.field("string", { extension: true })
], LinkCreate.prototype, "user_agent", void 0);
LinkCreate = __decorate([
  Struct.type("link_create")
], LinkCreate);
var LinkInfo = class LinkInfo2 extends Struct {
};
__decorate([
  Struct.field("time_point_sec")
], LinkInfo.prototype, "expiration", void 0);
LinkInfo = __decorate([
  Struct.type("link_info")
], LinkInfo);
var fetch = (0, import_fetch_ponyfill.default)().fetch;
function sealMessage(message, privateKey, publicKey, nonce) {
  const secret = privateKey.sharedSecret(publicKey);
  if (!nonce) {
    nonce = UInt64.random();
  }
  const key = Checksum512.hash(Serializer.encode({ object: nonce }).appending(secret.array));
  const cbc = new AES_CBC(key.array.slice(0, 32), key.array.slice(32, 48));
  const ciphertext = Bytes.from(cbc.encrypt(Bytes.from(message, "utf8").array));
  const checksumView = new DataView(Checksum256.hash(key.array).array.buffer);
  const checksum = checksumView.getUint32(0, true);
  return SealedMessage.from({
    from: privateKey.toPublic(),
    nonce,
    ciphertext,
    checksum
  });
}
function sessionMetadata(payload, request) {
  const metadata = {
    // backwards compat, can be removed next major release
    sameDevice: request.getRawInfo()["return_path"] !== void 0
  };
  if (payload.link_meta) {
    try {
      const parsed = JSON.parse(payload.link_meta);
      for (const key of Object.keys(parsed)) {
        metadata[snakeToCamel(key)] = parsed[key];
      }
    } catch (error) {
      logWarn("Unable to parse link metadata", error, payload.link_meta);
    }
  }
  return metadata;
}
function snakeToPascal(name) {
  return name.split("_").map((v) => (v[0] ? v[0].toUpperCase() : "_") + v.slice(1)).join("");
}
function snakeToCamel(name) {
  const pascal = snakeToPascal(name);
  return pascal[0].toLowerCase() + pascal.slice(1);
}
function logWarn(...args) {
  console.warn("[anchor-link]", ...args);
}
var LinkSession = class {
  /** @internal */
  constructor() {
  }
  // eslint-disable-line @typescript-eslint/no-empty-function
  /**
   * Convenience, remove this session from associated [[Link]] storage if set.
   * Equivalent to:
   * ```ts
   * session.link.removeSession(session.identifier, session.auth, session.chainId)
   * ```
   */
  async remove() {
    if (this.link.storage) {
      await this.link.removeSession(this.identifier, this.auth, this.chainId);
    }
  }
  /** API client for the chain this session is valid on. */
  get client() {
    return this.link.getChain(this.chainId).client;
  }
  /** Restore a previously serialized session. */
  static restore(link, data) {
    switch (data.type) {
      case "channel":
        return new LinkChannelSession(link, data.data, data.metadata);
      case "fallback":
        return new LinkFallbackSession(link, data.data, data.metadata);
      default:
        throw new Error("Unable to restore, session data invalid");
    }
  }
};
var LinkChannelSession = class extends LinkSession {
  constructor(link, data, metadata) {
    super();
    this.type = "channel";
    this.timeout = 2 * 60 * 1e3;
    this.link = link;
    this.chainId = ChainId.from(data.chainId);
    this.auth = PermissionLevel.from(data.auth);
    this.publicKey = PublicKey.from(data.publicKey);
    this.identifier = Name.from(data.identifier);
    const privateKey = PrivateKey.from(data.requestKey);
    this.channelKey = PublicKey.from(data.channel.key);
    this.channelUrl = data.channel.url;
    this.channelName = data.channel.name;
    this.encrypt = (request) => {
      return sealMessage(request.encode(true, false), privateKey, this.channelKey);
    };
    this.metadata = {
      ...metadata || {},
      timeout: this.timeout,
      name: this.channelName,
      request_key: privateKey.toPublic()
    };
    this.serialize = () => ({
      type: "channel",
      data: {
        ...data,
        channel: {
          url: this.channelUrl,
          key: this.channelKey,
          name: this.channelName
        }
      },
      metadata: this.metadata
    });
  }
  onSuccess(request, result) {
    if (this.link.transport.onSuccess) {
      this.link.transport.onSuccess(request, result);
    }
  }
  onFailure(request, error) {
    if (this.link.transport.onFailure) {
      this.link.transport.onFailure(request, error);
    }
  }
  onRequest(request, cancel) {
    const info = LinkInfo.from({
      expiration: new Date(Date.now() + this.timeout)
    });
    if (this.link.transport.onSessionRequest) {
      this.link.transport.onSessionRequest(this, request, cancel);
    }
    const timer = setTimeout(() => {
      cancel(new SessionError("Wallet did not respond in time", "E_TIMEOUT", this));
    }, this.timeout);
    request.setInfoKey("link", info);
    let payloadSent = false;
    const payload = Serializer.encode({ object: this.encrypt(request) });
    if (this.link.transport.sendSessionPayload) {
      try {
        payloadSent = this.link.transport.sendSessionPayload(payload, this);
      } catch (error) {
        logWarn("Unexpected error when transport tried to send session payload", error);
      }
    }
    if (payloadSent) {
      return;
    }
    fetch(this.channelUrl, {
      method: "POST",
      headers: {
        "X-Buoy-Soft-Wait": "10"
      },
      body: payload.array
    }).then((response) => {
      if (Math.floor(response.status / 100) !== 2) {
        clearTimeout(timer);
        if (response.status === 202) {
          logWarn("Missing delivery ack from session channel");
        }
        cancel(new SessionError("Unable to push message", "E_DELIVERY", this));
      }
    }).catch((error) => {
      clearTimeout(timer);
      cancel(new SessionError(`Unable to reach link service (${error.message || String(error)})`, "E_DELIVERY", this));
    });
  }
  addLinkInfo(request) {
    const createInfo = LinkCreate.from({
      session_name: this.identifier,
      request_key: this.metadata.request_key,
      user_agent: this.link.getUserAgent()
    });
    request.setInfoKey("link", createInfo);
  }
  prepare(request) {
    if (this.link.transport.prepare) {
      return this.link.transport.prepare(request, this);
    }
    return Promise.resolve(request);
  }
  showLoading() {
    if (this.link.transport.showLoading) {
      return this.link.transport.showLoading();
    }
  }
  recoverError(error, request) {
    if (this.link.transport.recoverError) {
      return this.link.transport.recoverError(error, request);
    }
    return false;
  }
  makeSignatureProvider() {
    return this.link.makeSignatureProvider([this.publicKey.toString()], this.chainId, this);
  }
  async transact(args, options) {
    const res = await this.link.transact(args, { ...options, chain: this.chainId }, this);
    if (res.payload.link_ch && res.payload.link_key && res.payload.link_name) {
      try {
        const metadata = {
          ...this.metadata,
          ...sessionMetadata(res.payload, res.resolved.request)
        };
        this.channelUrl = res.payload.link_ch;
        this.channelKey = PublicKey.from(res.payload.link_key);
        this.channelName = res.payload.link_name;
        metadata.name = res.payload.link_name;
        this.metadata = metadata;
      } catch (error) {
        logWarn("Unable to recover link session", error);
      }
    }
    return res;
  }
};
var LinkFallbackSession = class extends LinkSession {
  constructor(link, data, metadata) {
    super();
    this.type = "fallback";
    this.link = link;
    this.auth = PermissionLevel.from(data.auth);
    this.publicKey = PublicKey.from(data.publicKey);
    this.chainId = ChainId.from(data.chainId);
    this.metadata = metadata || {};
    this.identifier = Name.from(data.identifier);
    this.serialize = () => ({
      type: this.type,
      data,
      metadata: this.metadata
    });
  }
  onSuccess(request, result) {
    if (this.link.transport.onSuccess) {
      this.link.transport.onSuccess(request, result);
    }
  }
  onFailure(request, error) {
    if (this.link.transport.onFailure) {
      this.link.transport.onFailure(request, error);
    }
  }
  onRequest(request, cancel) {
    if (this.link.transport.onSessionRequest) {
      this.link.transport.onSessionRequest(this, request, cancel);
    } else {
      this.link.transport.onRequest(request, cancel);
    }
  }
  prepare(request) {
    if (this.link.transport.prepare) {
      return this.link.transport.prepare(request, this);
    }
    return Promise.resolve(request);
  }
  showLoading() {
    if (this.link.transport.showLoading) {
      return this.link.transport.showLoading();
    }
  }
  makeSignatureProvider() {
    return this.link.makeSignatureProvider([this.publicKey.toString()], this.chainId, this);
  }
  transact(args, options) {
    return this.link.transact(args, { ...options, chain: this.chainId }, this);
  }
};
var BuoyCallbackService = class {
  constructor(address) {
    this.address = address.trim().replace(/\/$/, "");
  }
  create() {
    const url = `${this.address}/${v4_default()}`;
    return new BuoyCallback(url);
  }
};
var BuoyCallback = class {
  constructor(url) {
    this.url = url;
    this.ctx = {};
  }
  wait() {
    if (this.url.includes("hyperbuoy")) {
      return pollForCallback(this.url, this.ctx);
    } else {
      return waitForCallback(this.url, this.ctx);
    }
  }
  cancel() {
    if (this.ctx.cancel) {
      this.ctx.cancel();
    }
  }
};
function waitForCallback(url, ctx) {
  return new Promise((resolve, reject) => {
    let active = true;
    let retries = 0;
    const socketUrl = url.replace(/^http/, "ws");
    const handleResponse = (response) => {
      try {
        resolve(JSON.parse(response));
      } catch (error) {
        error.message = "Unable to parse callback JSON: " + error.message;
        reject(error);
      }
    };
    const connect = () => {
      const socket = new import_isomorphic_ws.default(socketUrl);
      ctx.cancel = () => {
        active = false;
        if (socket.readyState === import_isomorphic_ws.default.OPEN || socket.readyState === import_isomorphic_ws.default.CONNECTING) {
          socket.close();
        }
      };
      socket.onmessage = (event) => {
        active = false;
        if (socket.readyState === import_isomorphic_ws.default.OPEN) {
          socket.close();
        }
        if (typeof Blob !== "undefined" && event.data instanceof Blob) {
          const reader = new FileReader();
          reader.onload = () => {
            handleResponse(reader.result);
          };
          reader.onerror = (error) => {
            reject(error);
          };
          reader.readAsText(event.data);
        } else {
          if (typeof event.data === "string") {
            handleResponse(event.data);
          } else {
            handleResponse(event.data.toString());
          }
        }
      };
      socket.onopen = () => {
        retries = 0;
      };
      socket.onclose = () => {
        if (active) {
          setTimeout(connect, backoff(retries++));
        }
      };
    };
    connect();
  });
}
async function pollForCallback(url, ctx) {
  let active = true;
  ctx.cancel = () => {
    active = false;
  };
  while (active) {
    try {
      const res = await fetch(url);
      if (res.status === 408) {
        continue;
      } else if (res.status === 200) {
        return await res.json();
      } else {
        throw new Error(`HTTP ${res.status}: ${res.statusText}`);
      }
    } catch (error) {
      logWarn("Unexpected hyperbuoy error", error);
    }
    await sleep(1e3);
  }
  return null;
}
function backoff(tries) {
  return Math.min(Math.pow(tries * 10, 2), 10 * 1e3);
}
function sleep(ms) {
  return new Promise((resolve) => {
    setTimeout(resolve, ms);
  });
}
var LinkChain = class {
  /** @internal */
  constructor(chainId, clientOrUrl) {
    this.abiCache = /* @__PURE__ */ new Map();
    this.pendingAbis = /* @__PURE__ */ new Map();
    this.chainId = ChainId.from(chainId);
    this.client = typeof clientOrUrl === "string" ? new APIClient({ url: clientOrUrl }) : clientOrUrl;
  }
  /**
   * Fetch the ABI for given account, cached.
   * @internal
   */
  async getAbi(account) {
    const key = String(account);
    let rv = this.abiCache.get(key);
    if (!rv) {
      let getAbi = this.pendingAbis.get(key);
      if (!getAbi) {
        getAbi = this.client.v1.chain.get_abi(account);
        this.pendingAbis.set(key, getAbi);
      }
      rv = (await getAbi).abi;
      this.pendingAbis.delete(key);
      if (rv) {
        this.abiCache.set(key, rv);
      }
    }
    return rv;
  }
};
var Link = class {
  /** Create a new link instance. */
  constructor(options) {
    if (typeof options !== "object") {
      throw new TypeError("Missing options object");
    }
    if (!options.transport) {
      throw new TypeError("options.transport is required");
    }
    let chains = options.chains || [];
    if (options.chainId && options.client) {
      if (options.chains.length > 0) {
        throw new TypeError("options.chainId and options.client are deprecated and cannot be used together with options.chains");
      }
      chains = [{ chainId: options.chainId, nodeUrl: options.client }];
    }
    if (chains.length === 0) {
      throw new TypeError("options.chains is required");
    }
    this.chains = chains.map((chain) => {
      if (chain instanceof LinkChain) {
        return chain;
      }
      if (!chain.chainId) {
        throw new TypeError("options.chains[].chainId is required");
      }
      if (!chain.nodeUrl) {
        throw new TypeError("options.chains[].nodeUrl is required");
      }
      return new LinkChain(chain.chainId, chain.nodeUrl);
    });
    if (options.service === void 0 || typeof options.service === "string") {
      this.callbackService = new BuoyCallbackService(options.service || LinkOptions.defaults.service);
    } else {
      this.callbackService = options.service;
    }
    this.transport = options.transport;
    if (options.storage !== null) {
      this.storage = options.storage || this.transport.storage;
    }
    this.verifyProofs = options.verifyProofs !== void 0 ? options.verifyProofs : LinkOptions.defaults.verifyProofs;
    this.encodeChainIds = options.encodeChainIds !== void 0 ? options.encodeChainIds : LinkOptions.defaults.encodeChainIds;
  }
  /**
   * The APIClient instance for communicating with the node.
   * @note This returns the first APIClient when link is configured with multiple chains.
   */
  get client() {
    return this.chains[0].client;
  }
  /**
   * Return a [[LinkChain]] object for given chainId or chain reference.
   * @throws If this link instance has no configured chain for given reference.
   * @internal
   */
  getChain(chain) {
    if (chain instanceof LinkChain) {
      return chain;
    }
    if (typeof chain === "number") {
      const rv2 = this.chains[chain];
      if (!rv2) {
        throw new Error(`Invalid chain index: ${chain}`);
      }
      return rv2;
    }
    const id = ChainId.from(chain);
    const rv = this.chains.find((c) => c.chainId.equals(id));
    if (!rv) {
      throw new Error(`Unsupported chain: ${id}`);
    }
    return rv;
  }
  /**
   * Create a SigningRequest instance configured for this link.
   * @internal
   */
  async createRequest(args, chain, transport) {
    const t = transport || this.transport;
    let request;
    if (chain || this.chains.length === 1) {
      const c = chain || this.chains[0];
      request = await SigningRequest.create({
        ...args,
        chainId: c.chainId,
        broadcast: false
      }, { abiProvider: c, zlib: pako });
    } else {
      request = await SigningRequest.create(
        {
          ...args,
          chainId: null,
          chainIds: this.encodeChainIds ? this.chains.map((c) => c.chainId) : void 0,
          broadcast: false
        },
        // abi's will be pulled from the first chain and assumed to be identical on all chains
        { abiProvider: this.chains[0], zlib: pako }
      );
    }
    if (t.prepare) {
      request = await t.prepare(request);
    }
    const callback = this.callbackService.create();
    request.setCallback(callback.url, true);
    return { request, callback };
  }
  /**
   * Send a SigningRequest instance using this link.
   * @internal
   */
  async sendRequest(request, callback, chain, transport, broadcast = false) {
    const t = transport || this.transport;
    try {
      const linkUrl = request.data.callback;
      if (linkUrl !== callback.url) {
        throw new Error("Invalid request callback");
      }
      if (request.data.flags.broadcast === true || request.data.flags.background === false) {
        throw new Error("Invalid request flags");
      }
      let done = false;
      const cancel = new Promise((resolve, reject) => {
        t.onRequest(request, (reason) => {
          if (done) {
            return;
          }
          const error = typeof reason === "string" ? new CancelError(reason) : reason;
          if (t.recoverError && t.recoverError(error, request) === true) {
            return;
          }
          callback.cancel();
          reject(error);
        });
      });
      const callbackResponse = await Promise.race([callback.wait(), cancel]);
      done = true;
      if (typeof callbackResponse.rejected === "string") {
        throw new CancelError(callbackResponse.rejected);
      }
      const payload = callbackResponse;
      const signer = PermissionLevel.from({
        actor: payload.sa,
        permission: payload.sp
      });
      const signatures = Object.keys(payload).filter((key) => key.startsWith("sig") && key !== "sig0").map((key) => Signature.from(payload[key]));
      let c;
      if (!chain && this.chains.length > 1) {
        if (!payload.cid) {
          throw new Error("Multi chain response payload must specify resolved chain id (cid)");
        }
        c = this.getChain(payload.cid);
      } else {
        c = chain || this.getChain(0);
        if (payload.cid && !c.chainId.equals(payload.cid)) {
          throw new Error("Got response for wrong chain id");
        }
      }
      const resolved = await ResolvedSigningRequest.fromPayload(payload, {
        zlib: pako,
        abiProvider: c
      });
      const cosignerSig = resolved.request.getInfoKey("cosig", {
        type: Signature,
        array: true
      });
      if (cosignerSig) {
        signatures.unshift(...cosignerSig);
      }
      const result = {
        resolved,
        chain: c,
        transaction: resolved.transaction,
        resolvedTransaction: resolved.resolvedTransaction,
        signatures,
        payload,
        signer
      };
      if (broadcast) {
        const signedTx = SignedTransaction.from({
          ...resolved.transaction,
          signatures
        });
        const res = await c.client.v1.chain.push_transaction(signedTx);
        result.processed = res.processed;
      }
      if (t.onSuccess) {
        t.onSuccess(request, result);
      }
      return result;
    } catch (error) {
      if (t.onFailure) {
        t.onFailure(request, error);
      }
      throw error;
    }
  }
  /**
   * Sign and optionally broadcast a EOSIO transaction, action or actions.
   *
   * Example:
   *
   * ```ts
   * let result = await myLink.transact({transaction: myTx})
   * ```
   *
   * @param args The action, actions or transaction to use.
   * @param options Options for this transact call.
   * @param transport Transport override, for internal use.
   */
  async transact(args, options, transport) {
    const o = options || {};
    const t = transport || this.transport;
    const c = o.chain !== void 0 ? this.getChain(o.chain) : void 0;
    const broadcast = o.broadcast !== false;
    const noModify = o.noModify !== void 0 ? o.noModify : !broadcast;
    if (t && t.showLoading) {
      t.showLoading();
    }
    const anyArgs = args;
    if (args.actions && (anyArgs.expiration || anyArgs.ref_block_num || anyArgs.ref_block_prefix || anyArgs.max_net_usage_words || anyArgs.max_cpu_usage_ms || anyArgs.delay_sec)) {
      args = {
        transaction: {
          expiration: "1970-01-01T00:00:00",
          ref_block_num: 0,
          ref_block_prefix: 0,
          max_net_usage_words: 0,
          max_cpu_usage_ms: 0,
          delay_sec: 0,
          ...anyArgs
        }
      };
    }
    const { request, callback } = await this.createRequest(args, c, t);
    if (noModify) {
      request.setInfoKey("no_modify", true, "bool");
    }
    const result = await this.sendRequest(request, callback, c, t, broadcast);
    return result;
  }
  /**
   * Send an identity request and verify the identity proof if [[LinkOptions.verifyProofs]] is true.
   * @param args.scope The scope of the identity request.
   * @param args.requestPermission Optional request permission if the request is for a specific account or permission.
   * @param args.info Metadata to add to the request.
   * @note This is for advanced use-cases, you probably want to use [[Link.login]] instead.
   */
  async identify(args) {
    const { request, callback } = await this.createRequest({
      identity: { permission: args.requestPermission, scope: args.scope },
      info: args.info
    });
    const res = await this.sendRequest(request, callback);
    if (!res.resolved.request.isIdentity()) {
      throw new IdentityError("Unexpected response");
    }
    let account;
    const proof = res.resolved.getIdentityProof(res.signatures[0]);
    if (this.verifyProofs) {
      account = await res.chain.client.v1.chain.get_account(res.signer.actor);
      if (!account) {
        throw new IdentityError(`Signature from unknown account: ${proof.signer.actor}`);
      }
      const accountPermission = account.permissions.find(({ perm_name }) => proof.signer.permission.equals(perm_name));
      if (!accountPermission) {
        throw new IdentityError(`${proof.signer.actor} signed for unknown permission: ${proof.signer.permission}`);
      }
      const proofValid = proof.verify(accountPermission.required_auth, account.head_block_time);
      if (!proofValid) {
        throw new IdentityError(`Invalid identify proof for: ${proof.signer}`);
      }
    }
    if (args.requestPermission) {
      const perm = PermissionLevel.from(args.requestPermission);
      if (!perm.actor.equals(PlaceholderName) && !perm.actor.equals(proof.signer.actor) || !perm.permission.equals(PlaceholderPermission) && !perm.permission.equals(proof.signer.permission)) {
        throw new IdentityError(`Identity proof singed by ${proof.signer}, expected: ${formatAuth(perm)} `);
      }
    }
    return {
      ...res,
      account,
      proof
    };
  }
  /**
   * Login and create a persistent session.
   * @param identifier The session identifier, an EOSIO name (`[a-z1-5]{1,12}`).
   *                   Should be set to the contract account if applicable.
   */
  async login(identifier) {
    const privateKey = PrivateKey.generate("K1");
    const requestKey = privateKey.toPublic();
    const createInfo = LinkCreate.from({
      session_name: identifier,
      request_key: requestKey,
      user_agent: this.getUserAgent()
    });
    const res = await this.identify({
      scope: identifier,
      info: {
        link: createInfo,
        scope: identifier
      }
    });
    const metadata = sessionMetadata(res.payload, res.resolved.request);
    const signerKey = res.proof.recover();
    let session;
    if (res.payload.link_ch && res.payload.link_key && res.payload.link_name) {
      session = new LinkChannelSession(this, {
        identifier,
        chainId: res.chain.chainId,
        auth: res.signer,
        publicKey: signerKey,
        channel: {
          url: res.payload.link_ch,
          key: res.payload.link_key,
          name: res.payload.link_name
        },
        requestKey: privateKey
      }, metadata);
    } else {
      session = new LinkFallbackSession(this, {
        identifier,
        chainId: res.chain.chainId,
        auth: res.signer,
        publicKey: signerKey
      }, metadata);
    }
    await this.storeSession(session);
    return {
      ...res,
      session
    };
  }
  /**
   * Restore previous session, use [[login]] to create a new session.
   * @param identifier The session identifier, must be same as what was used when creating the session with [[login]].
   * @param auth A specific session auth to restore, if omitted the most recently used session will be restored.
   * @param chainId If given function will only consider that specific chain when restoring session.
   * @returns A [[LinkSession]] instance or null if no session can be found.
   * @throws If no [[LinkStorage]] adapter is configured or there was an error retrieving the session data.
   **/
  async restoreSession(identifier, auth, chainId) {
    if (!this.storage) {
      throw new Error("Unable to restore session: No storage adapter configured");
    }
    let key;
    if (auth && chainId) {
      key = this.sessionKey(identifier, formatAuth(PermissionLevel.from(auth)), String(ChainId.from(chainId)));
    } else {
      let list = await this.listSessions(identifier);
      if (auth) {
        list = list.filter((item) => item.auth.equals(auth));
      }
      if (chainId) {
        const id = ChainId.from(chainId);
        list = list.filter((item) => item.chainId.equals(id));
      }
      const latest = list[0];
      if (!latest) {
        return null;
      }
      key = this.sessionKey(identifier, formatAuth(latest.auth), String(latest.chainId));
    }
    const data = await this.storage.read(key);
    if (!data) {
      return null;
    }
    let sessionData;
    try {
      sessionData = JSON.parse(data);
    } catch (error) {
      throw new Error(`Unable to restore session: Stored JSON invalid (${error.message || String(error)})`);
    }
    const session = LinkSession.restore(this, sessionData);
    if (auth || chainId) {
      await this.touchSession(identifier, session.auth, session.chainId);
    }
    return session;
  }
  /**
   * List stored session auths for given identifier.
   * The most recently used session is at the top (index 0).
   * @throws If no [[LinkStorage]] adapter is configured or there was an error retrieving the session list.
   **/
  async listSessions(identifier) {
    if (!this.storage) {
      throw new Error("Unable to list sessions: No storage adapter configured");
    }
    const key = this.sessionKey(identifier, "list");
    let list;
    try {
      list = JSON.parse(await this.storage.read(key) || "[]");
    } catch (error) {
      throw new Error(`Unable to list sessions: ${error.message || String(error)}`);
    }
    return list.map(({ auth, chainId }) => ({
      auth: PermissionLevel.from(auth),
      chainId: ChainId.from(chainId)
    }));
  }
  /**
   * Remove stored session for given identifier and auth.
   * @throws If no [[LinkStorage]] adapter is configured or there was an error removing the session data.
   */
  async removeSession(identifier, auth, chainId) {
    if (!this.storage) {
      throw new Error("Unable to remove session: No storage adapter configured");
    }
    const key = this.sessionKey(identifier, formatAuth(auth), String(chainId));
    await this.storage.remove(key);
    await this.touchSession(identifier, auth, chainId, true);
  }
  /**
   * Remove all stored sessions for given identifier.
   * @throws If no [[LinkStorage]] adapter is configured or there was an error removing the session data.
   */
  async clearSessions(identifier) {
    if (!this.storage) {
      throw new Error("Unable to clear sessions: No storage adapter configured");
    }
    for (const { auth, chainId } of await this.listSessions(identifier)) {
      await this.removeSession(identifier, auth, chainId);
    }
  }
  /**
   * Create an eosjs compatible signature provider using this link.
   * @param availableKeys Keys the created provider will claim to be able to sign for.
   * @param chain Chain to use when configured with multiple chains.
   * @param transport (internal) Transport override for this call.
   * @note We don't know what keys are available so those have to be provided,
   *       to avoid this use [[LinkSession.makeSignatureProvider]] instead. Sessions can be created with [[Link.login]].
   */
  makeSignatureProvider(availableKeys, chain, transport) {
    return {
      getAvailableKeys: async () => availableKeys,
      sign: async (args) => {
        const t = transport || this.transport;
        const c = chain ? this.getChain(chain) : this.chains[0];
        let request = SigningRequest.fromTransaction(args.chainId, args.serializedTransaction, { abiProvider: c, zlib: pako });
        const callback = this.callbackService.create();
        request.setCallback(callback.url, true);
        request.setBroadcast(false);
        if (t.prepare) {
          request = await t.prepare(request);
        }
        const { transaction, signatures } = await this.sendRequest(request, callback, c, t);
        const serializedTransaction = Serializer.encode({ object: transaction });
        return {
          ...args,
          serializedTransaction,
          signatures
        };
      }
    };
  }
  /** Makes sure session is in storage list of sessions and moves it to top (most recently used). */
  async touchSession(identifier, auth, chainId, remove = false) {
    const list = await this.listSessions(identifier);
    const existing = list.findIndex((item) => item.auth.equals(auth) && item.chainId.equals(chainId));
    if (existing >= 0) {
      list.splice(existing, 1);
    }
    if (remove === false) {
      list.unshift({ auth, chainId });
    }
    const key = this.sessionKey(identifier, "list");
    await this.storage.write(key, JSON.stringify(list));
  }
  /**
   * Makes sure session is in storage list of sessions and moves it to top (most recently used).
   * @internal
   */
  async storeSession(session) {
    if (this.storage) {
      const key = this.sessionKey(session.identifier, formatAuth(session.auth), String(session.chainId));
      const data = JSON.stringify(session.serialize());
      await this.storage.write(key, data);
      await this.touchSession(session.identifier, session.auth, session.chainId);
    }
  }
  /** Session storage key for identifier and suffix. */
  sessionKey(identifier, ...suffix) {
    return [String(Name.from(identifier)), ...suffix].join("-");
  }
  /**
   * Return user agent of this link.
   * @internal
   */
  getUserAgent() {
    let rv = `AnchorLink/${Link.version}`;
    if (this.transport.userAgent) {
      rv += " " + this.transport.userAgent();
    }
    return rv;
  }
};
Link.version = "3.5.1";
function formatAuth(auth) {
  const a = PermissionLevel.from(auth);
  const actor = a.actor.equals(PlaceholderName) ? "<any>" : String(a.actor);
  let permission;
  if (a.permission.equals(PlaceholderName) || a.permission.equals(PlaceholderPermission)) {
    permission = "<any>";
  } else {
    permission = String(a.permission);
  }
  return `${actor}@${permission}`;
}

export {
  CancelError,
  IdentityError,
  SessionError,
  LinkSession,
  LinkChannelSession,
  LinkFallbackSession,
  LinkChain,
  Link
};
/*! Bundled license information:

anchor-link/lib/anchor-link.m.js:
  (**
   * Anchor Link v3.5.1
   * https://github.com/greymass/anchor-link
   *
   * @license
   * Copyright (c) 2020 Greymass Inc. All Rights Reserved.
   * 
   * Redistribution and use in source and binary forms, with or without modification,
   * are permitted provided that the following conditions are met:
   * 
   *  1. Redistribution of source code must retain the above copyright notice, this
   *     list of conditions and the following disclaimer.
   * 
   *  2. Redistribution in binary form must reproduce the above copyright notice,
   *     this list of conditions and the following disclaimer in the documentation
   *     and/or other materials provided with the distribution.
   * 
   *  3. Neither the name of the copyright holder nor the names of its contributors
   *     may be used to endorse or promote products derived from this software without
   *     specific prior written permission.
   * 
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
   * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
   * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
   * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
   * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
   * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
   * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
   * OF THE POSSIBILITY OF SUCH DAMAGE.
   * 
   * YOU ACKNOWLEDGE THAT THIS SOFTWARE IS NOT DESIGNED, LICENSED OR INTENDED FOR USE
   * IN THE DESIGN, CONSTRUCTION, OPERATION OR MAINTENANCE OF ANY MILITARY FACILITY.
   *)
*/
//# sourceMappingURL=chunk-FSE6CIJM.js.map
