import {
  require_hash
} from "./chunk-YSRTV47A.js";
import {
  __commonJS
} from "./chunk-GKWPUQBP.js";

// node_modules/eosjs/node_modules/pako/lib/zlib/trees.js
var require_trees = __commonJS({
  "node_modules/eosjs/node_modules/pako/lib/zlib/trees.js"(exports, module) {
    "use strict";
    var Z_FIXED = 4;
    var Z_BINARY = 0;
    var Z_TEXT = 1;
    var Z_UNKNOWN = 2;
    function zero(buf) {
      let len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    var STORED_BLOCK = 0;
    var STATIC_TREES = 1;
    var DYN_TREES = 2;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var Buf_size = 16;
    var MAX_BL_BITS = 7;
    var END_BLOCK = 256;
    var REP_3_6 = 16;
    var REPZ_3_10 = 17;
    var REPZ_11_138 = 18;
    var extra_lbits = (
      /* extra bits for each length code */
      new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
    );
    var extra_dbits = (
      /* extra bits for each distance code */
      new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
    );
    var extra_blbits = (
      /* extra bits for each bit length code */
      new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
    );
    var bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
    var DIST_CODE_LEN = 512;
    var static_ltree = new Array((L_CODES + 2) * 2);
    zero(static_ltree);
    var static_dtree = new Array(D_CODES * 2);
    zero(static_dtree);
    var _dist_code = new Array(DIST_CODE_LEN);
    zero(_dist_code);
    var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
    zero(_length_code);
    var base_length = new Array(LENGTH_CODES);
    zero(base_length);
    var base_dist = new Array(D_CODES);
    zero(base_dist);
    function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
      this.static_tree = static_tree;
      this.extra_bits = extra_bits;
      this.extra_base = extra_base;
      this.elems = elems;
      this.max_length = max_length;
      this.has_stree = static_tree && static_tree.length;
    }
    var static_l_desc;
    var static_d_desc;
    var static_bl_desc;
    function TreeDesc(dyn_tree, stat_desc) {
      this.dyn_tree = dyn_tree;
      this.max_code = 0;
      this.stat_desc = stat_desc;
    }
    var d_code = (dist) => {
      return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
    };
    var put_short = (s, w) => {
      s.pending_buf[s.pending++] = w & 255;
      s.pending_buf[s.pending++] = w >>> 8 & 255;
    };
    var send_bits = (s, value, length) => {
      if (s.bi_valid > Buf_size - length) {
        s.bi_buf |= value << s.bi_valid & 65535;
        put_short(s, s.bi_buf);
        s.bi_buf = value >> Buf_size - s.bi_valid;
        s.bi_valid += length - Buf_size;
      } else {
        s.bi_buf |= value << s.bi_valid & 65535;
        s.bi_valid += length;
      }
    };
    var send_code = (s, c, tree) => {
      send_bits(
        s,
        tree[c * 2],
        tree[c * 2 + 1]
        /*.Len*/
      );
    };
    var bi_reverse = (code, len) => {
      let res = 0;
      do {
        res |= code & 1;
        code >>>= 1;
        res <<= 1;
      } while (--len > 0);
      return res >>> 1;
    };
    var bi_flush = (s) => {
      if (s.bi_valid === 16) {
        put_short(s, s.bi_buf);
        s.bi_buf = 0;
        s.bi_valid = 0;
      } else if (s.bi_valid >= 8) {
        s.pending_buf[s.pending++] = s.bi_buf & 255;
        s.bi_buf >>= 8;
        s.bi_valid -= 8;
      }
    };
    var gen_bitlen = (s, desc) => {
      const tree = desc.dyn_tree;
      const max_code = desc.max_code;
      const stree = desc.stat_desc.static_tree;
      const has_stree = desc.stat_desc.has_stree;
      const extra = desc.stat_desc.extra_bits;
      const base = desc.stat_desc.extra_base;
      const max_length = desc.stat_desc.max_length;
      let h;
      let n, m;
      let bits;
      let xbits;
      let f;
      let overflow = 0;
      for (bits = 0; bits <= MAX_BITS; bits++) {
        s.bl_count[bits] = 0;
      }
      tree[s.heap[s.heap_max] * 2 + 1] = 0;
      for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
        n = s.heap[h];
        bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
        if (bits > max_length) {
          bits = max_length;
          overflow++;
        }
        tree[n * 2 + 1] = bits;
        if (n > max_code) {
          continue;
        }
        s.bl_count[bits]++;
        xbits = 0;
        if (n >= base) {
          xbits = extra[n - base];
        }
        f = tree[n * 2];
        s.opt_len += f * (bits + xbits);
        if (has_stree) {
          s.static_len += f * (stree[n * 2 + 1] + xbits);
        }
      }
      if (overflow === 0) {
        return;
      }
      do {
        bits = max_length - 1;
        while (s.bl_count[bits] === 0) {
          bits--;
        }
        s.bl_count[bits]--;
        s.bl_count[bits + 1] += 2;
        s.bl_count[max_length]--;
        overflow -= 2;
      } while (overflow > 0);
      for (bits = max_length; bits !== 0; bits--) {
        n = s.bl_count[bits];
        while (n !== 0) {
          m = s.heap[--h];
          if (m > max_code) {
            continue;
          }
          if (tree[m * 2 + 1] !== bits) {
            s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
            tree[m * 2 + 1] = bits;
          }
          n--;
        }
      }
    };
    var gen_codes = (tree, max_code, bl_count) => {
      const next_code = new Array(MAX_BITS + 1);
      let code = 0;
      let bits;
      let n;
      for (bits = 1; bits <= MAX_BITS; bits++) {
        next_code[bits] = code = code + bl_count[bits - 1] << 1;
      }
      for (n = 0; n <= max_code; n++) {
        let len = tree[n * 2 + 1];
        if (len === 0) {
          continue;
        }
        tree[n * 2] = bi_reverse(next_code[len]++, len);
      }
    };
    var tr_static_init = () => {
      let n;
      let bits;
      let length;
      let code;
      let dist;
      const bl_count = new Array(MAX_BITS + 1);
      length = 0;
      for (code = 0; code < LENGTH_CODES - 1; code++) {
        base_length[code] = length;
        for (n = 0; n < 1 << extra_lbits[code]; n++) {
          _length_code[length++] = code;
        }
      }
      _length_code[length - 1] = code;
      dist = 0;
      for (code = 0; code < 16; code++) {
        base_dist[code] = dist;
        for (n = 0; n < 1 << extra_dbits[code]; n++) {
          _dist_code[dist++] = code;
        }
      }
      dist >>= 7;
      for (; code < D_CODES; code++) {
        base_dist[code] = dist << 7;
        for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
          _dist_code[256 + dist++] = code;
        }
      }
      for (bits = 0; bits <= MAX_BITS; bits++) {
        bl_count[bits] = 0;
      }
      n = 0;
      while (n <= 143) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      while (n <= 255) {
        static_ltree[n * 2 + 1] = 9;
        n++;
        bl_count[9]++;
      }
      while (n <= 279) {
        static_ltree[n * 2 + 1] = 7;
        n++;
        bl_count[7]++;
      }
      while (n <= 287) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      gen_codes(static_ltree, L_CODES + 1, bl_count);
      for (n = 0; n < D_CODES; n++) {
        static_dtree[n * 2 + 1] = 5;
        static_dtree[n * 2] = bi_reverse(n, 5);
      }
      static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
      static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
      static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
    };
    var init_block = (s) => {
      let n;
      for (n = 0; n < L_CODES; n++) {
        s.dyn_ltree[n * 2] = 0;
      }
      for (n = 0; n < D_CODES; n++) {
        s.dyn_dtree[n * 2] = 0;
      }
      for (n = 0; n < BL_CODES; n++) {
        s.bl_tree[n * 2] = 0;
      }
      s.dyn_ltree[END_BLOCK * 2] = 1;
      s.opt_len = s.static_len = 0;
      s.last_lit = s.matches = 0;
    };
    var bi_windup = (s) => {
      if (s.bi_valid > 8) {
        put_short(s, s.bi_buf);
      } else if (s.bi_valid > 0) {
        s.pending_buf[s.pending++] = s.bi_buf;
      }
      s.bi_buf = 0;
      s.bi_valid = 0;
    };
    var copy_block = (s, buf, len, header) => {
      bi_windup(s);
      if (header) {
        put_short(s, len);
        put_short(s, ~len);
      }
      s.pending_buf.set(s.window.subarray(buf, buf + len), s.pending);
      s.pending += len;
    };
    var smaller = (tree, n, m, depth) => {
      const _n2 = n * 2;
      const _m2 = m * 2;
      return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
    };
    var pqdownheap = (s, tree, k) => {
      const v = s.heap[k];
      let j = k << 1;
      while (j <= s.heap_len) {
        if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
          j++;
        }
        if (smaller(tree, v, s.heap[j], s.depth)) {
          break;
        }
        s.heap[k] = s.heap[j];
        k = j;
        j <<= 1;
      }
      s.heap[k] = v;
    };
    var compress_block = (s, ltree, dtree) => {
      let dist;
      let lc;
      let lx = 0;
      let code;
      let extra;
      if (s.last_lit !== 0) {
        do {
          dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
          lc = s.pending_buf[s.l_buf + lx];
          lx++;
          if (dist === 0) {
            send_code(s, lc, ltree);
          } else {
            code = _length_code[lc];
            send_code(s, code + LITERALS + 1, ltree);
            extra = extra_lbits[code];
            if (extra !== 0) {
              lc -= base_length[code];
              send_bits(s, lc, extra);
            }
            dist--;
            code = d_code(dist);
            send_code(s, code, dtree);
            extra = extra_dbits[code];
            if (extra !== 0) {
              dist -= base_dist[code];
              send_bits(s, dist, extra);
            }
          }
        } while (lx < s.last_lit);
      }
      send_code(s, END_BLOCK, ltree);
    };
    var build_tree = (s, desc) => {
      const tree = desc.dyn_tree;
      const stree = desc.stat_desc.static_tree;
      const has_stree = desc.stat_desc.has_stree;
      const elems = desc.stat_desc.elems;
      let n, m;
      let max_code = -1;
      let node;
      s.heap_len = 0;
      s.heap_max = HEAP_SIZE;
      for (n = 0; n < elems; n++) {
        if (tree[n * 2] !== 0) {
          s.heap[++s.heap_len] = max_code = n;
          s.depth[n] = 0;
        } else {
          tree[n * 2 + 1] = 0;
        }
      }
      while (s.heap_len < 2) {
        node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
        tree[node * 2] = 1;
        s.depth[node] = 0;
        s.opt_len--;
        if (has_stree) {
          s.static_len -= stree[node * 2 + 1];
        }
      }
      desc.max_code = max_code;
      for (n = s.heap_len >> 1; n >= 1; n--) {
        pqdownheap(s, tree, n);
      }
      node = elems;
      do {
        n = s.heap[
          1
          /*SMALLEST*/
        ];
        s.heap[
          1
          /*SMALLEST*/
        ] = s.heap[s.heap_len--];
        pqdownheap(
          s,
          tree,
          1
          /*SMALLEST*/
        );
        m = s.heap[
          1
          /*SMALLEST*/
        ];
        s.heap[--s.heap_max] = n;
        s.heap[--s.heap_max] = m;
        tree[node * 2] = tree[n * 2] + tree[m * 2];
        s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
        tree[n * 2 + 1] = tree[m * 2 + 1] = node;
        s.heap[
          1
          /*SMALLEST*/
        ] = node++;
        pqdownheap(
          s,
          tree,
          1
          /*SMALLEST*/
        );
      } while (s.heap_len >= 2);
      s.heap[--s.heap_max] = s.heap[
        1
        /*SMALLEST*/
      ];
      gen_bitlen(s, desc);
      gen_codes(tree, max_code, s.bl_count);
    };
    var scan_tree = (s, tree, max_code) => {
      let n;
      let prevlen = -1;
      let curlen;
      let nextlen = tree[0 * 2 + 1];
      let count = 0;
      let max_count = 7;
      let min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      tree[(max_code + 1) * 2 + 1] = 65535;
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          s.bl_tree[curlen * 2] += count;
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            s.bl_tree[curlen * 2]++;
          }
          s.bl_tree[REP_3_6 * 2]++;
        } else if (count <= 10) {
          s.bl_tree[REPZ_3_10 * 2]++;
        } else {
          s.bl_tree[REPZ_11_138 * 2]++;
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    };
    var send_tree = (s, tree, max_code) => {
      let n;
      let prevlen = -1;
      let curlen;
      let nextlen = tree[0 * 2 + 1];
      let count = 0;
      let max_count = 7;
      let min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          do {
            send_code(s, curlen, s.bl_tree);
          } while (--count !== 0);
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            send_code(s, curlen, s.bl_tree);
            count--;
          }
          send_code(s, REP_3_6, s.bl_tree);
          send_bits(s, count - 3, 2);
        } else if (count <= 10) {
          send_code(s, REPZ_3_10, s.bl_tree);
          send_bits(s, count - 3, 3);
        } else {
          send_code(s, REPZ_11_138, s.bl_tree);
          send_bits(s, count - 11, 7);
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    };
    var build_bl_tree = (s) => {
      let max_blindex;
      scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
      scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
      build_tree(s, s.bl_desc);
      for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
        if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
          break;
        }
      }
      s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
      return max_blindex;
    };
    var send_all_trees = (s, lcodes, dcodes, blcodes) => {
      let rank;
      send_bits(s, lcodes - 257, 5);
      send_bits(s, dcodes - 1, 5);
      send_bits(s, blcodes - 4, 4);
      for (rank = 0; rank < blcodes; rank++) {
        send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
      }
      send_tree(s, s.dyn_ltree, lcodes - 1);
      send_tree(s, s.dyn_dtree, dcodes - 1);
    };
    var detect_data_type = (s) => {
      let black_mask = 4093624447;
      let n;
      for (n = 0; n <= 31; n++, black_mask >>>= 1) {
        if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
          return Z_BINARY;
        }
      }
      if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
        return Z_TEXT;
      }
      for (n = 32; n < LITERALS; n++) {
        if (s.dyn_ltree[n * 2] !== 0) {
          return Z_TEXT;
        }
      }
      return Z_BINARY;
    };
    var static_init_done = false;
    var _tr_init = (s) => {
      if (!static_init_done) {
        tr_static_init();
        static_init_done = true;
      }
      s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
      s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
      s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
      s.bi_buf = 0;
      s.bi_valid = 0;
      init_block(s);
    };
    var _tr_stored_block = (s, buf, stored_len, last) => {
      send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
      copy_block(s, buf, stored_len, true);
    };
    var _tr_align = (s) => {
      send_bits(s, STATIC_TREES << 1, 3);
      send_code(s, END_BLOCK, static_ltree);
      bi_flush(s);
    };
    var _tr_flush_block = (s, buf, stored_len, last) => {
      let opt_lenb, static_lenb;
      let max_blindex = 0;
      if (s.level > 0) {
        if (s.strm.data_type === Z_UNKNOWN) {
          s.strm.data_type = detect_data_type(s);
        }
        build_tree(s, s.l_desc);
        build_tree(s, s.d_desc);
        max_blindex = build_bl_tree(s);
        opt_lenb = s.opt_len + 3 + 7 >>> 3;
        static_lenb = s.static_len + 3 + 7 >>> 3;
        if (static_lenb <= opt_lenb) {
          opt_lenb = static_lenb;
        }
      } else {
        opt_lenb = static_lenb = stored_len + 5;
      }
      if (stored_len + 4 <= opt_lenb && buf !== -1) {
        _tr_stored_block(s, buf, stored_len, last);
      } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
        send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
        compress_block(s, static_ltree, static_dtree);
      } else {
        send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
        send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
        compress_block(s, s.dyn_ltree, s.dyn_dtree);
      }
      init_block(s);
      if (last) {
        bi_windup(s);
      }
    };
    var _tr_tally = (s, dist, lc) => {
      s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
      s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
      s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
      s.last_lit++;
      if (dist === 0) {
        s.dyn_ltree[lc * 2]++;
      } else {
        s.matches++;
        dist--;
        s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
        s.dyn_dtree[d_code(dist) * 2]++;
      }
      return s.last_lit === s.lit_bufsize - 1;
    };
    module.exports._tr_init = _tr_init;
    module.exports._tr_stored_block = _tr_stored_block;
    module.exports._tr_flush_block = _tr_flush_block;
    module.exports._tr_tally = _tr_tally;
    module.exports._tr_align = _tr_align;
  }
});

// node_modules/eosjs/node_modules/pako/lib/zlib/adler32.js
var require_adler32 = __commonJS({
  "node_modules/eosjs/node_modules/pako/lib/zlib/adler32.js"(exports, module) {
    "use strict";
    var adler32 = (adler, buf, len, pos) => {
      let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
      while (len !== 0) {
        n = len > 2e3 ? 2e3 : len;
        len -= n;
        do {
          s1 = s1 + buf[pos++] | 0;
          s2 = s2 + s1 | 0;
        } while (--n);
        s1 %= 65521;
        s2 %= 65521;
      }
      return s1 | s2 << 16 | 0;
    };
    module.exports = adler32;
  }
});

// node_modules/eosjs/node_modules/pako/lib/zlib/crc32.js
var require_crc32 = __commonJS({
  "node_modules/eosjs/node_modules/pako/lib/zlib/crc32.js"(exports, module) {
    "use strict";
    var makeTable = () => {
      let c, table = [];
      for (var n = 0; n < 256; n++) {
        c = n;
        for (var k = 0; k < 8; k++) {
          c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
        }
        table[n] = c;
      }
      return table;
    };
    var crcTable = new Uint32Array(makeTable());
    var crc32 = (crc, buf, len, pos) => {
      const t = crcTable;
      const end = pos + len;
      crc ^= -1;
      for (let i = pos; i < end; i++) {
        crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
      }
      return crc ^ -1;
    };
    module.exports = crc32;
  }
});

// node_modules/eosjs/node_modules/pako/lib/zlib/messages.js
var require_messages = __commonJS({
  "node_modules/eosjs/node_modules/pako/lib/zlib/messages.js"(exports, module) {
    "use strict";
    module.exports = {
      2: "need dictionary",
      /* Z_NEED_DICT       2  */
      1: "stream end",
      /* Z_STREAM_END      1  */
      0: "",
      /* Z_OK              0  */
      "-1": "file error",
      /* Z_ERRNO         (-1) */
      "-2": "stream error",
      /* Z_STREAM_ERROR  (-2) */
      "-3": "data error",
      /* Z_DATA_ERROR    (-3) */
      "-4": "insufficient memory",
      /* Z_MEM_ERROR     (-4) */
      "-5": "buffer error",
      /* Z_BUF_ERROR     (-5) */
      "-6": "incompatible version"
      /* Z_VERSION_ERROR (-6) */
    };
  }
});

// node_modules/eosjs/node_modules/pako/lib/zlib/constants.js
var require_constants = __commonJS({
  "node_modules/eosjs/node_modules/pako/lib/zlib/constants.js"(exports, module) {
    "use strict";
    module.exports = {
      /* Allowed flush values; see deflate() and inflate() below for details */
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_TREES: 6,
      /* Return codes for the compression/decompression functions. Negative values
      * are errors, positive values are used for special but normal events.
      */
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      Z_MEM_ERROR: -4,
      Z_BUF_ERROR: -5,
      //Z_VERSION_ERROR: -6,
      /* compression levels */
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      /* Possible values of the data_type field (though see inflate()) */
      Z_BINARY: 0,
      Z_TEXT: 1,
      //Z_ASCII:                1, // = Z_TEXT (deprecated)
      Z_UNKNOWN: 2,
      /* The deflate compression method */
      Z_DEFLATED: 8
      //Z_NULL:                 null // Use -1 or null inline, depending on var type
    };
  }
});

// node_modules/eosjs/node_modules/pako/lib/zlib/deflate.js
var require_deflate = __commonJS({
  "node_modules/eosjs/node_modules/pako/lib/zlib/deflate.js"(exports, module) {
    "use strict";
    var { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = require_trees();
    var adler32 = require_adler32();
    var crc32 = require_crc32();
    var msg = require_messages();
    var {
      Z_NO_FLUSH,
      Z_PARTIAL_FLUSH,
      Z_FULL_FLUSH,
      Z_FINISH,
      Z_BLOCK,
      Z_OK,
      Z_STREAM_END,
      Z_STREAM_ERROR,
      Z_DATA_ERROR,
      Z_BUF_ERROR,
      Z_DEFAULT_COMPRESSION,
      Z_FILTERED,
      Z_HUFFMAN_ONLY,
      Z_RLE,
      Z_FIXED,
      Z_DEFAULT_STRATEGY,
      Z_UNKNOWN,
      Z_DEFLATED
    } = require_constants();
    var MAX_MEM_LEVEL = 9;
    var MAX_WBITS = 15;
    var DEF_MEM_LEVEL = 8;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
    var PRESET_DICT = 32;
    var INIT_STATE = 42;
    var EXTRA_STATE = 69;
    var NAME_STATE = 73;
    var COMMENT_STATE = 91;
    var HCRC_STATE = 103;
    var BUSY_STATE = 113;
    var FINISH_STATE = 666;
    var BS_NEED_MORE = 1;
    var BS_BLOCK_DONE = 2;
    var BS_FINISH_STARTED = 3;
    var BS_FINISH_DONE = 4;
    var OS_CODE = 3;
    var err = (strm, errorCode) => {
      strm.msg = msg[errorCode];
      return errorCode;
    };
    var rank = (f) => {
      return (f << 1) - (f > 4 ? 9 : 0);
    };
    var zero = (buf) => {
      let len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    };
    var HASH_ZLIB = (s, prev, data) => (prev << s.hash_shift ^ data) & s.hash_mask;
    var HASH = HASH_ZLIB;
    var flush_pending = (strm) => {
      const s = strm.state;
      let len = s.pending;
      if (len > strm.avail_out) {
        len = strm.avail_out;
      }
      if (len === 0) {
        return;
      }
      strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
      strm.next_out += len;
      s.pending_out += len;
      strm.total_out += len;
      strm.avail_out -= len;
      s.pending -= len;
      if (s.pending === 0) {
        s.pending_out = 0;
      }
    };
    var flush_block_only = (s, last) => {
      _tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
      s.block_start = s.strstart;
      flush_pending(s.strm);
    };
    var put_byte = (s, b) => {
      s.pending_buf[s.pending++] = b;
    };
    var putShortMSB = (s, b) => {
      s.pending_buf[s.pending++] = b >>> 8 & 255;
      s.pending_buf[s.pending++] = b & 255;
    };
    var read_buf = (strm, buf, start, size) => {
      let len = strm.avail_in;
      if (len > size) {
        len = size;
      }
      if (len === 0) {
        return 0;
      }
      strm.avail_in -= len;
      buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
      if (strm.state.wrap === 1) {
        strm.adler = adler32(strm.adler, buf, len, start);
      } else if (strm.state.wrap === 2) {
        strm.adler = crc32(strm.adler, buf, len, start);
      }
      strm.next_in += len;
      strm.total_in += len;
      return len;
    };
    var longest_match = (s, cur_match) => {
      let chain_length = s.max_chain_length;
      let scan = s.strstart;
      let match;
      let len;
      let best_len = s.prev_length;
      let nice_match = s.nice_match;
      const limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
      const _win = s.window;
      const wmask = s.w_mask;
      const prev = s.prev;
      const strend = s.strstart + MAX_MATCH;
      let scan_end1 = _win[scan + best_len - 1];
      let scan_end = _win[scan + best_len];
      if (s.prev_length >= s.good_match) {
        chain_length >>= 2;
      }
      if (nice_match > s.lookahead) {
        nice_match = s.lookahead;
      }
      do {
        match = cur_match;
        if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
          continue;
        }
        scan += 2;
        match++;
        do {
        } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
        len = MAX_MATCH - (strend - scan);
        scan = strend - MAX_MATCH;
        if (len > best_len) {
          s.match_start = cur_match;
          best_len = len;
          if (len >= nice_match) {
            break;
          }
          scan_end1 = _win[scan + best_len - 1];
          scan_end = _win[scan + best_len];
        }
      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
      if (best_len <= s.lookahead) {
        return best_len;
      }
      return s.lookahead;
    };
    var fill_window = (s) => {
      const _w_size = s.w_size;
      let p, n, m, more, str;
      do {
        more = s.window_size - s.lookahead - s.strstart;
        if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
          s.window.set(s.window.subarray(_w_size, _w_size + _w_size), 0);
          s.match_start -= _w_size;
          s.strstart -= _w_size;
          s.block_start -= _w_size;
          n = s.hash_size;
          p = n;
          do {
            m = s.head[--p];
            s.head[p] = m >= _w_size ? m - _w_size : 0;
          } while (--n);
          n = _w_size;
          p = n;
          do {
            m = s.prev[--p];
            s.prev[p] = m >= _w_size ? m - _w_size : 0;
          } while (--n);
          more += _w_size;
        }
        if (s.strm.avail_in === 0) {
          break;
        }
        n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
        s.lookahead += n;
        if (s.lookahead + s.insert >= MIN_MATCH) {
          str = s.strstart - s.insert;
          s.ins_h = s.window[str];
          s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);
          while (s.insert) {
            s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
            s.prev[str & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = str;
            str++;
            s.insert--;
            if (s.lookahead + s.insert < MIN_MATCH) {
              break;
            }
          }
        }
      } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
    };
    var deflate_stored = (s, flush) => {
      let max_block_size = 65535;
      if (max_block_size > s.pending_buf_size - 5) {
        max_block_size = s.pending_buf_size - 5;
      }
      for (; ; ) {
        if (s.lookahead <= 1) {
          fill_window(s);
          if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        s.strstart += s.lookahead;
        s.lookahead = 0;
        const max_start = s.block_start + max_block_size;
        if (s.strstart === 0 || s.strstart >= max_start) {
          s.lookahead = s.strstart - max_start;
          s.strstart = max_start;
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.strstart > s.block_start) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_NEED_MORE;
    };
    var deflate_fast = (s, flush) => {
      let hash_head;
      let bflush;
      for (; ; ) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
          s.match_length = longest_match(s, hash_head);
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
            s.match_length--;
            do {
              s.strstart++;
              s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            } while (--s.match_length !== 0);
            s.strstart++;
          } else {
            s.strstart += s.match_length;
            s.match_length = 0;
            s.ins_h = s.window[s.strstart];
            s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);
          }
        } else {
          bflush = _tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    };
    var deflate_slow = (s, flush) => {
      let hash_head;
      let bflush;
      let max_insert;
      for (; ; ) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        s.prev_length = s.match_length;
        s.prev_match = s.match_start;
        s.match_length = MIN_MATCH - 1;
        if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
          s.match_length = longest_match(s, hash_head);
          if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
            s.match_length = MIN_MATCH - 1;
          }
        }
        if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
          max_insert = s.strstart + s.lookahead - MIN_MATCH;
          bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
          s.lookahead -= s.prev_length - 1;
          s.prev_length -= 2;
          do {
            if (++s.strstart <= max_insert) {
              s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            }
          } while (--s.prev_length !== 0);
          s.match_available = 0;
          s.match_length = MIN_MATCH - 1;
          s.strstart++;
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        } else if (s.match_available) {
          bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
          if (bflush) {
            flush_block_only(s, false);
          }
          s.strstart++;
          s.lookahead--;
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        } else {
          s.match_available = 1;
          s.strstart++;
          s.lookahead--;
        }
      }
      if (s.match_available) {
        bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
        s.match_available = 0;
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    };
    var deflate_rle = (s, flush) => {
      let bflush;
      let prev;
      let scan, strend;
      const _win = s.window;
      for (; ; ) {
        if (s.lookahead <= MAX_MATCH) {
          fill_window(s);
          if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        s.match_length = 0;
        if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
          scan = s.strstart - 1;
          prev = _win[scan];
          if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
            strend = s.strstart + MAX_MATCH;
            do {
            } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
            s.match_length = MAX_MATCH - (strend - scan);
            if (s.match_length > s.lookahead) {
              s.match_length = s.lookahead;
            }
          }
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          s.strstart += s.match_length;
          s.match_length = 0;
        } else {
          bflush = _tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    };
    var deflate_huff = (s, flush) => {
      let bflush;
      for (; ; ) {
        if (s.lookahead === 0) {
          fill_window(s);
          if (s.lookahead === 0) {
            if (flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            break;
          }
        }
        s.match_length = 0;
        bflush = _tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    };
    function Config(good_length, max_lazy, nice_length, max_chain, func) {
      this.good_length = good_length;
      this.max_lazy = max_lazy;
      this.nice_length = nice_length;
      this.max_chain = max_chain;
      this.func = func;
    }
    var configuration_table = [
      /*      good lazy nice chain */
      new Config(0, 0, 0, 0, deflate_stored),
      /* 0 store only */
      new Config(4, 4, 8, 4, deflate_fast),
      /* 1 max speed, no lazy matches */
      new Config(4, 5, 16, 8, deflate_fast),
      /* 2 */
      new Config(4, 6, 32, 32, deflate_fast),
      /* 3 */
      new Config(4, 4, 16, 16, deflate_slow),
      /* 4 lazy matches */
      new Config(8, 16, 32, 32, deflate_slow),
      /* 5 */
      new Config(8, 16, 128, 128, deflate_slow),
      /* 6 */
      new Config(8, 32, 128, 256, deflate_slow),
      /* 7 */
      new Config(32, 128, 258, 1024, deflate_slow),
      /* 8 */
      new Config(32, 258, 258, 4096, deflate_slow)
      /* 9 max compression */
    ];
    var lm_init = (s) => {
      s.window_size = 2 * s.w_size;
      zero(s.head);
      s.max_lazy_match = configuration_table[s.level].max_lazy;
      s.good_match = configuration_table[s.level].good_length;
      s.nice_match = configuration_table[s.level].nice_length;
      s.max_chain_length = configuration_table[s.level].max_chain;
      s.strstart = 0;
      s.block_start = 0;
      s.lookahead = 0;
      s.insert = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      s.ins_h = 0;
    };
    function DeflateState() {
      this.strm = null;
      this.status = 0;
      this.pending_buf = null;
      this.pending_buf_size = 0;
      this.pending_out = 0;
      this.pending = 0;
      this.wrap = 0;
      this.gzhead = null;
      this.gzindex = 0;
      this.method = Z_DEFLATED;
      this.last_flush = -1;
      this.w_size = 0;
      this.w_bits = 0;
      this.w_mask = 0;
      this.window = null;
      this.window_size = 0;
      this.prev = null;
      this.head = null;
      this.ins_h = 0;
      this.hash_size = 0;
      this.hash_bits = 0;
      this.hash_mask = 0;
      this.hash_shift = 0;
      this.block_start = 0;
      this.match_length = 0;
      this.prev_match = 0;
      this.match_available = 0;
      this.strstart = 0;
      this.match_start = 0;
      this.lookahead = 0;
      this.prev_length = 0;
      this.max_chain_length = 0;
      this.max_lazy_match = 0;
      this.level = 0;
      this.strategy = 0;
      this.good_match = 0;
      this.nice_match = 0;
      this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
      this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
      this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
      zero(this.dyn_ltree);
      zero(this.dyn_dtree);
      zero(this.bl_tree);
      this.l_desc = null;
      this.d_desc = null;
      this.bl_desc = null;
      this.bl_count = new Uint16Array(MAX_BITS + 1);
      this.heap = new Uint16Array(2 * L_CODES + 1);
      zero(this.heap);
      this.heap_len = 0;
      this.heap_max = 0;
      this.depth = new Uint16Array(2 * L_CODES + 1);
      zero(this.depth);
      this.l_buf = 0;
      this.lit_bufsize = 0;
      this.last_lit = 0;
      this.d_buf = 0;
      this.opt_len = 0;
      this.static_len = 0;
      this.matches = 0;
      this.insert = 0;
      this.bi_buf = 0;
      this.bi_valid = 0;
    }
    var deflateResetKeep = (strm) => {
      if (!strm || !strm.state) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.total_in = strm.total_out = 0;
      strm.data_type = Z_UNKNOWN;
      const s = strm.state;
      s.pending = 0;
      s.pending_out = 0;
      if (s.wrap < 0) {
        s.wrap = -s.wrap;
      }
      s.status = s.wrap ? INIT_STATE : BUSY_STATE;
      strm.adler = s.wrap === 2 ? 0 : 1;
      s.last_flush = Z_NO_FLUSH;
      _tr_init(s);
      return Z_OK;
    };
    var deflateReset = (strm) => {
      const ret = deflateResetKeep(strm);
      if (ret === Z_OK) {
        lm_init(strm.state);
      }
      return ret;
    };
    var deflateSetHeader = (strm, head) => {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      if (strm.state.wrap !== 2) {
        return Z_STREAM_ERROR;
      }
      strm.state.gzhead = head;
      return Z_OK;
    };
    var deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      let wrap = 1;
      if (level === Z_DEFAULT_COMPRESSION) {
        level = 6;
      }
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else if (windowBits > 15) {
        wrap = 2;
        windowBits -= 16;
      }
      if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
        return err(strm, Z_STREAM_ERROR);
      }
      if (windowBits === 8) {
        windowBits = 9;
      }
      const s = new DeflateState();
      strm.state = s;
      s.strm = strm;
      s.wrap = wrap;
      s.gzhead = null;
      s.w_bits = windowBits;
      s.w_size = 1 << s.w_bits;
      s.w_mask = s.w_size - 1;
      s.hash_bits = memLevel + 7;
      s.hash_size = 1 << s.hash_bits;
      s.hash_mask = s.hash_size - 1;
      s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
      s.window = new Uint8Array(s.w_size * 2);
      s.head = new Uint16Array(s.hash_size);
      s.prev = new Uint16Array(s.w_size);
      s.lit_bufsize = 1 << memLevel + 6;
      s.pending_buf_size = s.lit_bufsize * 4;
      s.pending_buf = new Uint8Array(s.pending_buf_size);
      s.d_buf = 1 * s.lit_bufsize;
      s.l_buf = (1 + 2) * s.lit_bufsize;
      s.level = level;
      s.strategy = strategy;
      s.method = method;
      return deflateReset(strm);
    };
    var deflateInit = (strm, level) => {
      return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
    };
    var deflate = (strm, flush) => {
      let beg, val;
      if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
        return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
      }
      const s = strm.state;
      if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
        return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
      }
      s.strm = strm;
      const old_flush = s.last_flush;
      s.last_flush = flush;
      if (s.status === INIT_STATE) {
        if (s.wrap === 2) {
          strm.adler = 0;
          put_byte(s, 31);
          put_byte(s, 139);
          put_byte(s, 8);
          if (!s.gzhead) {
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
            put_byte(s, OS_CODE);
            s.status = BUSY_STATE;
          } else {
            put_byte(
              s,
              (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
            );
            put_byte(s, s.gzhead.time & 255);
            put_byte(s, s.gzhead.time >> 8 & 255);
            put_byte(s, s.gzhead.time >> 16 & 255);
            put_byte(s, s.gzhead.time >> 24 & 255);
            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
            put_byte(s, s.gzhead.os & 255);
            if (s.gzhead.extra && s.gzhead.extra.length) {
              put_byte(s, s.gzhead.extra.length & 255);
              put_byte(s, s.gzhead.extra.length >> 8 & 255);
            }
            if (s.gzhead.hcrc) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
            }
            s.gzindex = 0;
            s.status = EXTRA_STATE;
          }
        } else {
          let header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
          let level_flags = -1;
          if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
            level_flags = 0;
          } else if (s.level < 6) {
            level_flags = 1;
          } else if (s.level === 6) {
            level_flags = 2;
          } else {
            level_flags = 3;
          }
          header |= level_flags << 6;
          if (s.strstart !== 0) {
            header |= PRESET_DICT;
          }
          header += 31 - header % 31;
          s.status = BUSY_STATE;
          putShortMSB(s, header);
          if (s.strstart !== 0) {
            putShortMSB(s, strm.adler >>> 16);
            putShortMSB(s, strm.adler & 65535);
          }
          strm.adler = 1;
        }
      }
      if (s.status === EXTRA_STATE) {
        if (s.gzhead.extra) {
          beg = s.pending;
          while (s.gzindex < (s.gzhead.extra.length & 65535)) {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                break;
              }
            }
            put_byte(s, s.gzhead.extra[s.gzindex] & 255);
            s.gzindex++;
          }
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (s.gzindex === s.gzhead.extra.length) {
            s.gzindex = 0;
            s.status = NAME_STATE;
          }
        } else {
          s.status = NAME_STATE;
        }
      }
      if (s.status === NAME_STATE) {
        if (s.gzhead.name) {
          beg = s.pending;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s.gzindex < s.gzhead.name.length) {
              val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (val === 0) {
            s.gzindex = 0;
            s.status = COMMENT_STATE;
          }
        } else {
          s.status = COMMENT_STATE;
        }
      }
      if (s.status === COMMENT_STATE) {
        if (s.gzhead.comment) {
          beg = s.pending;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s.gzindex < s.gzhead.comment.length) {
              val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (val === 0) {
            s.status = HCRC_STATE;
          }
        } else {
          s.status = HCRC_STATE;
        }
      }
      if (s.status === HCRC_STATE) {
        if (s.gzhead.hcrc) {
          if (s.pending + 2 > s.pending_buf_size) {
            flush_pending(strm);
          }
          if (s.pending + 2 <= s.pending_buf_size) {
            put_byte(s, strm.adler & 255);
            put_byte(s, strm.adler >> 8 & 255);
            strm.adler = 0;
            s.status = BUSY_STATE;
          }
        } else {
          s.status = BUSY_STATE;
        }
      }
      if (s.pending !== 0) {
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s.last_flush = -1;
          return Z_OK;
        }
      } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
        return err(strm, Z_BUF_ERROR);
      }
      if (s.status === FINISH_STATE && strm.avail_in !== 0) {
        return err(strm, Z_BUF_ERROR);
      }
      if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
        let bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
          s.status = FINISH_STATE;
        }
        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
          if (strm.avail_out === 0) {
            s.last_flush = -1;
          }
          return Z_OK;
        }
        if (bstate === BS_BLOCK_DONE) {
          if (flush === Z_PARTIAL_FLUSH) {
            _tr_align(s);
          } else if (flush !== Z_BLOCK) {
            _tr_stored_block(s, 0, 0, false);
            if (flush === Z_FULL_FLUSH) {
              zero(s.head);
              if (s.lookahead === 0) {
                s.strstart = 0;
                s.block_start = 0;
                s.insert = 0;
              }
            }
          }
          flush_pending(strm);
          if (strm.avail_out === 0) {
            s.last_flush = -1;
            return Z_OK;
          }
        }
      }
      if (flush !== Z_FINISH) {
        return Z_OK;
      }
      if (s.wrap <= 0) {
        return Z_STREAM_END;
      }
      if (s.wrap === 2) {
        put_byte(s, strm.adler & 255);
        put_byte(s, strm.adler >> 8 & 255);
        put_byte(s, strm.adler >> 16 & 255);
        put_byte(s, strm.adler >> 24 & 255);
        put_byte(s, strm.total_in & 255);
        put_byte(s, strm.total_in >> 8 & 255);
        put_byte(s, strm.total_in >> 16 & 255);
        put_byte(s, strm.total_in >> 24 & 255);
      } else {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 65535);
      }
      flush_pending(strm);
      if (s.wrap > 0) {
        s.wrap = -s.wrap;
      }
      return s.pending !== 0 ? Z_OK : Z_STREAM_END;
    };
    var deflateEnd = (strm) => {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      const status = strm.state.status;
      if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.state = null;
      return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
    };
    var deflateSetDictionary = (strm, dictionary) => {
      let dictLength = dictionary.length;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      const s = strm.state;
      const wrap = s.wrap;
      if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
        return Z_STREAM_ERROR;
      }
      if (wrap === 1) {
        strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
      }
      s.wrap = 0;
      if (dictLength >= s.w_size) {
        if (wrap === 0) {
          zero(s.head);
          s.strstart = 0;
          s.block_start = 0;
          s.insert = 0;
        }
        let tmpDict = new Uint8Array(s.w_size);
        tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
        dictionary = tmpDict;
        dictLength = s.w_size;
      }
      const avail = strm.avail_in;
      const next = strm.next_in;
      const input = strm.input;
      strm.avail_in = dictLength;
      strm.next_in = 0;
      strm.input = dictionary;
      fill_window(s);
      while (s.lookahead >= MIN_MATCH) {
        let str = s.strstart;
        let n = s.lookahead - (MIN_MATCH - 1);
        do {
          s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
          s.prev[str & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = str;
          str++;
        } while (--n);
        s.strstart = str;
        s.lookahead = MIN_MATCH - 1;
        fill_window(s);
      }
      s.strstart += s.lookahead;
      s.block_start = s.strstart;
      s.insert = s.lookahead;
      s.lookahead = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      strm.next_in = next;
      strm.input = input;
      strm.avail_in = avail;
      s.wrap = wrap;
      return Z_OK;
    };
    module.exports.deflateInit = deflateInit;
    module.exports.deflateInit2 = deflateInit2;
    module.exports.deflateReset = deflateReset;
    module.exports.deflateResetKeep = deflateResetKeep;
    module.exports.deflateSetHeader = deflateSetHeader;
    module.exports.deflate = deflate;
    module.exports.deflateEnd = deflateEnd;
    module.exports.deflateSetDictionary = deflateSetDictionary;
    module.exports.deflateInfo = "pako deflate (from Nodeca project)";
  }
});

// node_modules/eosjs/node_modules/pako/lib/utils/common.js
var require_common = __commonJS({
  "node_modules/eosjs/node_modules/pako/lib/utils/common.js"(exports, module) {
    "use strict";
    var _has = (obj, key) => {
      return Object.prototype.hasOwnProperty.call(obj, key);
    };
    module.exports.assign = function(obj) {
      const sources = Array.prototype.slice.call(arguments, 1);
      while (sources.length) {
        const source = sources.shift();
        if (!source) {
          continue;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be non-object");
        }
        for (const p in source) {
          if (_has(source, p)) {
            obj[p] = source[p];
          }
        }
      }
      return obj;
    };
    module.exports.flattenChunks = (chunks) => {
      let len = 0;
      for (let i = 0, l = chunks.length; i < l; i++) {
        len += chunks[i].length;
      }
      const result = new Uint8Array(len);
      for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
        let chunk = chunks[i];
        result.set(chunk, pos);
        pos += chunk.length;
      }
      return result;
    };
  }
});

// node_modules/eosjs/node_modules/pako/lib/utils/strings.js
var require_strings = __commonJS({
  "node_modules/eosjs/node_modules/pako/lib/utils/strings.js"(exports, module) {
    "use strict";
    var STR_APPLY_UIA_OK = true;
    try {
      String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (__) {
      STR_APPLY_UIA_OK = false;
    }
    var _utf8len = new Uint8Array(256);
    for (let q = 0; q < 256; q++) {
      _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
    }
    _utf8len[254] = _utf8len[254] = 1;
    module.exports.string2buf = (str) => {
      let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
      for (m_pos = 0; m_pos < str_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
      }
      buf = new Uint8Array(buf_len);
      for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        if (c < 128) {
          buf[i++] = c;
        } else if (c < 2048) {
          buf[i++] = 192 | c >>> 6;
          buf[i++] = 128 | c & 63;
        } else if (c < 65536) {
          buf[i++] = 224 | c >>> 12;
          buf[i++] = 128 | c >>> 6 & 63;
          buf[i++] = 128 | c & 63;
        } else {
          buf[i++] = 240 | c >>> 18;
          buf[i++] = 128 | c >>> 12 & 63;
          buf[i++] = 128 | c >>> 6 & 63;
          buf[i++] = 128 | c & 63;
        }
      }
      return buf;
    };
    var buf2binstring = (buf, len) => {
      if (len < 65534) {
        if (buf.subarray && STR_APPLY_UIA_OK) {
          return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
        }
      }
      let result = "";
      for (let i = 0; i < len; i++) {
        result += String.fromCharCode(buf[i]);
      }
      return result;
    };
    module.exports.buf2string = (buf, max) => {
      let i, out;
      const len = max || buf.length;
      const utf16buf = new Array(len * 2);
      for (out = 0, i = 0; i < len; ) {
        let c = buf[i++];
        if (c < 128) {
          utf16buf[out++] = c;
          continue;
        }
        let c_len = _utf8len[c];
        if (c_len > 4) {
          utf16buf[out++] = 65533;
          i += c_len - 1;
          continue;
        }
        c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
        while (c_len > 1 && i < len) {
          c = c << 6 | buf[i++] & 63;
          c_len--;
        }
        if (c_len > 1) {
          utf16buf[out++] = 65533;
          continue;
        }
        if (c < 65536) {
          utf16buf[out++] = c;
        } else {
          c -= 65536;
          utf16buf[out++] = 55296 | c >> 10 & 1023;
          utf16buf[out++] = 56320 | c & 1023;
        }
      }
      return buf2binstring(utf16buf, out);
    };
    module.exports.utf8border = (buf, max) => {
      max = max || buf.length;
      if (max > buf.length) {
        max = buf.length;
      }
      let pos = max - 1;
      while (pos >= 0 && (buf[pos] & 192) === 128) {
        pos--;
      }
      if (pos < 0) {
        return max;
      }
      if (pos === 0) {
        return max;
      }
      return pos + _utf8len[buf[pos]] > max ? pos : max;
    };
  }
});

// node_modules/eosjs/node_modules/pako/lib/zlib/zstream.js
var require_zstream = __commonJS({
  "node_modules/eosjs/node_modules/pako/lib/zlib/zstream.js"(exports, module) {
    "use strict";
    function ZStream() {
      this.input = null;
      this.next_in = 0;
      this.avail_in = 0;
      this.total_in = 0;
      this.output = null;
      this.next_out = 0;
      this.avail_out = 0;
      this.total_out = 0;
      this.msg = "";
      this.state = null;
      this.data_type = 2;
      this.adler = 0;
    }
    module.exports = ZStream;
  }
});

// node_modules/eosjs/node_modules/pako/lib/deflate.js
var require_deflate2 = __commonJS({
  "node_modules/eosjs/node_modules/pako/lib/deflate.js"(exports, module) {
    "use strict";
    var zlib_deflate = require_deflate();
    var utils = require_common();
    var strings = require_strings();
    var msg = require_messages();
    var ZStream = require_zstream();
    var toString = Object.prototype.toString;
    var {
      Z_NO_FLUSH,
      Z_SYNC_FLUSH,
      Z_FULL_FLUSH,
      Z_FINISH,
      Z_OK,
      Z_STREAM_END,
      Z_DEFAULT_COMPRESSION,
      Z_DEFAULT_STRATEGY,
      Z_DEFLATED
    } = require_constants();
    function Deflate(options) {
      this.options = utils.assign({
        level: Z_DEFAULT_COMPRESSION,
        method: Z_DEFLATED,
        chunkSize: 16384,
        windowBits: 15,
        memLevel: 8,
        strategy: Z_DEFAULT_STRATEGY
      }, options || {});
      let opt = this.options;
      if (opt.raw && opt.windowBits > 0) {
        opt.windowBits = -opt.windowBits;
      } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
        opt.windowBits += 16;
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      let status = zlib_deflate.deflateInit2(
        this.strm,
        opt.level,
        opt.method,
        opt.windowBits,
        opt.memLevel,
        opt.strategy
      );
      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }
      if (opt.header) {
        zlib_deflate.deflateSetHeader(this.strm, opt.header);
      }
      if (opt.dictionary) {
        let dict;
        if (typeof opt.dictionary === "string") {
          dict = strings.string2buf(opt.dictionary);
        } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
          dict = new Uint8Array(opt.dictionary);
        } else {
          dict = opt.dictionary;
        }
        status = zlib_deflate.deflateSetDictionary(this.strm, dict);
        if (status !== Z_OK) {
          throw new Error(msg[status]);
        }
        this._dict_set = true;
      }
    }
    Deflate.prototype.push = function(data, flush_mode) {
      const strm = this.strm;
      const chunkSize = this.options.chunkSize;
      let status, _flush_mode;
      if (this.ended) {
        return false;
      }
      if (flush_mode === ~~flush_mode)
        _flush_mode = flush_mode;
      else
        _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
      if (typeof data === "string") {
        strm.input = strings.string2buf(data);
      } else if (toString.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      for (; ; ) {
        if (strm.avail_out === 0) {
          strm.output = new Uint8Array(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
          this.onData(strm.output.subarray(0, strm.next_out));
          strm.avail_out = 0;
          continue;
        }
        status = zlib_deflate.deflate(strm, _flush_mode);
        if (status === Z_STREAM_END) {
          if (strm.next_out > 0) {
            this.onData(strm.output.subarray(0, strm.next_out));
          }
          status = zlib_deflate.deflateEnd(this.strm);
          this.onEnd(status);
          this.ended = true;
          return status === Z_OK;
        }
        if (strm.avail_out === 0) {
          this.onData(strm.output);
          continue;
        }
        if (_flush_mode > 0 && strm.next_out > 0) {
          this.onData(strm.output.subarray(0, strm.next_out));
          strm.avail_out = 0;
          continue;
        }
        if (strm.avail_in === 0)
          break;
      }
      return true;
    };
    Deflate.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Deflate.prototype.onEnd = function(status) {
      if (status === Z_OK) {
        this.result = utils.flattenChunks(this.chunks);
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function deflate(input, options) {
      const deflator = new Deflate(options);
      deflator.push(input, true);
      if (deflator.err) {
        throw deflator.msg || msg[deflator.err];
      }
      return deflator.result;
    }
    function deflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return deflate(input, options);
    }
    function gzip(input, options) {
      options = options || {};
      options.gzip = true;
      return deflate(input, options);
    }
    module.exports.Deflate = Deflate;
    module.exports.deflate = deflate;
    module.exports.deflateRaw = deflateRaw;
    module.exports.gzip = gzip;
    module.exports.constants = require_constants();
  }
});

// node_modules/eosjs/node_modules/pako/lib/zlib/inffast.js
var require_inffast = __commonJS({
  "node_modules/eosjs/node_modules/pako/lib/zlib/inffast.js"(exports, module) {
    "use strict";
    var BAD = 30;
    var TYPE = 12;
    module.exports = function inflate_fast(strm, start) {
      let _in;
      let last;
      let _out;
      let beg;
      let end;
      let dmax;
      let wsize;
      let whave;
      let wnext;
      let s_window;
      let hold;
      let bits;
      let lcode;
      let dcode;
      let lmask;
      let dmask;
      let here;
      let op;
      let len;
      let dist;
      let from;
      let from_source;
      let input, output;
      const state = strm.state;
      _in = strm.next_in;
      input = strm.input;
      last = _in + (strm.avail_in - 5);
      _out = strm.next_out;
      output = strm.output;
      beg = _out - (start - strm.avail_out);
      end = _out + (strm.avail_out - 257);
      dmax = state.dmax;
      wsize = state.wsize;
      whave = state.whave;
      wnext = state.wnext;
      s_window = state.window;
      hold = state.hold;
      bits = state.bits;
      lcode = state.lencode;
      dcode = state.distcode;
      lmask = (1 << state.lenbits) - 1;
      dmask = (1 << state.distbits) - 1;
      top:
        do {
          if (bits < 15) {
            hold += input[_in++] << bits;
            bits += 8;
            hold += input[_in++] << bits;
            bits += 8;
          }
          here = lcode[hold & lmask];
          dolen:
            for (; ; ) {
              op = here >>> 24;
              hold >>>= op;
              bits -= op;
              op = here >>> 16 & 255;
              if (op === 0) {
                output[_out++] = here & 65535;
              } else if (op & 16) {
                len = here & 65535;
                op &= 15;
                if (op) {
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                  }
                  len += hold & (1 << op) - 1;
                  hold >>>= op;
                  bits -= op;
                }
                if (bits < 15) {
                  hold += input[_in++] << bits;
                  bits += 8;
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                here = dcode[hold & dmask];
                dodist:
                  for (; ; ) {
                    op = here >>> 24;
                    hold >>>= op;
                    bits -= op;
                    op = here >>> 16 & 255;
                    if (op & 16) {
                      dist = here & 65535;
                      op &= 15;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                        if (bits < op) {
                          hold += input[_in++] << bits;
                          bits += 8;
                        }
                      }
                      dist += hold & (1 << op) - 1;
                      if (dist > dmax) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD;
                        break top;
                      }
                      hold >>>= op;
                      bits -= op;
                      op = _out - beg;
                      if (dist > op) {
                        op = dist - op;
                        if (op > whave) {
                          if (state.sane) {
                            strm.msg = "invalid distance too far back";
                            state.mode = BAD;
                            break top;
                          }
                        }
                        from = 0;
                        from_source = s_window;
                        if (wnext === 0) {
                          from += wsize - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        } else if (wnext < op) {
                          from += wsize + wnext - op;
                          op -= wnext;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = 0;
                            if (wnext < len) {
                              op = wnext;
                              len -= op;
                              do {
                                output[_out++] = s_window[from++];
                              } while (--op);
                              from = _out - dist;
                              from_source = output;
                            }
                          }
                        } else {
                          from += wnext - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        }
                        while (len > 2) {
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          len -= 3;
                        }
                        if (len) {
                          output[_out++] = from_source[from++];
                          if (len > 1) {
                            output[_out++] = from_source[from++];
                          }
                        }
                      } else {
                        from = _out - dist;
                        do {
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          len -= 3;
                        } while (len > 2);
                        if (len) {
                          output[_out++] = output[from++];
                          if (len > 1) {
                            output[_out++] = output[from++];
                          }
                        }
                      }
                    } else if ((op & 64) === 0) {
                      here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                      continue dodist;
                    } else {
                      strm.msg = "invalid distance code";
                      state.mode = BAD;
                      break top;
                    }
                    break;
                  }
              } else if ((op & 64) === 0) {
                here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                continue dolen;
              } else if (op & 32) {
                state.mode = TYPE;
                break top;
              } else {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break top;
              }
              break;
            }
        } while (_in < last && _out < end);
      len = bits >> 3;
      _in -= len;
      bits -= len << 3;
      hold &= (1 << bits) - 1;
      strm.next_in = _in;
      strm.next_out = _out;
      strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
      strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
      state.hold = hold;
      state.bits = bits;
      return;
    };
  }
});

// node_modules/eosjs/node_modules/pako/lib/zlib/inftrees.js
var require_inftrees = __commonJS({
  "node_modules/eosjs/node_modules/pako/lib/zlib/inftrees.js"(exports, module) {
    "use strict";
    var MAXBITS = 15;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var lbase = new Uint16Array([
      /* Length codes 257..285 base */
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      13,
      15,
      17,
      19,
      23,
      27,
      31,
      35,
      43,
      51,
      59,
      67,
      83,
      99,
      115,
      131,
      163,
      195,
      227,
      258,
      0,
      0
    ]);
    var lext = new Uint8Array([
      /* Length codes 257..285 extra */
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      17,
      17,
      17,
      17,
      18,
      18,
      18,
      18,
      19,
      19,
      19,
      19,
      20,
      20,
      20,
      20,
      21,
      21,
      21,
      21,
      16,
      72,
      78
    ]);
    var dbase = new Uint16Array([
      /* Distance codes 0..29 base */
      1,
      2,
      3,
      4,
      5,
      7,
      9,
      13,
      17,
      25,
      33,
      49,
      65,
      97,
      129,
      193,
      257,
      385,
      513,
      769,
      1025,
      1537,
      2049,
      3073,
      4097,
      6145,
      8193,
      12289,
      16385,
      24577,
      0,
      0
    ]);
    var dext = new Uint8Array([
      /* Distance codes 0..29 extra */
      16,
      16,
      16,
      16,
      17,
      17,
      18,
      18,
      19,
      19,
      20,
      20,
      21,
      21,
      22,
      22,
      23,
      23,
      24,
      24,
      25,
      25,
      26,
      26,
      27,
      27,
      28,
      28,
      29,
      29,
      64,
      64
    ]);
    var inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) => {
      const bits = opts.bits;
      let len = 0;
      let sym = 0;
      let min = 0, max = 0;
      let root = 0;
      let curr = 0;
      let drop = 0;
      let left = 0;
      let used = 0;
      let huff = 0;
      let incr;
      let fill;
      let low;
      let mask;
      let next;
      let base = null;
      let base_index = 0;
      let end;
      const count = new Uint16Array(MAXBITS + 1);
      const offs = new Uint16Array(MAXBITS + 1);
      let extra = null;
      let extra_index = 0;
      let here_bits, here_op, here_val;
      for (len = 0; len <= MAXBITS; len++) {
        count[len] = 0;
      }
      for (sym = 0; sym < codes; sym++) {
        count[lens[lens_index + sym]]++;
      }
      root = bits;
      for (max = MAXBITS; max >= 1; max--) {
        if (count[max] !== 0) {
          break;
        }
      }
      if (root > max) {
        root = max;
      }
      if (max === 0) {
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        opts.bits = 1;
        return 0;
      }
      for (min = 1; min < max; min++) {
        if (count[min] !== 0) {
          break;
        }
      }
      if (root < min) {
        root = min;
      }
      left = 1;
      for (len = 1; len <= MAXBITS; len++) {
        left <<= 1;
        left -= count[len];
        if (left < 0) {
          return -1;
        }
      }
      if (left > 0 && (type === CODES || max !== 1)) {
        return -1;
      }
      offs[1] = 0;
      for (len = 1; len < MAXBITS; len++) {
        offs[len + 1] = offs[len] + count[len];
      }
      for (sym = 0; sym < codes; sym++) {
        if (lens[lens_index + sym] !== 0) {
          work[offs[lens[lens_index + sym]]++] = sym;
        }
      }
      if (type === CODES) {
        base = extra = work;
        end = 19;
      } else if (type === LENS) {
        base = lbase;
        base_index -= 257;
        extra = lext;
        extra_index -= 257;
        end = 256;
      } else {
        base = dbase;
        extra = dext;
        end = -1;
      }
      huff = 0;
      sym = 0;
      len = min;
      next = table_index;
      curr = root;
      drop = 0;
      low = -1;
      used = 1 << root;
      mask = used - 1;
      if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
        return 1;
      }
      for (; ; ) {
        here_bits = len - drop;
        if (work[sym] < end) {
          here_op = 0;
          here_val = work[sym];
        } else if (work[sym] > end) {
          here_op = extra[extra_index + work[sym]];
          here_val = base[base_index + work[sym]];
        } else {
          here_op = 32 + 64;
          here_val = 0;
        }
        incr = 1 << len - drop;
        fill = 1 << curr;
        min = fill;
        do {
          fill -= incr;
          table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
        } while (fill !== 0);
        incr = 1 << len - 1;
        while (huff & incr) {
          incr >>= 1;
        }
        if (incr !== 0) {
          huff &= incr - 1;
          huff += incr;
        } else {
          huff = 0;
        }
        sym++;
        if (--count[len] === 0) {
          if (len === max) {
            break;
          }
          len = lens[lens_index + work[sym]];
        }
        if (len > root && (huff & mask) !== low) {
          if (drop === 0) {
            drop = root;
          }
          next += min;
          curr = len - drop;
          left = 1 << curr;
          while (curr + drop < max) {
            left -= count[curr + drop];
            if (left <= 0) {
              break;
            }
            curr++;
            left <<= 1;
          }
          used += 1 << curr;
          if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
            return 1;
          }
          low = huff & mask;
          table[low] = root << 24 | curr << 16 | next - table_index | 0;
        }
      }
      if (huff !== 0) {
        table[next + huff] = len - drop << 24 | 64 << 16 | 0;
      }
      opts.bits = root;
      return 0;
    };
    module.exports = inflate_table;
  }
});

// node_modules/eosjs/node_modules/pako/lib/zlib/inflate.js
var require_inflate = __commonJS({
  "node_modules/eosjs/node_modules/pako/lib/zlib/inflate.js"(exports, module) {
    "use strict";
    var adler32 = require_adler32();
    var crc32 = require_crc32();
    var inflate_fast = require_inffast();
    var inflate_table = require_inftrees();
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var {
      Z_FINISH,
      Z_BLOCK,
      Z_TREES,
      Z_OK,
      Z_STREAM_END,
      Z_NEED_DICT,
      Z_STREAM_ERROR,
      Z_DATA_ERROR,
      Z_MEM_ERROR,
      Z_BUF_ERROR,
      Z_DEFLATED
    } = require_constants();
    var HEAD = 1;
    var FLAGS = 2;
    var TIME = 3;
    var OS = 4;
    var EXLEN = 5;
    var EXTRA = 6;
    var NAME = 7;
    var COMMENT = 8;
    var HCRC = 9;
    var DICTID = 10;
    var DICT = 11;
    var TYPE = 12;
    var TYPEDO = 13;
    var STORED = 14;
    var COPY_ = 15;
    var COPY = 16;
    var TABLE = 17;
    var LENLENS = 18;
    var CODELENS = 19;
    var LEN_ = 20;
    var LEN = 21;
    var LENEXT = 22;
    var DIST = 23;
    var DISTEXT = 24;
    var MATCH = 25;
    var LIT = 26;
    var CHECK = 27;
    var LENGTH = 28;
    var DONE = 29;
    var BAD = 30;
    var MEM = 31;
    var SYNC = 32;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var MAX_WBITS = 15;
    var DEF_WBITS = MAX_WBITS;
    var zswap32 = (q) => {
      return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
    };
    function InflateState() {
      this.mode = 0;
      this.last = false;
      this.wrap = 0;
      this.havedict = false;
      this.flags = 0;
      this.dmax = 0;
      this.check = 0;
      this.total = 0;
      this.head = null;
      this.wbits = 0;
      this.wsize = 0;
      this.whave = 0;
      this.wnext = 0;
      this.window = null;
      this.hold = 0;
      this.bits = 0;
      this.length = 0;
      this.offset = 0;
      this.extra = 0;
      this.lencode = null;
      this.distcode = null;
      this.lenbits = 0;
      this.distbits = 0;
      this.ncode = 0;
      this.nlen = 0;
      this.ndist = 0;
      this.have = 0;
      this.next = null;
      this.lens = new Uint16Array(320);
      this.work = new Uint16Array(288);
      this.lendyn = null;
      this.distdyn = null;
      this.sane = 0;
      this.back = 0;
      this.was = 0;
    }
    var inflateResetKeep = (strm) => {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      const state = strm.state;
      strm.total_in = strm.total_out = state.total = 0;
      strm.msg = "";
      if (state.wrap) {
        strm.adler = state.wrap & 1;
      }
      state.mode = HEAD;
      state.last = 0;
      state.havedict = 0;
      state.dmax = 32768;
      state.head = null;
      state.hold = 0;
      state.bits = 0;
      state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
      state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
      state.sane = 1;
      state.back = -1;
      return Z_OK;
    };
    var inflateReset = (strm) => {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      const state = strm.state;
      state.wsize = 0;
      state.whave = 0;
      state.wnext = 0;
      return inflateResetKeep(strm);
    };
    var inflateReset2 = (strm, windowBits) => {
      let wrap;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      const state = strm.state;
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else {
        wrap = (windowBits >> 4) + 1;
        if (windowBits < 48) {
          windowBits &= 15;
        }
      }
      if (windowBits && (windowBits < 8 || windowBits > 15)) {
        return Z_STREAM_ERROR;
      }
      if (state.window !== null && state.wbits !== windowBits) {
        state.window = null;
      }
      state.wrap = wrap;
      state.wbits = windowBits;
      return inflateReset(strm);
    };
    var inflateInit2 = (strm, windowBits) => {
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      const state = new InflateState();
      strm.state = state;
      state.window = null;
      const ret = inflateReset2(strm, windowBits);
      if (ret !== Z_OK) {
        strm.state = null;
      }
      return ret;
    };
    var inflateInit = (strm) => {
      return inflateInit2(strm, DEF_WBITS);
    };
    var virgin = true;
    var lenfix;
    var distfix;
    var fixedtables = (state) => {
      if (virgin) {
        lenfix = new Int32Array(512);
        distfix = new Int32Array(32);
        let sym = 0;
        while (sym < 144) {
          state.lens[sym++] = 8;
        }
        while (sym < 256) {
          state.lens[sym++] = 9;
        }
        while (sym < 280) {
          state.lens[sym++] = 7;
        }
        while (sym < 288) {
          state.lens[sym++] = 8;
        }
        inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
        sym = 0;
        while (sym < 32) {
          state.lens[sym++] = 5;
        }
        inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
        virgin = false;
      }
      state.lencode = lenfix;
      state.lenbits = 9;
      state.distcode = distfix;
      state.distbits = 5;
    };
    var updatewindow = (strm, src, end, copy) => {
      let dist;
      const state = strm.state;
      if (state.window === null) {
        state.wsize = 1 << state.wbits;
        state.wnext = 0;
        state.whave = 0;
        state.window = new Uint8Array(state.wsize);
      }
      if (copy >= state.wsize) {
        state.window.set(src.subarray(end - state.wsize, end), 0);
        state.wnext = 0;
        state.whave = state.wsize;
      } else {
        dist = state.wsize - state.wnext;
        if (dist > copy) {
          dist = copy;
        }
        state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
        copy -= dist;
        if (copy) {
          state.window.set(src.subarray(end - copy, end), 0);
          state.wnext = copy;
          state.whave = state.wsize;
        } else {
          state.wnext += dist;
          if (state.wnext === state.wsize) {
            state.wnext = 0;
          }
          if (state.whave < state.wsize) {
            state.whave += dist;
          }
        }
      }
      return 0;
    };
    var inflate = (strm, flush) => {
      let state;
      let input, output;
      let next;
      let put;
      let have, left;
      let hold;
      let bits;
      let _in, _out;
      let copy;
      let from;
      let from_source;
      let here = 0;
      let here_bits, here_op, here_val;
      let last_bits, last_op, last_val;
      let len;
      let ret;
      const hbuf = new Uint8Array(4);
      let opts;
      let n;
      const order = (
        /* permutation of code lengths */
        new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
      );
      if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.mode === TYPE) {
        state.mode = TYPEDO;
      }
      put = strm.next_out;
      output = strm.output;
      left = strm.avail_out;
      next = strm.next_in;
      input = strm.input;
      have = strm.avail_in;
      hold = state.hold;
      bits = state.bits;
      _in = have;
      _out = left;
      ret = Z_OK;
      inf_leave:
        for (; ; ) {
          switch (state.mode) {
            case HEAD:
              if (state.wrap === 0) {
                state.mode = TYPEDO;
                break;
              }
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.wrap & 2 && hold === 35615) {
                state.check = 0;
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
                hold = 0;
                bits = 0;
                state.mode = FLAGS;
                break;
              }
              state.flags = 0;
              if (state.head) {
                state.head.done = false;
              }
              if (!(state.wrap & 1) || /* check if zlib header allowed */
              (((hold & 255) << 8) + (hold >> 8)) % 31) {
                strm.msg = "incorrect header check";
                state.mode = BAD;
                break;
              }
              if ((hold & 15) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              hold >>>= 4;
              bits -= 4;
              len = (hold & 15) + 8;
              if (state.wbits === 0) {
                state.wbits = len;
              } else if (len > state.wbits) {
                strm.msg = "invalid window size";
                state.mode = BAD;
                break;
              }
              state.dmax = 1 << state.wbits;
              strm.adler = state.check = 1;
              state.mode = hold & 512 ? DICTID : TYPE;
              hold = 0;
              bits = 0;
              break;
            case FLAGS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.flags = hold;
              if ((state.flags & 255) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              if (state.flags & 57344) {
                strm.msg = "unknown header flags set";
                state.mode = BAD;
                break;
              }
              if (state.head) {
                state.head.text = hold >> 8 & 1;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = TIME;
            case TIME:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.time = hold;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                hbuf[2] = hold >>> 16 & 255;
                hbuf[3] = hold >>> 24 & 255;
                state.check = crc32(state.check, hbuf, 4, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = OS;
            case OS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.xflags = hold & 255;
                state.head.os = hold >> 8;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = EXLEN;
            case EXLEN:
              if (state.flags & 1024) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length = hold;
                if (state.head) {
                  state.head.extra_len = hold;
                }
                if (state.flags & 512) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
              } else if (state.head) {
                state.head.extra = null;
              }
              state.mode = EXTRA;
            case EXTRA:
              if (state.flags & 1024) {
                copy = state.length;
                if (copy > have) {
                  copy = have;
                }
                if (copy) {
                  if (state.head) {
                    len = state.head.extra_len - state.length;
                    if (!state.head.extra) {
                      state.head.extra = new Uint8Array(state.head.extra_len);
                    }
                    state.head.extra.set(
                      input.subarray(
                        next,
                        // extra field is limited to 65536 bytes
                        // - no need for additional size check
                        next + copy
                      ),
                      /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                      len
                    );
                  }
                  if (state.flags & 512) {
                    state.check = crc32(state.check, input, copy, next);
                  }
                  have -= copy;
                  next += copy;
                  state.length -= copy;
                }
                if (state.length) {
                  break inf_leave;
                }
              }
              state.length = 0;
              state.mode = NAME;
            case NAME:
              if (state.flags & 2048) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.name += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.name = null;
              }
              state.length = 0;
              state.mode = COMMENT;
            case COMMENT:
              if (state.flags & 4096) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.comment += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.comment = null;
              }
              state.mode = HCRC;
            case HCRC:
              if (state.flags & 512) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (hold !== (state.check & 65535)) {
                  strm.msg = "header crc mismatch";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              if (state.head) {
                state.head.hcrc = state.flags >> 9 & 1;
                state.head.done = true;
              }
              strm.adler = state.check = 0;
              state.mode = TYPE;
              break;
            case DICTID:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              strm.adler = state.check = zswap32(hold);
              hold = 0;
              bits = 0;
              state.mode = DICT;
            case DICT:
              if (state.havedict === 0) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                return Z_NEED_DICT;
              }
              strm.adler = state.check = 1;
              state.mode = TYPE;
            case TYPE:
              if (flush === Z_BLOCK || flush === Z_TREES) {
                break inf_leave;
              }
            case TYPEDO:
              if (state.last) {
                hold >>>= bits & 7;
                bits -= bits & 7;
                state.mode = CHECK;
                break;
              }
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.last = hold & 1;
              hold >>>= 1;
              bits -= 1;
              switch (hold & 3) {
                case 0:
                  state.mode = STORED;
                  break;
                case 1:
                  fixedtables(state);
                  state.mode = LEN_;
                  if (flush === Z_TREES) {
                    hold >>>= 2;
                    bits -= 2;
                    break inf_leave;
                  }
                  break;
                case 2:
                  state.mode = TABLE;
                  break;
                case 3:
                  strm.msg = "invalid block type";
                  state.mode = BAD;
              }
              hold >>>= 2;
              bits -= 2;
              break;
            case STORED:
              hold >>>= bits & 7;
              bits -= bits & 7;
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                strm.msg = "invalid stored block lengths";
                state.mode = BAD;
                break;
              }
              state.length = hold & 65535;
              hold = 0;
              bits = 0;
              state.mode = COPY_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            case COPY_:
              state.mode = COPY;
            case COPY:
              copy = state.length;
              if (copy) {
                if (copy > have) {
                  copy = have;
                }
                if (copy > left) {
                  copy = left;
                }
                if (copy === 0) {
                  break inf_leave;
                }
                output.set(input.subarray(next, next + copy), put);
                have -= copy;
                next += copy;
                left -= copy;
                put += copy;
                state.length -= copy;
                break;
              }
              state.mode = TYPE;
              break;
            case TABLE:
              while (bits < 14) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.nlen = (hold & 31) + 257;
              hold >>>= 5;
              bits -= 5;
              state.ndist = (hold & 31) + 1;
              hold >>>= 5;
              bits -= 5;
              state.ncode = (hold & 15) + 4;
              hold >>>= 4;
              bits -= 4;
              if (state.nlen > 286 || state.ndist > 30) {
                strm.msg = "too many length or distance symbols";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = LENLENS;
            case LENLENS:
              while (state.have < state.ncode) {
                while (bits < 3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.lens[order[state.have++]] = hold & 7;
                hold >>>= 3;
                bits -= 3;
              }
              while (state.have < 19) {
                state.lens[order[state.have++]] = 0;
              }
              state.lencode = state.lendyn;
              state.lenbits = 7;
              opts = { bits: state.lenbits };
              ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid code lengths set";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = CODELENS;
            case CODELENS:
              while (state.have < state.nlen + state.ndist) {
                for (; ; ) {
                  here = state.lencode[hold & (1 << state.lenbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (here_val < 16) {
                  hold >>>= here_bits;
                  bits -= here_bits;
                  state.lens[state.have++] = here_val;
                } else {
                  if (here_val === 16) {
                    n = here_bits + 2;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    if (state.have === 0) {
                      strm.msg = "invalid bit length repeat";
                      state.mode = BAD;
                      break;
                    }
                    len = state.lens[state.have - 1];
                    copy = 3 + (hold & 3);
                    hold >>>= 2;
                    bits -= 2;
                  } else if (here_val === 17) {
                    n = here_bits + 3;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 3 + (hold & 7);
                    hold >>>= 3;
                    bits -= 3;
                  } else {
                    n = here_bits + 7;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 11 + (hold & 127);
                    hold >>>= 7;
                    bits -= 7;
                  }
                  if (state.have + copy > state.nlen + state.ndist) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD;
                    break;
                  }
                  while (copy--) {
                    state.lens[state.have++] = len;
                  }
                }
              }
              if (state.mode === BAD) {
                break;
              }
              if (state.lens[256] === 0) {
                strm.msg = "invalid code -- missing end-of-block";
                state.mode = BAD;
                break;
              }
              state.lenbits = 9;
              opts = { bits: state.lenbits };
              ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid literal/lengths set";
                state.mode = BAD;
                break;
              }
              state.distbits = 6;
              state.distcode = state.distdyn;
              opts = { bits: state.distbits };
              ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
              state.distbits = opts.bits;
              if (ret) {
                strm.msg = "invalid distances set";
                state.mode = BAD;
                break;
              }
              state.mode = LEN_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            case LEN_:
              state.mode = LEN;
            case LEN:
              if (have >= 6 && left >= 258) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                inflate_fast(strm, _out);
                put = strm.next_out;
                output = strm.output;
                left = strm.avail_out;
                next = strm.next_in;
                input = strm.input;
                have = strm.avail_in;
                hold = state.hold;
                bits = state.bits;
                if (state.mode === TYPE) {
                  state.back = -1;
                }
                break;
              }
              state.back = 0;
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_op && (here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              state.length = here_val;
              if (here_op === 0) {
                state.mode = LIT;
                break;
              }
              if (here_op & 32) {
                state.back = -1;
                state.mode = TYPE;
                break;
              }
              if (here_op & 64) {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break;
              }
              state.extra = here_op & 15;
              state.mode = LENEXT;
            case LENEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              state.was = state.length;
              state.mode = DIST;
            case DIST:
              for (; ; ) {
                here = state.distcode[hold & (1 << state.distbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              if (here_op & 64) {
                strm.msg = "invalid distance code";
                state.mode = BAD;
                break;
              }
              state.offset = here_val;
              state.extra = here_op & 15;
              state.mode = DISTEXT;
            case DISTEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.offset += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              if (state.offset > state.dmax) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
              state.mode = MATCH;
            case MATCH:
              if (left === 0) {
                break inf_leave;
              }
              copy = _out - left;
              if (state.offset > copy) {
                copy = state.offset - copy;
                if (copy > state.whave) {
                  if (state.sane) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD;
                    break;
                  }
                }
                if (copy > state.wnext) {
                  copy -= state.wnext;
                  from = state.wsize - copy;
                } else {
                  from = state.wnext - copy;
                }
                if (copy > state.length) {
                  copy = state.length;
                }
                from_source = state.window;
              } else {
                from_source = output;
                from = put - state.offset;
                copy = state.length;
              }
              if (copy > left) {
                copy = left;
              }
              left -= copy;
              state.length -= copy;
              do {
                output[put++] = from_source[from++];
              } while (--copy);
              if (state.length === 0) {
                state.mode = LEN;
              }
              break;
            case LIT:
              if (left === 0) {
                break inf_leave;
              }
              output[put++] = state.length;
              left--;
              state.mode = LEN;
              break;
            case CHECK:
              if (state.wrap) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold |= input[next++] << bits;
                  bits += 8;
                }
                _out -= left;
                strm.total_out += _out;
                state.total += _out;
                if (_out) {
                  strm.adler = state.check = /*UPDATE(state.check, put - _out, _out);*/
                  state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
                }
                _out = left;
                if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                  strm.msg = "incorrect data check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = LENGTH;
            case LENGTH:
              if (state.wrap && state.flags) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (hold !== (state.total & 4294967295)) {
                  strm.msg = "incorrect length check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = DONE;
            case DONE:
              ret = Z_STREAM_END;
              break inf_leave;
            case BAD:
              ret = Z_DATA_ERROR;
              break inf_leave;
            case MEM:
              return Z_MEM_ERROR;
            case SYNC:
            default:
              return Z_STREAM_ERROR;
          }
        }
      strm.next_out = put;
      strm.avail_out = left;
      strm.next_in = next;
      strm.avail_in = have;
      state.hold = hold;
      state.bits = bits;
      if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
        if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
          state.mode = MEM;
          return Z_MEM_ERROR;
        }
      }
      _in -= strm.avail_in;
      _out -= strm.avail_out;
      strm.total_in += _in;
      strm.total_out += _out;
      state.total += _out;
      if (state.wrap && _out) {
        strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
        state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
      }
      strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
      if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
        ret = Z_BUF_ERROR;
      }
      return ret;
    };
    var inflateEnd = (strm) => {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      let state = strm.state;
      if (state.window) {
        state.window = null;
      }
      strm.state = null;
      return Z_OK;
    };
    var inflateGetHeader = (strm, head) => {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      const state = strm.state;
      if ((state.wrap & 2) === 0) {
        return Z_STREAM_ERROR;
      }
      state.head = head;
      head.done = false;
      return Z_OK;
    };
    var inflateSetDictionary = (strm, dictionary) => {
      const dictLength = dictionary.length;
      let state;
      let dictid;
      let ret;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.wrap !== 0 && state.mode !== DICT) {
        return Z_STREAM_ERROR;
      }
      if (state.mode === DICT) {
        dictid = 1;
        dictid = adler32(dictid, dictionary, dictLength, 0);
        if (dictid !== state.check) {
          return Z_DATA_ERROR;
        }
      }
      ret = updatewindow(strm, dictionary, dictLength, dictLength);
      if (ret) {
        state.mode = MEM;
        return Z_MEM_ERROR;
      }
      state.havedict = 1;
      return Z_OK;
    };
    module.exports.inflateReset = inflateReset;
    module.exports.inflateReset2 = inflateReset2;
    module.exports.inflateResetKeep = inflateResetKeep;
    module.exports.inflateInit = inflateInit;
    module.exports.inflateInit2 = inflateInit2;
    module.exports.inflate = inflate;
    module.exports.inflateEnd = inflateEnd;
    module.exports.inflateGetHeader = inflateGetHeader;
    module.exports.inflateSetDictionary = inflateSetDictionary;
    module.exports.inflateInfo = "pako inflate (from Nodeca project)";
  }
});

// node_modules/eosjs/node_modules/pako/lib/zlib/gzheader.js
var require_gzheader = __commonJS({
  "node_modules/eosjs/node_modules/pako/lib/zlib/gzheader.js"(exports, module) {
    "use strict";
    function GZheader() {
      this.text = 0;
      this.time = 0;
      this.xflags = 0;
      this.os = 0;
      this.extra = null;
      this.extra_len = 0;
      this.name = "";
      this.comment = "";
      this.hcrc = 0;
      this.done = false;
    }
    module.exports = GZheader;
  }
});

// node_modules/eosjs/node_modules/pako/lib/inflate.js
var require_inflate2 = __commonJS({
  "node_modules/eosjs/node_modules/pako/lib/inflate.js"(exports, module) {
    "use strict";
    var zlib_inflate = require_inflate();
    var utils = require_common();
    var strings = require_strings();
    var msg = require_messages();
    var ZStream = require_zstream();
    var GZheader = require_gzheader();
    var toString = Object.prototype.toString;
    var {
      Z_NO_FLUSH,
      Z_FINISH,
      Z_OK,
      Z_STREAM_END,
      Z_NEED_DICT,
      Z_STREAM_ERROR,
      Z_DATA_ERROR,
      Z_MEM_ERROR
    } = require_constants();
    function Inflate(options) {
      this.options = utils.assign({
        chunkSize: 1024 * 64,
        windowBits: 15,
        to: ""
      }, options || {});
      const opt = this.options;
      if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
        opt.windowBits = -opt.windowBits;
        if (opt.windowBits === 0) {
          opt.windowBits = -15;
        }
      }
      if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
        opt.windowBits += 32;
      }
      if (opt.windowBits > 15 && opt.windowBits < 48) {
        if ((opt.windowBits & 15) === 0) {
          opt.windowBits |= 15;
        }
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      let status = zlib_inflate.inflateInit2(
        this.strm,
        opt.windowBits
      );
      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }
      this.header = new GZheader();
      zlib_inflate.inflateGetHeader(this.strm, this.header);
      if (opt.dictionary) {
        if (typeof opt.dictionary === "string") {
          opt.dictionary = strings.string2buf(opt.dictionary);
        } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
          opt.dictionary = new Uint8Array(opt.dictionary);
        }
        if (opt.raw) {
          status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
          if (status !== Z_OK) {
            throw new Error(msg[status]);
          }
        }
      }
    }
    Inflate.prototype.push = function(data, flush_mode) {
      const strm = this.strm;
      const chunkSize = this.options.chunkSize;
      const dictionary = this.options.dictionary;
      let status, _flush_mode, last_avail_out;
      if (this.ended)
        return false;
      if (flush_mode === ~~flush_mode)
        _flush_mode = flush_mode;
      else
        _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
      if (toString.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      for (; ; ) {
        if (strm.avail_out === 0) {
          strm.output = new Uint8Array(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        status = zlib_inflate.inflate(strm, _flush_mode);
        if (status === Z_NEED_DICT && dictionary) {
          status = zlib_inflate.inflateSetDictionary(strm, dictionary);
          if (status === Z_OK) {
            status = zlib_inflate.inflate(strm, _flush_mode);
          } else if (status === Z_DATA_ERROR) {
            status = Z_NEED_DICT;
          }
        }
        while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
          zlib_inflate.inflateReset(strm);
          status = zlib_inflate.inflate(strm, _flush_mode);
        }
        switch (status) {
          case Z_STREAM_ERROR:
          case Z_DATA_ERROR:
          case Z_NEED_DICT:
          case Z_MEM_ERROR:
            this.onEnd(status);
            this.ended = true;
            return false;
        }
        last_avail_out = strm.avail_out;
        if (strm.next_out) {
          if (strm.avail_out === 0 || status === Z_STREAM_END) {
            if (this.options.to === "string") {
              let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
              let tail = strm.next_out - next_out_utf8;
              let utf8str = strings.buf2string(strm.output, next_out_utf8);
              strm.next_out = tail;
              strm.avail_out = chunkSize - tail;
              if (tail)
                strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
              this.onData(utf8str);
            } else {
              this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
            }
          }
        }
        if (status === Z_OK && last_avail_out === 0)
          continue;
        if (status === Z_STREAM_END) {
          status = zlib_inflate.inflateEnd(this.strm);
          this.onEnd(status);
          this.ended = true;
          return true;
        }
        if (strm.avail_in === 0)
          break;
      }
      return true;
    };
    Inflate.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Inflate.prototype.onEnd = function(status) {
      if (status === Z_OK) {
        if (this.options.to === "string") {
          this.result = this.chunks.join("");
        } else {
          this.result = utils.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function inflate(input, options) {
      const inflator = new Inflate(options);
      inflator.push(input);
      if (inflator.err)
        throw inflator.msg || msg[inflator.err];
      return inflator.result;
    }
    function inflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return inflate(input, options);
    }
    module.exports.Inflate = Inflate;
    module.exports.inflate = inflate;
    module.exports.inflateRaw = inflateRaw;
    module.exports.ungzip = inflate;
    module.exports.constants = require_constants();
  }
});

// node_modules/eosjs/node_modules/pako/index.js
var require_pako = __commonJS({
  "node_modules/eosjs/node_modules/pako/index.js"(exports, module) {
    "use strict";
    var { Deflate, deflate, deflateRaw, gzip } = require_deflate2();
    var { Inflate, inflate, inflateRaw, ungzip } = require_inflate2();
    var constants = require_constants();
    module.exports.Deflate = Deflate;
    module.exports.deflate = deflate;
    module.exports.deflateRaw = deflateRaw;
    module.exports.gzip = gzip;
    module.exports.Inflate = Inflate;
    module.exports.inflate = inflate;
    module.exports.inflateRaw = inflateRaw;
    module.exports.ungzip = ungzip;
    module.exports.constants = constants;
  }
});

// node_modules/eosjs/dist/ripemd.js
var require_ripemd = __commonJS({
  "node_modules/eosjs/dist/ripemd.js"(exports, module) {
    "use strict";
    var _slicedToArray = function() {
      function sliceIterator(arr, i) {
        var _arr = [];
        var _n = true;
        var _d = false;
        var _e = void 0;
        try {
          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);
            if (i && _arr.length === i)
              break;
          }
        } catch (err) {
          _d = true;
          _e = err;
        } finally {
          try {
            if (!_n && _i["return"])
              _i["return"]();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
      return function(arr, i) {
        if (Array.isArray(arr)) {
          return arr;
        } else if (Symbol.iterator in Object(arr)) {
          return sliceIterator(arr, i);
        } else {
          throw new TypeError("Invalid attempt to destructure non-iterable instance");
        }
      };
    }();
    var _createClass = function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var RIPEMD160 = function() {
      function RIPEMD1602() {
        _classCallCheck(this, RIPEMD1602);
      }
      _createClass(RIPEMD1602, null, [{
        key: "get_n_pad_bytes",
        value: function get_n_pad_bytes(message_size) {
          return 64 - (message_size + 8 & 63);
        }
      }, {
        key: "pad",
        value: function pad(message) {
          var message_size = message.byteLength;
          var n_pad = RIPEMD1602.get_n_pad_bytes(message_size);
          var divmod = function divmod2(dividend, divisor) {
            return [Math.floor(dividend / divisor), dividend % divisor];
          };
          var _divmod$map = divmod(
            message_size,
            536870912
            /* (2 ** 29) */
          ).map(function(x, index) {
            return index ? x * 8 : x;
          }), _divmod$map2 = _slicedToArray(_divmod$map, 2), msg_bit_size_most = _divmod$map2[0], msg_bit_size_least = _divmod$map2[1];
          var padded = new Uint8Array(message_size + n_pad + 8);
          padded.set(new Uint8Array(message), 0);
          var data_view = new DataView(padded.buffer);
          data_view.setUint8(message_size, 128);
          data_view.setUint32(
            message_size + n_pad,
            msg_bit_size_least,
            true
            // Little-endian
          );
          data_view.setUint32(
            message_size + n_pad + 4,
            msg_bit_size_most,
            true
            // Little-endian
          );
          return padded.buffer;
        }
      }, {
        key: "f",
        value: function f(j, x, y, z) {
          if (0 <= j && j <= 15) {
            return x ^ y ^ z;
          }
          if (16 <= j && j <= 31) {
            return x & y | ~x & z;
          }
          if (32 <= j && j <= 47) {
            return (x | ~y) ^ z;
          }
          if (48 <= j && j <= 63) {
            return x & z | y & ~z;
          }
          if (64 <= j && j <= 79) {
            return x ^ (y | ~z);
          }
        }
      }, {
        key: "K",
        value: function K(j) {
          if (0 <= j && j <= 15) {
            return 0;
          }
          if (16 <= j && j <= 31) {
            return 1518500249;
          }
          if (32 <= j && j <= 47) {
            return 1859775393;
          }
          if (48 <= j && j <= 63) {
            return 2400959708;
          }
          if (64 <= j && j <= 79) {
            return 2840853838;
          }
        }
      }, {
        key: "KP",
        value: function KP(j) {
          if (0 <= j && j <= 15) {
            return 1352829926;
          }
          if (16 <= j && j <= 31) {
            return 1548603684;
          }
          if (32 <= j && j <= 47) {
            return 1836072691;
          }
          if (48 <= j && j <= 63) {
            return 2053994217;
          }
          if (64 <= j && j <= 79) {
            return 0;
          }
        }
      }, {
        key: "add_modulo32",
        value: function add_modulo32() {
          return Array.from(arguments).reduce(function(a, b) {
            return a + b;
          }, 0) | 0;
        }
      }, {
        key: "rol32",
        value: function rol32(value, count) {
          return value << count | value >>> 32 - count;
        }
      }, {
        key: "hash",
        value: function hash(message) {
          var padded = RIPEMD1602.pad(message);
          var r = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13];
          var rP = [
            // r'
            5,
            14,
            7,
            0,
            9,
            2,
            11,
            4,
            13,
            6,
            15,
            8,
            1,
            10,
            3,
            12,
            6,
            11,
            3,
            7,
            0,
            13,
            5,
            10,
            14,
            15,
            8,
            12,
            4,
            9,
            1,
            2,
            15,
            5,
            1,
            3,
            7,
            14,
            6,
            9,
            11,
            8,
            12,
            2,
            10,
            0,
            4,
            13,
            8,
            6,
            4,
            1,
            3,
            11,
            15,
            0,
            5,
            12,
            2,
            13,
            9,
            7,
            10,
            14,
            12,
            15,
            10,
            4,
            1,
            5,
            8,
            7,
            6,
            2,
            13,
            14,
            0,
            3,
            9,
            11
          ];
          var s = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6];
          var sP = [
            // s'
            8,
            9,
            9,
            11,
            13,
            15,
            15,
            5,
            7,
            7,
            8,
            11,
            14,
            14,
            12,
            6,
            9,
            13,
            15,
            7,
            12,
            8,
            9,
            11,
            7,
            7,
            12,
            7,
            6,
            15,
            13,
            11,
            9,
            7,
            15,
            11,
            8,
            6,
            6,
            14,
            12,
            13,
            5,
            14,
            13,
            13,
            7,
            5,
            15,
            5,
            8,
            11,
            14,
            14,
            6,
            14,
            6,
            9,
            12,
            9,
            12,
            5,
            15,
            8,
            8,
            5,
            12,
            9,
            12,
            5,
            14,
            6,
            8,
            13,
            6,
            5,
            15,
            13,
            11,
            11
          ];
          var word_size = 4;
          var block_size = 64;
          var t = padded.byteLength / block_size;
          var X = new Array(t).fill(void 0).map(function(_, i2) {
            return function(j2) {
              return new DataView(padded, i2 * block_size, block_size).getUint32(
                j2 * word_size,
                true
                // Little-endian
              );
            };
          });
          var h = [
            1732584193,
            // h_0
            4023233417,
            // h_1
            2562383102,
            // h_2
            271733878,
            // h_3
            3285377520
            // h_4
          ];
          for (var i = 0; i < t; ++i) {
            var A = h[0], B = h[1], C = h[2], D = h[3], E = h[4];
            var AP = A, BP = B, CP = C, DP = D, EP = E;
            for (var j = 0; j < 80; ++j) {
              var _T = RIPEMD1602.add_modulo32(RIPEMD1602.rol32(RIPEMD1602.add_modulo32(A, RIPEMD1602.f(j, B, C, D), X[i](r[j]), RIPEMD1602.K(j)), s[j]), E);
              A = E;
              E = D;
              D = RIPEMD1602.rol32(C, 10);
              C = B;
              B = _T;
              _T = RIPEMD1602.add_modulo32(RIPEMD1602.rol32(RIPEMD1602.add_modulo32(AP, RIPEMD1602.f(79 - j, BP, CP, DP), X[i](rP[j]), RIPEMD1602.KP(j)), sP[j]), EP);
              AP = EP;
              EP = DP;
              DP = RIPEMD1602.rol32(CP, 10);
              CP = BP;
              BP = _T;
            }
            var T = RIPEMD1602.add_modulo32(h[1], C, DP);
            h[1] = RIPEMD1602.add_modulo32(h[2], D, EP);
            h[2] = RIPEMD1602.add_modulo32(h[3], E, AP);
            h[3] = RIPEMD1602.add_modulo32(h[4], A, BP);
            h[4] = RIPEMD1602.add_modulo32(h[0], B, CP);
            h[0] = T;
          }
          var result = new ArrayBuffer(20);
          var data_view = new DataView(result);
          h.forEach(function(h_i, i2) {
            return data_view.setUint32(i2 * 4, h_i, true);
          });
          return result;
        }
      }]);
      return RIPEMD1602;
    }();
    module.exports = {
      RIPEMD160
    };
  }
});

// node_modules/eosjs/dist/eosjs-numeric.js
var require_eosjs_numeric = __commonJS({
  "node_modules/eosjs/dist/eosjs-numeric.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    var __values = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.signatureToString = exports.stringToSignature = exports.privateKeyToString = exports.privateKeyToLegacyString = exports.stringToPrivateKey = exports.convertLegacyPublicKeys = exports.convertLegacyPublicKey = exports.publicKeyToString = exports.publicKeyToLegacyString = exports.stringToPublicKey = exports.signatureDataSize = exports.privateKeyDataSize = exports.publicKeyDataSize = exports.KeyType = exports.base64ToBinary = exports.binaryToBase58 = exports.base58ToBinary = exports.signedBinaryToDecimal = exports.binaryToDecimal = exports.signedDecimalToBinary = exports.decimalToBinary = exports.negate = exports.isNegative = void 0;
    var hash_js_1 = require_hash();
    var ripemd160 = require_ripemd().RIPEMD160.hash;
    var base58Chars = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    var base64Chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    var create_base58_map = function() {
      var base58M = Array(256).fill(-1);
      for (var i = 0; i < base58Chars.length; ++i) {
        base58M[base58Chars.charCodeAt(i)] = i;
      }
      return base58M;
    };
    var base58Map = create_base58_map();
    var create_base64_map = function() {
      var base64M = Array(256).fill(-1);
      for (var i = 0; i < base64Chars.length; ++i) {
        base64M[base64Chars.charCodeAt(i)] = i;
      }
      base64M["=".charCodeAt(0)] = 0;
      return base64M;
    };
    var base64Map = create_base64_map();
    var isNegative = function(bignum) {
      return (bignum[bignum.length - 1] & 128) !== 0;
    };
    exports.isNegative = isNegative;
    var negate = function(bignum) {
      var carry = 1;
      for (var i = 0; i < bignum.length; ++i) {
        var x = (~bignum[i] & 255) + carry;
        bignum[i] = x;
        carry = x >> 8;
      }
    };
    exports.negate = negate;
    var decimalToBinary = function(size, s) {
      var result = new Uint8Array(size);
      for (var i = 0; i < s.length; ++i) {
        var srcDigit = s.charCodeAt(i);
        if (srcDigit < "0".charCodeAt(0) || srcDigit > "9".charCodeAt(0)) {
          throw new Error("invalid number");
        }
        var carry = srcDigit - "0".charCodeAt(0);
        for (var j = 0; j < size; ++j) {
          var x = result[j] * 10 + carry;
          result[j] = x;
          carry = x >> 8;
        }
        if (carry) {
          throw new Error("number is out of range");
        }
      }
      return result;
    };
    exports.decimalToBinary = decimalToBinary;
    var signedDecimalToBinary = function(size, s) {
      var negative = s[0] === "-";
      if (negative) {
        s = s.substr(1);
      }
      var result = exports.decimalToBinary(size, s);
      if (negative) {
        exports.negate(result);
        if (!exports.isNegative(result)) {
          throw new Error("number is out of range");
        }
      } else if (exports.isNegative(result)) {
        throw new Error("number is out of range");
      }
      return result;
    };
    exports.signedDecimalToBinary = signedDecimalToBinary;
    var binaryToDecimal = function(bignum, minDigits) {
      if (minDigits === void 0) {
        minDigits = 1;
      }
      var result = Array(minDigits).fill("0".charCodeAt(0));
      for (var i = bignum.length - 1; i >= 0; --i) {
        var carry = bignum[i];
        for (var j = 0; j < result.length; ++j) {
          var x = (result[j] - "0".charCodeAt(0) << 8) + carry;
          result[j] = "0".charCodeAt(0) + x % 10;
          carry = x / 10 | 0;
        }
        while (carry) {
          result.push("0".charCodeAt(0) + carry % 10);
          carry = carry / 10 | 0;
        }
      }
      result.reverse();
      return String.fromCharCode.apply(String, __spreadArray([], __read(result)));
    };
    exports.binaryToDecimal = binaryToDecimal;
    var signedBinaryToDecimal = function(bignum, minDigits) {
      if (minDigits === void 0) {
        minDigits = 1;
      }
      if (exports.isNegative(bignum)) {
        var x = bignum.slice();
        exports.negate(x);
        return "-" + exports.binaryToDecimal(x, minDigits);
      }
      return exports.binaryToDecimal(bignum, minDigits);
    };
    exports.signedBinaryToDecimal = signedBinaryToDecimal;
    var base58ToBinaryVarSize = function(s) {
      var e_1, _a;
      var result = [];
      for (var i = 0; i < s.length; ++i) {
        var carry = base58Map[s.charCodeAt(i)];
        if (carry < 0) {
          throw new Error("invalid base-58 value");
        }
        for (var j = 0; j < result.length; ++j) {
          var x = result[j] * 58 + carry;
          result[j] = x & 255;
          carry = x >> 8;
        }
        if (carry) {
          result.push(carry);
        }
      }
      try {
        for (var s_1 = __values(s), s_1_1 = s_1.next(); !s_1_1.done; s_1_1 = s_1.next()) {
          var ch = s_1_1.value;
          if (ch === "1") {
            result.push(0);
          } else {
            break;
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (s_1_1 && !s_1_1.done && (_a = s_1.return))
            _a.call(s_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      result.reverse();
      return new Uint8Array(result);
    };
    var base58ToBinary = function(size, s) {
      if (!size) {
        return base58ToBinaryVarSize(s);
      }
      var result = new Uint8Array(size);
      for (var i = 0; i < s.length; ++i) {
        var carry = base58Map[s.charCodeAt(i)];
        if (carry < 0) {
          throw new Error("invalid base-58 value");
        }
        for (var j = 0; j < size; ++j) {
          var x = result[j] * 58 + carry;
          result[j] = x;
          carry = x >> 8;
        }
        if (carry) {
          throw new Error("base-58 value is out of range");
        }
      }
      result.reverse();
      return result;
    };
    exports.base58ToBinary = base58ToBinary;
    var binaryToBase58 = function(bignum, minDigits) {
      var e_2, _a, e_3, _b;
      if (minDigits === void 0) {
        minDigits = 1;
      }
      var result = [];
      try {
        for (var bignum_1 = __values(bignum), bignum_1_1 = bignum_1.next(); !bignum_1_1.done; bignum_1_1 = bignum_1.next()) {
          var byte = bignum_1_1.value;
          var carry = byte;
          for (var j = 0; j < result.length; ++j) {
            var x = (base58Map[result[j]] << 8) + carry;
            result[j] = base58Chars.charCodeAt(x % 58);
            carry = x / 58 | 0;
          }
          while (carry) {
            result.push(base58Chars.charCodeAt(carry % 58));
            carry = carry / 58 | 0;
          }
        }
      } catch (e_2_1) {
        e_2 = { error: e_2_1 };
      } finally {
        try {
          if (bignum_1_1 && !bignum_1_1.done && (_a = bignum_1.return))
            _a.call(bignum_1);
        } finally {
          if (e_2)
            throw e_2.error;
        }
      }
      try {
        for (var bignum_2 = __values(bignum), bignum_2_1 = bignum_2.next(); !bignum_2_1.done; bignum_2_1 = bignum_2.next()) {
          var byte = bignum_2_1.value;
          if (byte) {
            break;
          } else {
            result.push("1".charCodeAt(0));
          }
        }
      } catch (e_3_1) {
        e_3 = { error: e_3_1 };
      } finally {
        try {
          if (bignum_2_1 && !bignum_2_1.done && (_b = bignum_2.return))
            _b.call(bignum_2);
        } finally {
          if (e_3)
            throw e_3.error;
        }
      }
      result.reverse();
      return String.fromCharCode.apply(String, __spreadArray([], __read(result)));
    };
    exports.binaryToBase58 = binaryToBase58;
    var base64ToBinary = function(s) {
      var len = s.length;
      if ((len & 3) === 1 && s[len - 1] === "=") {
        len -= 1;
      }
      if ((len & 3) !== 0) {
        throw new Error("base-64 value is not padded correctly");
      }
      var groups = len >> 2;
      var bytes = groups * 3;
      if (len > 0 && s[len - 1] === "=") {
        if (s[len - 2] === "=") {
          bytes -= 2;
        } else {
          bytes -= 1;
        }
      }
      var result = new Uint8Array(bytes);
      for (var group = 0; group < groups; ++group) {
        var digit0 = base64Map[s.charCodeAt(group * 4 + 0)];
        var digit1 = base64Map[s.charCodeAt(group * 4 + 1)];
        var digit2 = base64Map[s.charCodeAt(group * 4 + 2)];
        var digit3 = base64Map[s.charCodeAt(group * 4 + 3)];
        result[group * 3 + 0] = digit0 << 2 | digit1 >> 4;
        if (group * 3 + 1 < bytes) {
          result[group * 3 + 1] = (digit1 & 15) << 4 | digit2 >> 2;
        }
        if (group * 3 + 2 < bytes) {
          result[group * 3 + 2] = (digit2 & 3) << 6 | digit3;
        }
      }
      return result;
    };
    exports.base64ToBinary = base64ToBinary;
    var KeyType;
    (function(KeyType2) {
      KeyType2[KeyType2["k1"] = 0] = "k1";
      KeyType2[KeyType2["r1"] = 1] = "r1";
      KeyType2[KeyType2["wa"] = 2] = "wa";
    })(KeyType = exports.KeyType || (exports.KeyType = {}));
    exports.publicKeyDataSize = 33;
    exports.privateKeyDataSize = 32;
    exports.signatureDataSize = 65;
    var digestSuffixRipemd160 = function(data, suffix) {
      var d = new Uint8Array(data.length + suffix.length);
      for (var i = 0; i < data.length; ++i) {
        d[i] = data[i];
      }
      for (var i = 0; i < suffix.length; ++i) {
        d[data.length + i] = suffix.charCodeAt(i);
      }
      return ripemd160(d);
    };
    var stringToKey = function(s, type, size, suffix) {
      var whole = exports.base58ToBinary(size ? size + 4 : 0, s);
      var result = { type, data: new Uint8Array(whole.buffer, 0, whole.length - 4) };
      var digest = new Uint8Array(digestSuffixRipemd160(result.data, suffix));
      if (digest[0] !== whole[whole.length - 4] || digest[1] !== whole[whole.length - 3] || digest[2] !== whole[whole.length - 2] || digest[3] !== whole[whole.length - 1]) {
        throw new Error("checksum doesn't match");
      }
      return result;
    };
    var keyToString = function(key, suffix, prefix) {
      var digest = new Uint8Array(digestSuffixRipemd160(key.data, suffix));
      var whole = new Uint8Array(key.data.length + 4);
      for (var i = 0; i < key.data.length; ++i) {
        whole[i] = key.data[i];
      }
      for (var i = 0; i < 4; ++i) {
        whole[i + key.data.length] = digest[i];
      }
      return prefix + exports.binaryToBase58(whole);
    };
    var stringToPublicKey = function(s) {
      if (typeof s !== "string") {
        throw new Error("expected string containing public key");
      }
      if (s.substr(0, 3) === "EOS") {
        var whole = exports.base58ToBinary(exports.publicKeyDataSize + 4, s.substr(3));
        var key = { type: KeyType.k1, data: new Uint8Array(exports.publicKeyDataSize) };
        for (var i = 0; i < exports.publicKeyDataSize; ++i) {
          key.data[i] = whole[i];
        }
        var digest = new Uint8Array(ripemd160(key.data));
        if (digest[0] !== whole[exports.publicKeyDataSize] || digest[1] !== whole[34] || digest[2] !== whole[35] || digest[3] !== whole[36]) {
          throw new Error("checksum doesn't match");
        }
        return key;
      } else if (s.substr(0, 7) === "PUB_K1_") {
        return stringToKey(s.substr(7), KeyType.k1, exports.publicKeyDataSize, "K1");
      } else if (s.substr(0, 7) === "PUB_R1_") {
        return stringToKey(s.substr(7), KeyType.r1, exports.publicKeyDataSize, "R1");
      } else if (s.substr(0, 7) === "PUB_WA_") {
        return stringToKey(s.substr(7), KeyType.wa, 0, "WA");
      } else {
        throw new Error("unrecognized public key format");
      }
    };
    exports.stringToPublicKey = stringToPublicKey;
    var publicKeyToLegacyString = function(key) {
      if (key.type === KeyType.k1 && key.data.length === exports.publicKeyDataSize) {
        return keyToString(key, "", "EOS");
      } else if (key.type === KeyType.r1 || key.type === KeyType.wa) {
        throw new Error("Key format not supported in legacy conversion");
      } else {
        throw new Error("unrecognized public key format");
      }
    };
    exports.publicKeyToLegacyString = publicKeyToLegacyString;
    var publicKeyToString = function(key) {
      if (key.type === KeyType.k1 && key.data.length === exports.publicKeyDataSize) {
        return keyToString(key, "K1", "PUB_K1_");
      } else if (key.type === KeyType.r1 && key.data.length === exports.publicKeyDataSize) {
        return keyToString(key, "R1", "PUB_R1_");
      } else if (key.type === KeyType.wa) {
        return keyToString(key, "WA", "PUB_WA_");
      } else {
        throw new Error("unrecognized public key format");
      }
    };
    exports.publicKeyToString = publicKeyToString;
    var convertLegacyPublicKey = function(s) {
      if (s.substr(0, 3) === "EOS") {
        return exports.publicKeyToString(exports.stringToPublicKey(s));
      }
      return s;
    };
    exports.convertLegacyPublicKey = convertLegacyPublicKey;
    var convertLegacyPublicKeys = function(keys) {
      return keys.map(exports.convertLegacyPublicKey);
    };
    exports.convertLegacyPublicKeys = convertLegacyPublicKeys;
    var stringToPrivateKey = function(s) {
      if (typeof s !== "string") {
        throw new Error("expected string containing private key");
      }
      if (s.substr(0, 7) === "PVT_R1_") {
        return stringToKey(s.substr(7), KeyType.r1, exports.privateKeyDataSize, "R1");
      } else if (s.substr(0, 7) === "PVT_K1_") {
        return stringToKey(s.substr(7), KeyType.k1, exports.privateKeyDataSize, "K1");
      } else {
        var whole = exports.base58ToBinary(exports.privateKeyDataSize + 5, s);
        var key = { type: KeyType.k1, data: new Uint8Array(exports.privateKeyDataSize) };
        if (whole[0] !== 128) {
          throw new Error("unrecognized private key type");
        }
        for (var i = 0; i < exports.privateKeyDataSize; ++i) {
          key.data[i] = whole[i + 1];
        }
        return key;
      }
    };
    exports.stringToPrivateKey = stringToPrivateKey;
    var privateKeyToLegacyString = function(key) {
      if (key.type === KeyType.k1 && key.data.length === exports.privateKeyDataSize) {
        var whole_1 = [];
        whole_1.push(128);
        key.data.forEach(function(byte) {
          return whole_1.push(byte);
        });
        var digest = new Uint8Array(hash_js_1.sha256().update(hash_js_1.sha256().update(whole_1).digest()).digest());
        var result = new Uint8Array(exports.privateKeyDataSize + 5);
        for (var i = 0; i < whole_1.length; i++) {
          result[i] = whole_1[i];
        }
        for (var i = 0; i < 4; i++) {
          result[i + whole_1.length] = digest[i];
        }
        return exports.binaryToBase58(result);
      } else if (key.type === KeyType.r1 || key.type === KeyType.wa) {
        throw new Error("Key format not supported in legacy conversion");
      } else {
        throw new Error("unrecognized public key format");
      }
    };
    exports.privateKeyToLegacyString = privateKeyToLegacyString;
    var privateKeyToString = function(key) {
      if (key.type === KeyType.r1) {
        return keyToString(key, "R1", "PVT_R1_");
      } else if (key.type === KeyType.k1) {
        return keyToString(key, "K1", "PVT_K1_");
      } else {
        throw new Error("unrecognized private key format");
      }
    };
    exports.privateKeyToString = privateKeyToString;
    var stringToSignature = function(s) {
      if (typeof s !== "string") {
        throw new Error("expected string containing signature");
      }
      if (s.substr(0, 7) === "SIG_K1_") {
        return stringToKey(s.substr(7), KeyType.k1, exports.signatureDataSize, "K1");
      } else if (s.substr(0, 7) === "SIG_R1_") {
        return stringToKey(s.substr(7), KeyType.r1, exports.signatureDataSize, "R1");
      } else if (s.substr(0, 7) === "SIG_WA_") {
        return stringToKey(s.substr(7), KeyType.wa, 0, "WA");
      } else {
        throw new Error("unrecognized signature format");
      }
    };
    exports.stringToSignature = stringToSignature;
    var signatureToString = function(signature) {
      if (signature.type === KeyType.k1) {
        return keyToString(signature, "K1", "SIG_K1_");
      } else if (signature.type === KeyType.r1) {
        return keyToString(signature, "R1", "SIG_R1_");
      } else if (signature.type === KeyType.wa) {
        return keyToString(signature, "WA", "SIG_WA_");
      } else {
        throw new Error("unrecognized signature format");
      }
    };
    exports.signatureToString = signatureToString;
  }
});

// node_modules/eosjs/dist/eosjs-serialize.js
var require_eosjs_serialize = __commonJS({
  "node_modules/eosjs/dist/eosjs-serialize.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    var __values = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serializeQuery = exports.deserializeAnyArray = exports.serializeAnyArray = exports.deserializeAnyObject = exports.serializeAnyObject = exports.deserializeAnyvarShort = exports.deserializeAnyvar = exports.serializeAnyvar = exports.deserializeAction = exports.deserializeActionData = exports.serializeAction = exports.serializeActionData = exports.transactionHeader = exports.getTypesFromAbi = exports.getType = exports.createTransactionTypes = exports.createTransactionExtensionTypes = exports.createAbiTypes = exports.createInitialTypes = exports.hexToUint8Array = exports.arrayToHex = exports.symbolToString = exports.stringToSymbol = exports.blockTimestampToDate = exports.dateToBlockTimestamp = exports.timePointSecToDate = exports.dateToTimePointSec = exports.timePointToDate = exports.dateToTimePoint = exports.supportedAbiVersion = exports.SerialBuffer = exports.SerializerState = void 0;
    var numeric = require_eosjs_numeric();
    var SerializerState = (
      /** @class */
      function() {
        function SerializerState2(options) {
          if (options === void 0) {
            options = {};
          }
          this.skippedBinaryExtension = false;
          this.options = options;
        }
        return SerializerState2;
      }()
    );
    exports.SerializerState = SerializerState;
    var SerialBuffer = (
      /** @class */
      function() {
        function SerialBuffer2(_a) {
          var _b = _a === void 0 ? {} : _a, textEncoder = _b.textEncoder, textDecoder = _b.textDecoder, array = _b.array;
          this.readPos = 0;
          this.array = array || new Uint8Array(1024);
          this.length = array ? array.length : 0;
          this.textEncoder = textEncoder || new TextEncoder();
          this.textDecoder = textDecoder || new TextDecoder("utf-8", { fatal: true });
        }
        SerialBuffer2.prototype.reserve = function(size) {
          if (this.length + size <= this.array.length) {
            return;
          }
          var l = this.array.length;
          while (this.length + size > l) {
            l = Math.ceil(l * 1.5);
          }
          var newArray = new Uint8Array(l);
          newArray.set(this.array);
          this.array = newArray;
        };
        SerialBuffer2.prototype.haveReadData = function() {
          return this.readPos < this.length;
        };
        SerialBuffer2.prototype.restartRead = function() {
          this.readPos = 0;
        };
        SerialBuffer2.prototype.asUint8Array = function() {
          return new Uint8Array(this.array.buffer, this.array.byteOffset, this.length);
        };
        SerialBuffer2.prototype.pushArray = function(v) {
          this.reserve(v.length);
          this.array.set(v, this.length);
          this.length += v.length;
        };
        SerialBuffer2.prototype.push = function() {
          var v = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            v[_i] = arguments[_i];
          }
          this.pushArray(v);
        };
        SerialBuffer2.prototype.get = function() {
          if (this.readPos < this.length) {
            return this.array[this.readPos++];
          }
          throw new Error("Read past end of buffer");
        };
        SerialBuffer2.prototype.pushUint8ArrayChecked = function(v, len) {
          if (v.length !== len) {
            throw new Error("Binary data has incorrect size");
          }
          this.pushArray(v);
        };
        SerialBuffer2.prototype.getUint8Array = function(len) {
          if (this.readPos + len > this.length) {
            throw new Error("Read past end of buffer");
          }
          var result = new Uint8Array(this.array.buffer, this.array.byteOffset + this.readPos, len);
          this.readPos += len;
          return result;
        };
        SerialBuffer2.prototype.skip = function(len) {
          if (this.readPos + len > this.length) {
            throw new Error("Read past end of buffer");
          }
          this.readPos += len;
        };
        SerialBuffer2.prototype.pushUint16 = function(v) {
          this.push(v >> 0 & 255, v >> 8 & 255);
        };
        SerialBuffer2.prototype.getUint16 = function() {
          var v = 0;
          v |= this.get() << 0;
          v |= this.get() << 8;
          return v;
        };
        SerialBuffer2.prototype.pushUint32 = function(v) {
          this.push(v >> 0 & 255, v >> 8 & 255, v >> 16 & 255, v >> 24 & 255);
        };
        SerialBuffer2.prototype.getUint32 = function() {
          var v = 0;
          v |= this.get() << 0;
          v |= this.get() << 8;
          v |= this.get() << 16;
          v |= this.get() << 24;
          return v >>> 0;
        };
        SerialBuffer2.prototype.pushNumberAsUint64 = function(v) {
          this.pushUint32(v >>> 0);
          this.pushUint32(Math.floor(v / 4294967296) >>> 0);
        };
        SerialBuffer2.prototype.getUint64AsNumber = function() {
          var low = this.getUint32();
          var high = this.getUint32();
          return (high >>> 0) * 4294967296 + (low >>> 0);
        };
        SerialBuffer2.prototype.pushVaruint32 = function(v) {
          while (true) {
            if (v >>> 7) {
              this.push(128 | v & 127);
              v = v >>> 7;
            } else {
              this.push(v);
              break;
            }
          }
        };
        SerialBuffer2.prototype.getVaruint32 = function() {
          var v = 0;
          var bit = 0;
          while (true) {
            var b = this.get();
            v |= (b & 127) << bit;
            bit += 7;
            if (!(b & 128)) {
              break;
            }
          }
          return v >>> 0;
        };
        SerialBuffer2.prototype.pushVarint32 = function(v) {
          this.pushVaruint32(v << 1 ^ v >> 31);
        };
        SerialBuffer2.prototype.getVarint32 = function() {
          var v = this.getVaruint32();
          if (v & 1) {
            return ~v >> 1 | 2147483648;
          } else {
            return v >>> 1;
          }
        };
        SerialBuffer2.prototype.pushFloat32 = function(v) {
          this.pushArray(new Uint8Array(new Float32Array([v]).buffer));
        };
        SerialBuffer2.prototype.getFloat32 = function() {
          return new Float32Array(this.getUint8Array(4).slice().buffer)[0];
        };
        SerialBuffer2.prototype.pushFloat64 = function(v) {
          this.pushArray(new Uint8Array(new Float64Array([v]).buffer));
        };
        SerialBuffer2.prototype.getFloat64 = function() {
          return new Float64Array(this.getUint8Array(8).slice().buffer)[0];
        };
        SerialBuffer2.prototype.pushName = function(s) {
          if (typeof s !== "string") {
            throw new Error("Expected string containing name");
          }
          var regex = new RegExp(/^[.1-5a-z]{0,12}[.1-5a-j]?$/);
          if (!regex.test(s)) {
            throw new Error("Name should be less than 13 characters, or less than 14 if last character is between 1-5 or a-j, and only contain the following symbols .12345abcdefghijklmnopqrstuvwxyz");
          }
          var charToSymbol = function(c2) {
            if (c2 >= "a".charCodeAt(0) && c2 <= "z".charCodeAt(0)) {
              return c2 - "a".charCodeAt(0) + 6;
            }
            if (c2 >= "1".charCodeAt(0) && c2 <= "5".charCodeAt(0)) {
              return c2 - "1".charCodeAt(0) + 1;
            }
            return 0;
          };
          var a = new Uint8Array(8);
          var bit = 63;
          for (var i = 0; i < s.length; ++i) {
            var c = charToSymbol(s.charCodeAt(i));
            if (bit < 5) {
              c = c << 1;
            }
            for (var j = 4; j >= 0; --j) {
              if (bit >= 0) {
                a[Math.floor(bit / 8)] |= (c >> j & 1) << bit % 8;
                --bit;
              }
            }
          }
          this.pushArray(a);
        };
        SerialBuffer2.prototype.getName = function() {
          var a = this.getUint8Array(8);
          var result = "";
          for (var bit = 63; bit >= 0; ) {
            var c = 0;
            for (var i = 0; i < 5; ++i) {
              if (bit >= 0) {
                c = c << 1 | a[Math.floor(bit / 8)] >> bit % 8 & 1;
                --bit;
              }
            }
            if (c >= 6) {
              result += String.fromCharCode(c + "a".charCodeAt(0) - 6);
            } else if (c >= 1) {
              result += String.fromCharCode(c + "1".charCodeAt(0) - 1);
            } else {
              result += ".";
            }
          }
          while (result.endsWith(".")) {
            result = result.substr(0, result.length - 1);
          }
          return result;
        };
        SerialBuffer2.prototype.pushBytes = function(v) {
          this.pushVaruint32(v.length);
          this.pushArray(v);
        };
        SerialBuffer2.prototype.getBytes = function() {
          return this.getUint8Array(this.getVaruint32());
        };
        SerialBuffer2.prototype.pushString = function(v) {
          this.pushBytes(this.textEncoder.encode(v));
        };
        SerialBuffer2.prototype.getString = function() {
          return this.textDecoder.decode(this.getBytes());
        };
        SerialBuffer2.prototype.pushSymbolCode = function(name) {
          if (typeof name !== "string") {
            throw new Error("Expected string containing symbol_code");
          }
          var a = [];
          a.push.apply(a, __spreadArray([], __read(this.textEncoder.encode(name))));
          while (a.length < 8) {
            a.push(0);
          }
          this.pushArray(a.slice(0, 8));
        };
        SerialBuffer2.prototype.getSymbolCode = function() {
          var a = this.getUint8Array(8);
          var len;
          for (len = 0; len < a.length; ++len) {
            if (!a[len]) {
              break;
            }
          }
          var name = this.textDecoder.decode(new Uint8Array(a.buffer, a.byteOffset, len));
          return name;
        };
        SerialBuffer2.prototype.pushSymbol = function(_a) {
          var name = _a.name, precision = _a.precision;
          if (!/^[A-Z]{1,7}$/.test(name)) {
            throw new Error("Expected symbol to be A-Z and between one and seven characters");
          }
          var a = [precision & 255];
          a.push.apply(a, __spreadArray([], __read(this.textEncoder.encode(name))));
          while (a.length < 8) {
            a.push(0);
          }
          this.pushArray(a.slice(0, 8));
        };
        SerialBuffer2.prototype.getSymbol = function() {
          var precision = this.get();
          var a = this.getUint8Array(7);
          var len;
          for (len = 0; len < a.length; ++len) {
            if (!a[len]) {
              break;
            }
          }
          var name = this.textDecoder.decode(new Uint8Array(a.buffer, a.byteOffset, len));
          return { name, precision };
        };
        SerialBuffer2.prototype.pushAsset = function(s) {
          if (typeof s !== "string") {
            throw new Error("Expected string containing asset");
          }
          s = s.trim();
          var pos = 0;
          var amount = "";
          var precision = 0;
          if (s[pos] === "-") {
            amount += "-";
            ++pos;
          }
          var foundDigit = false;
          while (pos < s.length && s.charCodeAt(pos) >= "0".charCodeAt(0) && s.charCodeAt(pos) <= "9".charCodeAt(0)) {
            foundDigit = true;
            amount += s[pos];
            ++pos;
          }
          if (!foundDigit) {
            throw new Error("Asset must begin with a number");
          }
          if (s[pos] === ".") {
            ++pos;
            while (pos < s.length && s.charCodeAt(pos) >= "0".charCodeAt(0) && s.charCodeAt(pos) <= "9".charCodeAt(0)) {
              amount += s[pos];
              ++precision;
              ++pos;
            }
          }
          var name = s.substr(pos).trim();
          this.pushArray(numeric.signedDecimalToBinary(8, amount));
          this.pushSymbol({ name, precision });
        };
        SerialBuffer2.prototype.getAsset = function() {
          var amount = this.getUint8Array(8);
          var _a = this.getSymbol(), name = _a.name, precision = _a.precision;
          var s = numeric.signedBinaryToDecimal(amount, precision + 1);
          if (precision) {
            s = s.substr(0, s.length - precision) + "." + s.substr(s.length - precision);
          }
          return s + " " + name;
        };
        SerialBuffer2.prototype.pushPublicKey = function(s) {
          var key = numeric.stringToPublicKey(s);
          this.push(key.type);
          this.pushArray(key.data);
        };
        SerialBuffer2.prototype.getPublicKey = function() {
          var type = this.get();
          var data;
          if (type === numeric.KeyType.wa) {
            var begin = this.readPos;
            this.skip(34);
            this.skip(this.getVaruint32());
            data = new Uint8Array(this.array.buffer, this.array.byteOffset + begin, this.readPos - begin);
          } else {
            data = this.getUint8Array(numeric.publicKeyDataSize);
          }
          return numeric.publicKeyToString({ type, data });
        };
        SerialBuffer2.prototype.pushPrivateKey = function(s) {
          var key = numeric.stringToPrivateKey(s);
          this.push(key.type);
          this.pushArray(key.data);
        };
        SerialBuffer2.prototype.getPrivateKey = function() {
          var type = this.get();
          var data = this.getUint8Array(numeric.privateKeyDataSize);
          return numeric.privateKeyToString({ type, data });
        };
        SerialBuffer2.prototype.pushSignature = function(s) {
          var key = numeric.stringToSignature(s);
          this.push(key.type);
          this.pushArray(key.data);
        };
        SerialBuffer2.prototype.getSignature = function() {
          var type = this.get();
          var data;
          if (type === numeric.KeyType.wa) {
            var begin = this.readPos;
            this.skip(65);
            this.skip(this.getVaruint32());
            this.skip(this.getVaruint32());
            data = new Uint8Array(this.array.buffer, this.array.byteOffset + begin, this.readPos - begin);
          } else {
            data = this.getUint8Array(numeric.signatureDataSize);
          }
          return numeric.signatureToString({ type, data });
        };
        return SerialBuffer2;
      }()
    );
    exports.SerialBuffer = SerialBuffer;
    var supportedAbiVersion = function(version) {
      return version.startsWith("eosio::abi/1.");
    };
    exports.supportedAbiVersion = supportedAbiVersion;
    var checkDateParse = function(date) {
      var result = Date.parse(date);
      if (Number.isNaN(result)) {
        throw new Error("Invalid time format");
      }
      return result;
    };
    var dateToTimePoint = function(date) {
      return Math.round(checkDateParse(date + "Z") * 1e3);
    };
    exports.dateToTimePoint = dateToTimePoint;
    var timePointToDate = function(us) {
      var s = new Date(us / 1e3).toISOString();
      return s.substr(0, s.length - 1);
    };
    exports.timePointToDate = timePointToDate;
    var dateToTimePointSec = function(date) {
      return Math.round(checkDateParse(date + "Z") / 1e3);
    };
    exports.dateToTimePointSec = dateToTimePointSec;
    var timePointSecToDate = function(sec) {
      var s = new Date(sec * 1e3).toISOString();
      return s.substr(0, s.length - 1);
    };
    exports.timePointSecToDate = timePointSecToDate;
    var dateToBlockTimestamp = function(date) {
      return Math.round((checkDateParse(date + "Z") - 9466848e5) / 500);
    };
    exports.dateToBlockTimestamp = dateToBlockTimestamp;
    var blockTimestampToDate = function(slot) {
      var s = new Date(slot * 500 + 9466848e5).toISOString();
      return s.substr(0, s.length - 1);
    };
    exports.blockTimestampToDate = blockTimestampToDate;
    var stringToSymbol = function(s) {
      if (typeof s !== "string") {
        throw new Error("Expected string containing symbol");
      }
      var m = s.match(/^([0-9]+),([A-Z]+)$/);
      if (!m) {
        throw new Error("Invalid symbol");
      }
      return { name: m[2], precision: +m[1] };
    };
    exports.stringToSymbol = stringToSymbol;
    var symbolToString = function(_a) {
      var name = _a.name, precision = _a.precision;
      return precision + "," + name;
    };
    exports.symbolToString = symbolToString;
    var arrayToHex = function(data) {
      var e_1, _a;
      var result = "";
      try {
        for (var data_1 = __values(data), data_1_1 = data_1.next(); !data_1_1.done; data_1_1 = data_1.next()) {
          var x = data_1_1.value;
          result += ("00" + x.toString(16)).slice(-2);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (data_1_1 && !data_1_1.done && (_a = data_1.return))
            _a.call(data_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return result.toUpperCase();
    };
    exports.arrayToHex = arrayToHex;
    var hexToUint8Array = function(hex) {
      if (typeof hex !== "string") {
        throw new Error("Expected string containing hex digits");
      }
      if (hex.length % 2) {
        throw new Error("Odd number of hex digits");
      }
      var l = hex.length / 2;
      var result = new Uint8Array(l);
      for (var i = 0; i < l; ++i) {
        var x = parseInt(hex.substr(i * 2, 2), 16);
        if (Number.isNaN(x)) {
          throw new Error("Expected hex string");
        }
        result[i] = x;
      }
      return result;
    };
    exports.hexToUint8Array = hexToUint8Array;
    function serializeUnknown(buffer, data) {
      throw new Error("Don't know how to serialize " + this.name);
    }
    function deserializeUnknown(buffer) {
      throw new Error("Don't know how to deserialize " + this.name);
    }
    function serializeStruct(buffer, data, state, allowExtensions) {
      var e_2, _a;
      if (state === void 0) {
        state = new SerializerState();
      }
      if (allowExtensions === void 0) {
        allowExtensions = true;
      }
      if (typeof data !== "object") {
        throw new Error("expected object containing data: " + JSON.stringify(data));
      }
      if (this.base) {
        this.base.serialize(buffer, data, state, allowExtensions);
      }
      try {
        for (var _b = __values(this.fields), _c = _b.next(); !_c.done; _c = _b.next()) {
          var field = _c.value;
          if (field.name in data) {
            if (state.skippedBinaryExtension) {
              throw new Error("unexpected " + this.name + "." + field.name);
            }
            field.type.serialize(buffer, data[field.name], state, allowExtensions && field === this.fields[this.fields.length - 1]);
          } else {
            if (allowExtensions && field.type.extensionOf) {
              state.skippedBinaryExtension = true;
            } else {
              throw new Error("missing " + this.name + "." + field.name + " (type=" + field.type.name + ")");
            }
          }
        }
      } catch (e_2_1) {
        e_2 = { error: e_2_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return))
            _a.call(_b);
        } finally {
          if (e_2)
            throw e_2.error;
        }
      }
    }
    function deserializeStruct(buffer, state, allowExtensions) {
      var e_3, _a;
      if (state === void 0) {
        state = new SerializerState();
      }
      if (allowExtensions === void 0) {
        allowExtensions = true;
      }
      var result;
      if (this.base) {
        result = this.base.deserialize(buffer, state, allowExtensions);
      } else {
        result = {};
      }
      try {
        for (var _b = __values(this.fields), _c = _b.next(); !_c.done; _c = _b.next()) {
          var field = _c.value;
          if (allowExtensions && field.type.extensionOf && !buffer.haveReadData()) {
            state.skippedBinaryExtension = true;
          } else {
            result[field.name] = field.type.deserialize(buffer, state, allowExtensions);
          }
        }
      } catch (e_3_1) {
        e_3 = { error: e_3_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return))
            _a.call(_b);
        } finally {
          if (e_3)
            throw e_3.error;
        }
      }
      return result;
    }
    function serializeVariant(buffer, data, state, allowExtensions) {
      if (!Array.isArray(data) || data.length !== 2 || typeof data[0] !== "string") {
        throw new Error('expected variant: ["type", value]');
      }
      var i = this.fields.findIndex(function(field) {
        return field.name === data[0];
      });
      if (i < 0) {
        throw new Error('type "' + data[0] + '" is not valid for variant');
      }
      buffer.pushVaruint32(i);
      this.fields[i].type.serialize(buffer, data[1], state, allowExtensions);
    }
    function deserializeVariant(buffer, state, allowExtensions) {
      var i = buffer.getVaruint32();
      if (i >= this.fields.length) {
        throw new Error("type index " + i + " is not valid for variant");
      }
      var field = this.fields[i];
      return [field.name, field.type.deserialize(buffer, state, allowExtensions)];
    }
    function serializeArray(buffer, data, state, allowExtensions) {
      var e_4, _a;
      buffer.pushVaruint32(data.length);
      try {
        for (var data_2 = __values(data), data_2_1 = data_2.next(); !data_2_1.done; data_2_1 = data_2.next()) {
          var item = data_2_1.value;
          this.arrayOf.serialize(buffer, item, state, false);
        }
      } catch (e_4_1) {
        e_4 = { error: e_4_1 };
      } finally {
        try {
          if (data_2_1 && !data_2_1.done && (_a = data_2.return))
            _a.call(data_2);
        } finally {
          if (e_4)
            throw e_4.error;
        }
      }
    }
    function deserializeArray(buffer, state, allowExtensions) {
      var len = buffer.getVaruint32();
      var result = [];
      for (var i = 0; i < len; ++i) {
        result.push(this.arrayOf.deserialize(buffer, state, false));
      }
      return result;
    }
    function serializeOptional(buffer, data, state, allowExtensions) {
      if (data === null || data === void 0) {
        buffer.push(0);
      } else {
        buffer.push(1);
        this.optionalOf.serialize(buffer, data, state, allowExtensions);
      }
    }
    function deserializeOptional(buffer, state, allowExtensions) {
      if (buffer.get()) {
        return this.optionalOf.deserialize(buffer, state, allowExtensions);
      } else {
        return null;
      }
    }
    function serializeExtension(buffer, data, state, allowExtensions) {
      this.extensionOf.serialize(buffer, data, state, allowExtensions);
    }
    function deserializeExtension(buffer, state, allowExtensions) {
      return this.extensionOf.deserialize(buffer, state, allowExtensions);
    }
    function serializeObject(buffer, data, state, allowExtensions) {
      var e_5, _a;
      var entries = Object.entries(data);
      buffer.pushVaruint32(entries.length);
      try {
        for (var entries_1 = __values(entries), entries_1_1 = entries_1.next(); !entries_1_1.done; entries_1_1 = entries_1.next()) {
          var _b = __read(entries_1_1.value, 2), key = _b[0], value = _b[1];
          var keyType = this.fields[0].type;
          var dataType = this.fields[1].type;
          keyType.serialize(buffer, key, state, allowExtensions);
          dataType.serialize(buffer, value, state, allowExtensions);
        }
      } catch (e_5_1) {
        e_5 = { error: e_5_1 };
      } finally {
        try {
          if (entries_1_1 && !entries_1_1.done && (_a = entries_1.return))
            _a.call(entries_1);
        } finally {
          if (e_5)
            throw e_5.error;
        }
      }
    }
    function deserializeObject(buffer, state, allowExtensions) {
      var len = buffer.getVaruint32();
      var result = {};
      for (var i = 0; i < len; ++i) {
        var keyType = this.fields[0].type;
        var dataType = this.fields[1].type;
        var key = keyType.deserialize(buffer, state, allowExtensions);
        result[key] = dataType.deserialize(buffer, state, allowExtensions);
      }
      return result;
    }
    function serializePair(buffer, data, state, allowExtensions) {
      var _this = this;
      buffer.pushVaruint32(data.length);
      data.forEach(function(item) {
        _this.fields[0].type.serialize(buffer, item[0], state, allowExtensions);
        _this.fields[1].type.serialize(buffer, item[1], state, allowExtensions);
      });
    }
    function deserializePair(buffer, state, allowExtensions) {
      var result = [];
      var len = buffer.getVaruint32();
      for (var i = 0; i < len; ++i) {
        result.push(this.fields[0].type.deserialize(buffer, state, allowExtensions));
        result.push(this.fields[1].type.deserialize(buffer, state, allowExtensions));
      }
      return result;
    }
    var createType = function(attrs) {
      return __assign({ name: "<missing name>", aliasOfName: "", arrayOf: null, optionalOf: null, extensionOf: null, baseName: "", base: null, fields: [], serialize: serializeUnknown, deserialize: deserializeUnknown }, attrs);
    };
    var checkRange = function(orig, converted) {
      if (Number.isNaN(+orig) || Number.isNaN(+converted) || typeof orig !== "number" && typeof orig !== "string") {
        throw new Error("Expected number");
      }
      if (+orig !== +converted) {
        throw new Error("Number is out of range");
      }
      return +orig;
    };
    var createInitialTypes = function() {
      var result = new Map(Object.entries({
        bool: createType({
          name: "bool",
          serialize: function(buffer, data) {
            if (!(typeof data === "boolean" || typeof data === "number" && (data === 1 || data === 0))) {
              throw new Error("Expected boolean or number equal to 1 or 0");
            }
            buffer.push(data ? 1 : 0);
          },
          deserialize: function(buffer) {
            return !!buffer.get();
          }
        }),
        uint8: createType({
          name: "uint8",
          serialize: function(buffer, data) {
            buffer.push(checkRange(data, data & 255));
          },
          deserialize: function(buffer) {
            return buffer.get();
          }
        }),
        int8: createType({
          name: "int8",
          serialize: function(buffer, data) {
            buffer.push(checkRange(data, data << 24 >> 24));
          },
          deserialize: function(buffer) {
            return buffer.get() << 24 >> 24;
          }
        }),
        uint16: createType({
          name: "uint16",
          serialize: function(buffer, data) {
            buffer.pushUint16(checkRange(data, data & 65535));
          },
          deserialize: function(buffer) {
            return buffer.getUint16();
          }
        }),
        int16: createType({
          name: "int16",
          serialize: function(buffer, data) {
            buffer.pushUint16(checkRange(data, data << 16 >> 16));
          },
          deserialize: function(buffer) {
            return buffer.getUint16() << 16 >> 16;
          }
        }),
        uint32: createType({
          name: "uint32",
          serialize: function(buffer, data) {
            buffer.pushUint32(checkRange(data, data >>> 0));
          },
          deserialize: function(buffer) {
            return buffer.getUint32();
          }
        }),
        uint64: createType({
          name: "uint64",
          serialize: function(buffer, data) {
            buffer.pushArray(numeric.decimalToBinary(8, "" + data));
          },
          deserialize: function(buffer) {
            return numeric.binaryToDecimal(buffer.getUint8Array(8));
          }
        }),
        int64: createType({
          name: "int64",
          serialize: function(buffer, data) {
            buffer.pushArray(numeric.signedDecimalToBinary(8, "" + data));
          },
          deserialize: function(buffer) {
            return numeric.signedBinaryToDecimal(buffer.getUint8Array(8));
          }
        }),
        int32: createType({
          name: "int32",
          serialize: function(buffer, data) {
            buffer.pushUint32(checkRange(data, data | 0));
          },
          deserialize: function(buffer) {
            return buffer.getUint32() | 0;
          }
        }),
        varuint32: createType({
          name: "varuint32",
          serialize: function(buffer, data) {
            buffer.pushVaruint32(checkRange(data, data >>> 0));
          },
          deserialize: function(buffer) {
            return buffer.getVaruint32();
          }
        }),
        varint32: createType({
          name: "varint32",
          serialize: function(buffer, data) {
            buffer.pushVarint32(checkRange(data, data | 0));
          },
          deserialize: function(buffer) {
            return buffer.getVarint32();
          }
        }),
        uint128: createType({
          name: "uint128",
          serialize: function(buffer, data) {
            buffer.pushArray(numeric.decimalToBinary(16, "" + data));
          },
          deserialize: function(buffer) {
            return numeric.binaryToDecimal(buffer.getUint8Array(16));
          }
        }),
        int128: createType({
          name: "int128",
          serialize: function(buffer, data) {
            buffer.pushArray(numeric.signedDecimalToBinary(16, "" + data));
          },
          deserialize: function(buffer) {
            return numeric.signedBinaryToDecimal(buffer.getUint8Array(16));
          }
        }),
        float32: createType({
          name: "float32",
          serialize: function(buffer, data) {
            buffer.pushFloat32(data);
          },
          deserialize: function(buffer) {
            return buffer.getFloat32();
          }
        }),
        float64: createType({
          name: "float64",
          serialize: function(buffer, data) {
            buffer.pushFloat64(data);
          },
          deserialize: function(buffer) {
            return buffer.getFloat64();
          }
        }),
        float128: createType({
          name: "float128",
          serialize: function(buffer, data) {
            buffer.pushUint8ArrayChecked(exports.hexToUint8Array(data), 16);
          },
          deserialize: function(buffer) {
            return exports.arrayToHex(buffer.getUint8Array(16));
          }
        }),
        bytes: createType({
          name: "bytes",
          serialize: function(buffer, data) {
            if (data instanceof Uint8Array || Array.isArray(data)) {
              buffer.pushBytes(data);
            } else {
              buffer.pushBytes(exports.hexToUint8Array(data));
            }
          },
          deserialize: function(buffer, state) {
            if (state && state.options.bytesAsUint8Array) {
              return buffer.getBytes();
            } else {
              return exports.arrayToHex(buffer.getBytes());
            }
          }
        }),
        string: createType({
          name: "string",
          serialize: function(buffer, data) {
            buffer.pushString(data);
          },
          deserialize: function(buffer) {
            return buffer.getString();
          }
        }),
        name: createType({
          name: "name",
          serialize: function(buffer, data) {
            buffer.pushName(data);
          },
          deserialize: function(buffer) {
            return buffer.getName();
          }
        }),
        time_point: createType({
          name: "time_point",
          serialize: function(buffer, data) {
            buffer.pushNumberAsUint64(exports.dateToTimePoint(data));
          },
          deserialize: function(buffer) {
            return exports.timePointToDate(buffer.getUint64AsNumber());
          }
        }),
        time_point_sec: createType({
          name: "time_point_sec",
          serialize: function(buffer, data) {
            buffer.pushUint32(exports.dateToTimePointSec(data));
          },
          deserialize: function(buffer) {
            return exports.timePointSecToDate(buffer.getUint32());
          }
        }),
        block_timestamp_type: createType({
          name: "block_timestamp_type",
          serialize: function(buffer, data) {
            buffer.pushUint32(exports.dateToBlockTimestamp(data));
          },
          deserialize: function(buffer) {
            return exports.blockTimestampToDate(buffer.getUint32());
          }
        }),
        symbol_code: createType({
          name: "symbol_code",
          serialize: function(buffer, data) {
            buffer.pushSymbolCode(data);
          },
          deserialize: function(buffer) {
            return buffer.getSymbolCode();
          }
        }),
        symbol: createType({
          name: "symbol",
          serialize: function(buffer, data) {
            buffer.pushSymbol(exports.stringToSymbol(data));
          },
          deserialize: function(buffer) {
            return exports.symbolToString(buffer.getSymbol());
          }
        }),
        asset: createType({
          name: "asset",
          serialize: function(buffer, data) {
            buffer.pushAsset(data);
          },
          deserialize: function(buffer) {
            return buffer.getAsset();
          }
        }),
        checksum160: createType({
          name: "checksum160",
          serialize: function(buffer, data) {
            buffer.pushUint8ArrayChecked(exports.hexToUint8Array(data), 20);
          },
          deserialize: function(buffer) {
            return exports.arrayToHex(buffer.getUint8Array(20));
          }
        }),
        checksum256: createType({
          name: "checksum256",
          serialize: function(buffer, data) {
            buffer.pushUint8ArrayChecked(exports.hexToUint8Array(data), 32);
          },
          deserialize: function(buffer) {
            return exports.arrayToHex(buffer.getUint8Array(32));
          }
        }),
        checksum512: createType({
          name: "checksum512",
          serialize: function(buffer, data) {
            buffer.pushUint8ArrayChecked(exports.hexToUint8Array(data), 64);
          },
          deserialize: function(buffer) {
            return exports.arrayToHex(buffer.getUint8Array(64));
          }
        }),
        public_key: createType({
          name: "public_key",
          serialize: function(buffer, data) {
            buffer.pushPublicKey(data);
          },
          deserialize: function(buffer) {
            return buffer.getPublicKey();
          }
        }),
        private_key: createType({
          name: "private_key",
          serialize: function(buffer, data) {
            buffer.pushPrivateKey(data);
          },
          deserialize: function(buffer) {
            return buffer.getPrivateKey();
          }
        }),
        signature: createType({
          name: "signature",
          serialize: function(buffer, data) {
            buffer.pushSignature(data);
          },
          deserialize: function(buffer) {
            return buffer.getSignature();
          }
        })
      }));
      result.set("extended_asset", createType({
        name: "extended_asset",
        baseName: "",
        fields: [
          { name: "quantity", typeName: "asset", type: result.get("asset") },
          { name: "contract", typeName: "name", type: result.get("name") }
        ],
        serialize: serializeStruct,
        deserialize: deserializeStruct
      }));
      return result;
    };
    exports.createInitialTypes = createInitialTypes;
    var createAbiTypes = function() {
      var initialTypes = exports.createInitialTypes();
      initialTypes.set("extensions_entry", createType({
        name: "extensions_entry",
        baseName: "",
        fields: [
          { name: "tag", typeName: "uint16", type: null },
          { name: "value", typeName: "bytes", type: null }
        ],
        serialize: serializeStruct,
        deserialize: deserializeStruct
      }));
      initialTypes.set("type_def", createType({
        name: "type_def",
        baseName: "",
        fields: [
          { name: "new_type_name", typeName: "string", type: null },
          { name: "type", typeName: "string", type: null }
        ],
        serialize: serializeStruct,
        deserialize: deserializeStruct
      }));
      initialTypes.set("field_def", createType({
        name: "field_def",
        baseName: "",
        fields: [
          { name: "name", typeName: "string", type: null },
          { name: "type", typeName: "string", type: null }
        ],
        serialize: serializeStruct,
        deserialize: deserializeStruct
      }));
      initialTypes.set("struct_def", createType({
        name: "struct_def",
        baseName: "",
        fields: [
          { name: "name", typeName: "string", type: null },
          { name: "base", typeName: "string", type: null },
          { name: "fields", typeName: "field_def[]", type: null }
        ],
        serialize: serializeStruct,
        deserialize: deserializeStruct
      }));
      initialTypes.set("action_def", createType({
        name: "action_def",
        baseName: "",
        fields: [
          { name: "name", typeName: "name", type: null },
          { name: "type", typeName: "string", type: null },
          { name: "ricardian_contract", typeName: "string", type: null }
        ],
        serialize: serializeStruct,
        deserialize: deserializeStruct
      }));
      initialTypes.set("table_def", createType({
        name: "table_def",
        baseName: "",
        fields: [
          { name: "name", typeName: "name", type: null },
          { name: "index_type", typeName: "string", type: null },
          { name: "key_names", typeName: "string[]", type: null },
          { name: "key_types", typeName: "string[]", type: null },
          { name: "type", typeName: "string", type: null }
        ],
        serialize: serializeStruct,
        deserialize: deserializeStruct
      }));
      initialTypes.set("clause_pair", createType({
        name: "clause_pair",
        baseName: "",
        fields: [
          { name: "id", typeName: "string", type: null },
          { name: "body", typeName: "string", type: null }
        ],
        serialize: serializeStruct,
        deserialize: deserializeStruct
      }));
      initialTypes.set("error_message", createType({
        name: "error_message",
        baseName: "",
        fields: [
          { name: "error_code", typeName: "uint64", type: null },
          { name: "error_msg", typeName: "string", type: null }
        ],
        serialize: serializeStruct,
        deserialize: deserializeStruct
      }));
      initialTypes.set("variant_def", createType({
        name: "variant_def",
        baseName: "",
        fields: [
          { name: "name", typeName: "string", type: null },
          { name: "types", typeName: "string[]", type: null }
        ],
        serialize: serializeStruct,
        deserialize: deserializeStruct
      }));
      initialTypes.set("action_result", createType({
        name: "action_result",
        baseName: "",
        fields: [
          { name: "name", typeName: "name", type: null },
          { name: "result_type", typeName: "string", type: null }
        ],
        serialize: serializeStruct,
        deserialize: deserializeStruct
      }));
      initialTypes.set("primary_key_index_def", createType({
        name: "primary_key_index_def",
        baseName: "",
        fields: [
          { name: "name", typeName: "name", type: null },
          { name: "type", typeName: "string", type: null }
        ],
        serialize: serializeStruct,
        deserialize: deserializeStruct
      }));
      initialTypes.set("secondary_index_def", createType({
        name: "secondary_index_def",
        baseName: "",
        fields: [
          { name: "type", typeName: "string", type: null }
        ],
        serialize: serializeStruct,
        deserialize: deserializeStruct
      }));
      initialTypes.set("secondary_indices", createType({
        name: "secondary_indices",
        baseName: "",
        fields: [
          { name: "name", typeName: "name", type: null },
          { name: "secondary_index_def", typeName: "secondary_index_def", type: null }
        ],
        serialize: serializeObject,
        deserialize: deserializeObject
      }));
      initialTypes.set("kv_table_entry_def", createType({
        name: "kv_table_entry_def",
        baseName: "",
        fields: [
          { name: "type", typeName: "string", type: null },
          { name: "primary_index", typeName: "primary_key_index_def", type: null },
          { name: "secondary_indices", typeName: "secondary_indices", type: null }
        ],
        serialize: serializeStruct,
        deserialize: deserializeStruct
      }));
      initialTypes.set("kv_table", createType({
        name: "kv_table",
        baseName: "",
        fields: [
          { name: "name", typeName: "name", type: null },
          { name: "kv_table_entry_def", typeName: "kv_table_entry_def", type: null }
        ],
        serialize: serializeObject,
        deserialize: deserializeObject
      }));
      initialTypes.set("abi_def", createType({
        name: "abi_def",
        baseName: "",
        fields: [
          { name: "version", typeName: "string", type: null },
          { name: "types", typeName: "type_def[]", type: null },
          { name: "structs", typeName: "struct_def[]", type: null },
          { name: "actions", typeName: "action_def[]", type: null },
          { name: "tables", typeName: "table_def[]", type: null },
          { name: "ricardian_clauses", typeName: "clause_pair[]", type: null },
          { name: "error_messages", typeName: "error_message[]", type: null },
          { name: "abi_extensions", typeName: "extensions_entry[]", type: null },
          { name: "variants", typeName: "variant_def[]$", type: null },
          { name: "action_results", typeName: "action_result[]$", type: null },
          { name: "kv_tables", typeName: "kv_table$", type: null }
        ],
        serialize: serializeStruct,
        deserialize: deserializeStruct
      }));
      return initialTypes;
    };
    exports.createAbiTypes = createAbiTypes;
    var createTransactionExtensionTypes = function() {
      var initialTypes = exports.createInitialTypes();
      initialTypes.set("resource_payer", createType({
        name: "resource_payer",
        baseName: "",
        fields: [
          { name: "payer", typeName: "name", type: null },
          { name: "max_net_bytes", typeName: "uint64", type: null },
          { name: "max_cpu_us", typeName: "uint64", type: null },
          { name: "max_memory_bytes", typeName: "uint64", type: null }
        ],
        serialize: serializeStruct,
        deserialize: deserializeStruct
      }));
      return initialTypes;
    };
    exports.createTransactionExtensionTypes = createTransactionExtensionTypes;
    var createTransactionTypes = function() {
      var initialTypes = exports.createInitialTypes();
      initialTypes.set("permission_level", createType({
        name: "permission_level",
        baseName: "",
        fields: [
          { name: "actor", typeName: "name", type: null },
          { name: "permission", typeName: "name", type: null }
        ],
        serialize: serializeStruct,
        deserialize: deserializeStruct
      }));
      initialTypes.set("action", createType({
        name: "action",
        baseName: "",
        fields: [
          { name: "account", typeName: "name", type: null },
          { name: "name", typeName: "name", type: null },
          { name: "authorization", typeName: "permission_level[]", type: null },
          { name: "data", typeName: "bytes", type: null }
        ],
        serialize: serializeStruct,
        deserialize: deserializeStruct
      }));
      initialTypes.set("extension", createType({
        name: "extension",
        baseName: "",
        fields: [
          { name: "type", typeName: "uint16", type: null },
          { name: "data", typeName: "bytes", type: null }
        ],
        serialize: serializePair,
        deserialize: deserializePair
      }));
      initialTypes.set("transaction_header", createType({
        name: "transaction_header",
        baseName: "",
        fields: [
          { name: "expiration", typeName: "time_point_sec", type: null },
          { name: "ref_block_num", typeName: "uint16", type: null },
          { name: "ref_block_prefix", typeName: "uint32", type: null },
          { name: "max_net_usage_words", typeName: "varuint32", type: null },
          { name: "max_cpu_usage_ms", typeName: "uint8", type: null },
          { name: "delay_sec", typeName: "varuint32", type: null }
        ],
        serialize: serializeStruct,
        deserialize: deserializeStruct
      }));
      initialTypes.set("transaction", createType({
        name: "transaction",
        baseName: "transaction_header",
        fields: [
          { name: "context_free_actions", typeName: "action[]", type: null },
          { name: "actions", typeName: "action[]", type: null },
          { name: "transaction_extensions", typeName: "extension", type: null }
        ],
        serialize: serializeStruct,
        deserialize: deserializeStruct
      }));
      return initialTypes;
    };
    exports.createTransactionTypes = createTransactionTypes;
    var getType = function(types, name) {
      var type = types.get(name);
      if (type && type.aliasOfName) {
        return exports.getType(types, type.aliasOfName);
      }
      if (type) {
        return type;
      }
      if (name.endsWith("[]")) {
        return createType({
          name,
          arrayOf: exports.getType(types, name.substr(0, name.length - 2)),
          serialize: serializeArray,
          deserialize: deserializeArray
        });
      }
      if (name.endsWith("?")) {
        return createType({
          name,
          optionalOf: exports.getType(types, name.substr(0, name.length - 1)),
          serialize: serializeOptional,
          deserialize: deserializeOptional
        });
      }
      if (name.endsWith("$")) {
        return createType({
          name,
          extensionOf: exports.getType(types, name.substr(0, name.length - 1)),
          serialize: serializeExtension,
          deserialize: deserializeExtension
        });
      }
      throw new Error("Unknown type: " + name);
    };
    exports.getType = getType;
    var getTypesFromAbi = function(initialTypes, abi) {
      var e_6, _a, e_7, _b, e_8, _c, e_9, _d, e_10, _e;
      var types = new Map(initialTypes);
      if (abi && abi.types) {
        try {
          for (var _f = __values(abi.types), _g = _f.next(); !_g.done; _g = _f.next()) {
            var _h = _g.value, new_type_name = _h.new_type_name, type = _h.type;
            types.set(new_type_name, createType({ name: new_type_name, aliasOfName: type }));
          }
        } catch (e_6_1) {
          e_6 = { error: e_6_1 };
        } finally {
          try {
            if (_g && !_g.done && (_a = _f.return))
              _a.call(_f);
          } finally {
            if (e_6)
              throw e_6.error;
          }
        }
      }
      if (abi && abi.structs) {
        try {
          for (var _j = __values(abi.structs), _k = _j.next(); !_k.done; _k = _j.next()) {
            var _l = _k.value, name_1 = _l.name, base = _l.base, fields = _l.fields;
            types.set(name_1, createType({
              name: name_1,
              baseName: base,
              fields: fields.map(function(_a2) {
                var n = _a2.name, type2 = _a2.type;
                return { name: n, typeName: type2, type: null };
              }),
              serialize: serializeStruct,
              deserialize: deserializeStruct
            }));
          }
        } catch (e_7_1) {
          e_7 = { error: e_7_1 };
        } finally {
          try {
            if (_k && !_k.done && (_b = _j.return))
              _b.call(_j);
          } finally {
            if (e_7)
              throw e_7.error;
          }
        }
      }
      if (abi && abi.variants) {
        try {
          for (var _m = __values(abi.variants), _o = _m.next(); !_o.done; _o = _m.next()) {
            var _p = _o.value, name_2 = _p.name, t = _p.types;
            types.set(name_2, createType({
              name: name_2,
              fields: t.map(function(s) {
                return { name: s, typeName: s, type: null };
              }),
              serialize: serializeVariant,
              deserialize: deserializeVariant
            }));
          }
        } catch (e_8_1) {
          e_8 = { error: e_8_1 };
        } finally {
          try {
            if (_o && !_o.done && (_c = _m.return))
              _c.call(_m);
          } finally {
            if (e_8)
              throw e_8.error;
          }
        }
      }
      try {
        for (var types_1 = __values(types), types_1_1 = types_1.next(); !types_1_1.done; types_1_1 = types_1.next()) {
          var _q = __read(types_1_1.value, 2), name_3 = _q[0], type = _q[1];
          if (type.baseName) {
            type.base = exports.getType(types, type.baseName);
          }
          try {
            for (var _r = (e_10 = void 0, __values(type.fields)), _s = _r.next(); !_s.done; _s = _r.next()) {
              var field = _s.value;
              field.type = exports.getType(types, field.typeName);
            }
          } catch (e_10_1) {
            e_10 = { error: e_10_1 };
          } finally {
            try {
              if (_s && !_s.done && (_e = _r.return))
                _e.call(_r);
            } finally {
              if (e_10)
                throw e_10.error;
            }
          }
        }
      } catch (e_9_1) {
        e_9 = { error: e_9_1 };
      } finally {
        try {
          if (types_1_1 && !types_1_1.done && (_d = types_1.return))
            _d.call(types_1);
        } finally {
          if (e_9)
            throw e_9.error;
        }
      }
      return types;
    };
    exports.getTypesFromAbi = getTypesFromAbi;
    var reverseHex = function(h) {
      return h.substr(6, 2) + h.substr(4, 2) + h.substr(2, 2) + h.substr(0, 2);
    };
    var transactionHeader = function(refBlock, expireSeconds) {
      var timestamp = refBlock.header ? refBlock.header.timestamp : refBlock.timestamp;
      var prefix = parseInt(reverseHex(refBlock.id.substr(16, 8)), 16);
      return {
        expiration: exports.timePointSecToDate(exports.dateToTimePointSec(timestamp) + expireSeconds),
        ref_block_num: refBlock.block_num & 65535,
        ref_block_prefix: prefix
      };
    };
    exports.transactionHeader = transactionHeader;
    var serializeActionData = function(contract, account, name, data, textEncoder, textDecoder) {
      var action = contract.actions.get(name);
      if (!action) {
        throw new Error("Unknown action " + name + " in contract " + account);
      }
      var buffer = new SerialBuffer({ textEncoder, textDecoder });
      action.serialize(buffer, data);
      return exports.arrayToHex(buffer.asUint8Array());
    };
    exports.serializeActionData = serializeActionData;
    var serializeAction = function(contract, account, name, authorization, data, textEncoder, textDecoder) {
      return {
        account,
        name,
        authorization,
        data: exports.serializeActionData(contract, account, name, data, textEncoder, textDecoder)
      };
    };
    exports.serializeAction = serializeAction;
    var deserializeActionData = function(contract, account, name, data, textEncoder, textDecoder) {
      var action = contract.actions.get(name);
      if (typeof data === "string") {
        data = exports.hexToUint8Array(data);
      }
      if (!action) {
        throw new Error("Unknown action " + name + " in contract " + account);
      }
      var buffer = new SerialBuffer({ textDecoder, textEncoder });
      buffer.pushArray(data);
      return action.deserialize(buffer);
    };
    exports.deserializeActionData = deserializeActionData;
    var deserializeAction = function(contract, account, name, authorization, data, textEncoder, textDecoder) {
      return {
        account,
        name,
        authorization,
        data: exports.deserializeActionData(contract, account, name, data, textEncoder, textDecoder)
      };
    };
    exports.deserializeAction = deserializeAction;
    var serializeAnyvar = function(buffer, anyvar) {
      var _a, _b, _c, _d, _e, _f, _g;
      var def;
      var value;
      if (anyvar === null) {
        _a = __read([anyvarDefs.null_t, anyvar], 2), def = _a[0], value = _a[1];
      } else if (typeof anyvar === "string") {
        _b = __read([anyvarDefs.string, anyvar], 2), def = _b[0], value = _b[1];
      } else if (typeof anyvar === "number") {
        _c = __read([anyvarDefs.int32, anyvar], 2), def = _c[0], value = _c[1];
      } else if (anyvar instanceof Uint8Array) {
        _d = __read([anyvarDefs.bytes, anyvar], 2), def = _d[0], value = _d[1];
      } else if (Array.isArray(anyvar)) {
        _e = __read([anyvarDefs.any_array, anyvar], 2), def = _e[0], value = _e[1];
      } else if (Object.keys(anyvar).length === 2 && anyvar.hasOwnProperty("type") && anyvar.hasOwnProperty("value")) {
        _f = __read([anyvarDefs[anyvar.type], anyvar.value], 2), def = _f[0], value = _f[1];
      } else {
        _g = __read([anyvarDefs.any_object, anyvar], 2), def = _g[0], value = _g[1];
      }
      buffer.pushVaruint32(def.index);
      def.type.serialize(buffer, value);
    };
    exports.serializeAnyvar = serializeAnyvar;
    var deserializeAnyvar = function(buffer, state) {
      var defIndex = buffer.getVaruint32();
      if (defIndex >= anyvarDefsByIndex.length) {
        throw new Error("Tried to deserialize unknown anyvar type");
      }
      var def = anyvarDefsByIndex[defIndex];
      var value = def.type.deserialize(buffer, state);
      if (state && state.options.useShortForm || def.useShortForm) {
        return value;
      } else {
        return { type: def.type.name, value };
      }
    };
    exports.deserializeAnyvar = deserializeAnyvar;
    var deserializeAnyvarShort = function(buffer) {
      return exports.deserializeAnyvar(buffer, new SerializerState({ useShortForm: true }));
    };
    exports.deserializeAnyvarShort = deserializeAnyvarShort;
    var serializeAnyObject = function(buffer, obj) {
      var e_11, _a;
      var entries = Object.entries(obj);
      buffer.pushVaruint32(entries.length);
      try {
        for (var entries_2 = __values(entries), entries_2_1 = entries_2.next(); !entries_2_1.done; entries_2_1 = entries_2.next()) {
          var _b = __read(entries_2_1.value, 2), key = _b[0], value = _b[1];
          buffer.pushString(key);
          exports.serializeAnyvar(buffer, value);
        }
      } catch (e_11_1) {
        e_11 = { error: e_11_1 };
      } finally {
        try {
          if (entries_2_1 && !entries_2_1.done && (_a = entries_2.return))
            _a.call(entries_2);
        } finally {
          if (e_11)
            throw e_11.error;
        }
      }
    };
    exports.serializeAnyObject = serializeAnyObject;
    var deserializeAnyObject = function(buffer, state) {
      var len = buffer.getVaruint32();
      var result = {};
      for (var i = 0; i < len; ++i) {
        var key = buffer.getString();
        if (key in result) {
          var j = 1;
          while (key + "_" + j in result) {
            ++j;
          }
          key = key + "_" + j;
        }
        result[key] = exports.deserializeAnyvar(buffer, state);
      }
      return result;
    };
    exports.deserializeAnyObject = deserializeAnyObject;
    var serializeAnyArray = function(buffer, arr) {
      var e_12, _a;
      buffer.pushVaruint32(arr.length);
      try {
        for (var arr_1 = __values(arr), arr_1_1 = arr_1.next(); !arr_1_1.done; arr_1_1 = arr_1.next()) {
          var x = arr_1_1.value;
          exports.serializeAnyvar(buffer, x);
        }
      } catch (e_12_1) {
        e_12 = { error: e_12_1 };
      } finally {
        try {
          if (arr_1_1 && !arr_1_1.done && (_a = arr_1.return))
            _a.call(arr_1);
        } finally {
          if (e_12)
            throw e_12.error;
        }
      }
    };
    exports.serializeAnyArray = serializeAnyArray;
    var deserializeAnyArray = function(buffer, state) {
      var len = buffer.getVaruint32();
      var result = [];
      for (var i = 0; i < len; ++i) {
        result.push(exports.deserializeAnyvar(buffer, state));
      }
      return result;
    };
    exports.deserializeAnyArray = deserializeAnyArray;
    var addAdditionalTypes = function() {
      var initialTypes = exports.createInitialTypes();
      initialTypes.set("null_t", createType({
        name: "null_t",
        serialize: function(buffer, anyvar) {
        },
        deserialize: function(buffer, state) {
        }
      }));
      initialTypes.set("any_object", createType({
        name: "any_object",
        serialize: exports.serializeAnyObject,
        deserialize: exports.deserializeAnyObject
      }));
      initialTypes.set("any_array", createType({
        name: "any_array",
        serialize: exports.serializeAnyArray,
        deserialize: exports.deserializeAnyArray
      }));
      return initialTypes;
    };
    var additionalTypes = addAdditionalTypes();
    var anyvarDefs = {
      null_t: { index: 0, useShortForm: true, type: additionalTypes.get("null_t") },
      int64: { index: 1, useShortForm: false, type: additionalTypes.get("int64") },
      uint64: { index: 2, useShortForm: false, type: additionalTypes.get("uint64") },
      int32: { index: 3, useShortForm: true, type: additionalTypes.get("int32") },
      uint32: { index: 4, useShortForm: false, type: additionalTypes.get("uint32") },
      int16: { index: 5, useShortForm: false, type: additionalTypes.get("int16") },
      uint16: { index: 6, useShortForm: false, type: additionalTypes.get("uint16") },
      int8: { index: 7, useShortForm: false, type: additionalTypes.get("int8") },
      uint8: { index: 8, useShortForm: false, type: additionalTypes.get("uint8") },
      time_point: { index: 9, useShortForm: false, type: additionalTypes.get("time_point") },
      checksum256: { index: 10, useShortForm: false, type: additionalTypes.get("checksum256") },
      float64: { index: 11, useShortForm: false, type: additionalTypes.get("float64") },
      string: { index: 12, useShortForm: true, type: additionalTypes.get("string") },
      any_object: { index: 13, useShortForm: true, type: additionalTypes.get("any_object") },
      any_array: { index: 14, useShortForm: true, type: additionalTypes.get("any_array") },
      bytes: { index: 15, useShortForm: false, type: additionalTypes.get("bytes") },
      symbol: { index: 16, useShortForm: false, type: additionalTypes.get("symbol") },
      symbol_code: { index: 17, useShortForm: false, type: additionalTypes.get("symbol_code") },
      asset: { index: 18, useShortForm: false, type: additionalTypes.get("asset") }
    };
    var anyvarDefsByIndex = [
      anyvarDefs.null_t,
      anyvarDefs.int64,
      anyvarDefs.uint64,
      anyvarDefs.int32,
      anyvarDefs.uint32,
      anyvarDefs.int16,
      anyvarDefs.uint16,
      anyvarDefs.int8,
      anyvarDefs.uint8,
      anyvarDefs.time_point,
      anyvarDefs.checksum256,
      anyvarDefs.float64,
      anyvarDefs.string,
      anyvarDefs.any_object,
      anyvarDefs.any_array,
      anyvarDefs.bytes,
      anyvarDefs.symbol,
      anyvarDefs.symbol_code,
      anyvarDefs.asset
    ];
    var serializeQuery = function(buffer, query) {
      var _a, _b, _c, e_13, _d;
      var method;
      var arg;
      var filter;
      if (typeof query === "string") {
        method = query;
      } else if (Array.isArray(query) && query.length === 2) {
        _a = __read(query, 2), method = _a[0], filter = _a[1];
      } else if (Array.isArray(query) && query.length === 3) {
        _b = __read(query, 3), method = _b[0], arg = _b[1], filter = _b[2];
      } else {
        _c = __read([query.method, query.arg, query.filter], 3), method = _c[0], arg = _c[1], filter = _c[2];
      }
      buffer.pushString(method);
      if (arg === void 0) {
        buffer.push(0);
      } else {
        buffer.push(1);
        exports.serializeAnyvar(buffer, arg);
      }
      if (filter === void 0) {
        buffer.push(0);
      } else {
        buffer.pushVaruint32(filter.length);
        try {
          for (var filter_1 = __values(filter), filter_1_1 = filter_1.next(); !filter_1_1.done; filter_1_1 = filter_1.next()) {
            var q = filter_1_1.value;
            exports.serializeQuery(buffer, q);
          }
        } catch (e_13_1) {
          e_13 = { error: e_13_1 };
        } finally {
          try {
            if (filter_1_1 && !filter_1_1.done && (_d = filter_1.return))
              _d.call(filter_1);
          } finally {
            if (e_13)
              throw e_13.error;
          }
        }
      }
    };
    exports.serializeQuery = serializeQuery;
  }
});

// node_modules/eosjs/dist/eosjs-api.js
var require_eosjs_api = __commonJS({
  "node_modules/eosjs/dist/eosjs-api.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    var __values = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ActionBuilder = exports.TransactionBuilder = exports.Api = void 0;
    var pako_1 = require_pako();
    var ser = require_eosjs_serialize();
    var Api = (
      /** @class */
      function() {
        function Api2(args) {
          this.contracts = /* @__PURE__ */ new Map();
          this.cachedAbis = /* @__PURE__ */ new Map();
          this.transactionExtensions = [
            { id: 1, type: "resource_payer", keys: ["payer", "max_net_bytes", "max_cpu_us", "max_memory_bytes"] }
          ];
          this.rpc = args.rpc;
          this.authorityProvider = args.authorityProvider || args.rpc;
          this.abiProvider = args.abiProvider || args.rpc;
          this.signatureProvider = args.signatureProvider;
          this.chainId = args.chainId;
          this.textEncoder = args.textEncoder;
          this.textDecoder = args.textDecoder;
          this.abiTypes = ser.getTypesFromAbi(ser.createAbiTypes());
          this.transactionTypes = ser.getTypesFromAbi(ser.createTransactionTypes());
        }
        Api2.prototype.rawAbiToJson = function(rawAbi) {
          var buffer = new ser.SerialBuffer({
            textEncoder: this.textEncoder,
            textDecoder: this.textDecoder,
            array: rawAbi
          });
          if (!ser.supportedAbiVersion(buffer.getString())) {
            throw new Error("Unsupported abi version");
          }
          buffer.restartRead();
          return this.abiTypes.get("abi_def").deserialize(buffer);
        };
        Api2.prototype.jsonToRawAbi = function(jsonAbi) {
          var buffer = new ser.SerialBuffer({
            textEncoder: this.textEncoder,
            textDecoder: this.textDecoder
          });
          this.abiTypes.get("abi_def").serialize(buffer, jsonAbi);
          if (!ser.supportedAbiVersion(buffer.getString())) {
            throw new Error("Unsupported abi version");
          }
          return buffer.asUint8Array();
        };
        Api2.prototype.getCachedAbi = function(accountName, reload) {
          if (reload === void 0) {
            reload = false;
          }
          return __awaiter(this, void 0, void 0, function() {
            var cachedAbi, rawAbi, abi, e_1;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  if (!reload && this.cachedAbis.get(accountName)) {
                    return [2, this.cachedAbis.get(accountName)];
                  }
                  _a.label = 1;
                case 1:
                  _a.trys.push([1, 3, , 4]);
                  return [4, this.abiProvider.getRawAbi(accountName)];
                case 2:
                  rawAbi = _a.sent().abi;
                  abi = this.rawAbiToJson(rawAbi);
                  cachedAbi = { rawAbi, abi };
                  return [3, 4];
                case 3:
                  e_1 = _a.sent();
                  e_1.message = "fetching abi for " + accountName + ": " + e_1.message;
                  throw e_1;
                case 4:
                  if (!cachedAbi) {
                    throw new Error("Missing abi for " + accountName);
                  }
                  this.cachedAbis.set(accountName, cachedAbi);
                  return [2, cachedAbi];
              }
            });
          });
        };
        Api2.prototype.getAbi = function(accountName, reload) {
          if (reload === void 0) {
            reload = false;
          }
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.getCachedAbi(accountName, reload)];
                case 1:
                  return [2, _a.sent().abi];
              }
            });
          });
        };
        Api2.prototype.getTransactionAbis = function(transaction, reload) {
          if (reload === void 0) {
            reload = false;
          }
          return __awaiter(this, void 0, void 0, function() {
            var actions, accounts, uniqueAccounts, actionPromises;
            var _this = this;
            return __generator(this, function(_a) {
              actions = (transaction.context_free_actions || []).concat(transaction.actions);
              accounts = actions.map(function(action) {
                return action.account;
              });
              uniqueAccounts = new Set(accounts);
              actionPromises = __spreadArray([], __read(uniqueAccounts)).map(function(account) {
                return __awaiter(_this, void 0, void 0, function() {
                  var _a2;
                  return __generator(this, function(_b) {
                    switch (_b.label) {
                      case 0:
                        _a2 = {
                          accountName: account
                        };
                        return [4, this.getCachedAbi(account, reload)];
                      case 1:
                        return [2, (_a2.abi = _b.sent().rawAbi, _a2)];
                    }
                  });
                });
              });
              return [2, Promise.all(actionPromises)];
            });
          });
        };
        Api2.prototype.getContract = function(accountName, reload) {
          if (reload === void 0) {
            reload = false;
          }
          return __awaiter(this, void 0, void 0, function() {
            var abi, types, actions, _a, _b, _c, name_1, type, result;
            var e_2, _d;
            return __generator(this, function(_e) {
              switch (_e.label) {
                case 0:
                  if (!reload && this.contracts.get(accountName)) {
                    return [2, this.contracts.get(accountName)];
                  }
                  return [4, this.getAbi(accountName, reload)];
                case 1:
                  abi = _e.sent();
                  types = ser.getTypesFromAbi(ser.createInitialTypes(), abi);
                  actions = /* @__PURE__ */ new Map();
                  try {
                    for (_a = __values(abi.actions), _b = _a.next(); !_b.done; _b = _a.next()) {
                      _c = _b.value, name_1 = _c.name, type = _c.type;
                      actions.set(name_1, ser.getType(types, type));
                    }
                  } catch (e_2_1) {
                    e_2 = { error: e_2_1 };
                  } finally {
                    try {
                      if (_b && !_b.done && (_d = _a.return))
                        _d.call(_a);
                    } finally {
                      if (e_2)
                        throw e_2.error;
                    }
                  }
                  result = { types, actions };
                  this.contracts.set(accountName, result);
                  return [2, result];
              }
            });
          });
        };
        Api2.prototype.serialize = function(buffer, type, value) {
          this.transactionTypes.get(type).serialize(buffer, value);
        };
        Api2.prototype.deserialize = function(buffer, type) {
          return this.transactionTypes.get(type).deserialize(buffer);
        };
        Api2.prototype.serializeTransaction = function(transaction) {
          var buffer = new ser.SerialBuffer({ textEncoder: this.textEncoder, textDecoder: this.textDecoder });
          this.serialize(buffer, "transaction", __assign({ max_net_usage_words: 0, max_cpu_usage_ms: 0, delay_sec: 0, context_free_actions: [], actions: [], transaction_extensions: [] }, transaction));
          return buffer.asUint8Array();
        };
        Api2.prototype.serializeContextFreeData = function(contextFreeData) {
          var e_3, _a;
          if (!contextFreeData || !contextFreeData.length) {
            return null;
          }
          var buffer = new ser.SerialBuffer({ textEncoder: this.textEncoder, textDecoder: this.textDecoder });
          buffer.pushVaruint32(contextFreeData.length);
          try {
            for (var contextFreeData_1 = __values(contextFreeData), contextFreeData_1_1 = contextFreeData_1.next(); !contextFreeData_1_1.done; contextFreeData_1_1 = contextFreeData_1.next()) {
              var data = contextFreeData_1_1.value;
              buffer.pushBytes(data);
            }
          } catch (e_3_1) {
            e_3 = { error: e_3_1 };
          } finally {
            try {
              if (contextFreeData_1_1 && !contextFreeData_1_1.done && (_a = contextFreeData_1.return))
                _a.call(contextFreeData_1);
            } finally {
              if (e_3)
                throw e_3.error;
            }
          }
          return buffer.asUint8Array();
        };
        Api2.prototype.deserializeTransaction = function(transaction) {
          var buffer = new ser.SerialBuffer({ textEncoder: this.textEncoder, textDecoder: this.textDecoder });
          buffer.pushArray(transaction);
          return this.deserialize(buffer, "transaction");
        };
        Api2.prototype.serializeTransactionExtensions = function(transaction) {
          var transaction_extensions = [];
          if (transaction.resource_payer) {
            var extensionBuffer = new ser.SerialBuffer({ textEncoder: this.textEncoder, textDecoder: this.textDecoder });
            var types = ser.getTypesFromAbi(ser.createTransactionExtensionTypes());
            types.get("resource_payer").serialize(extensionBuffer, transaction.resource_payer);
            transaction_extensions = __spreadArray(__spreadArray([], __read(transaction_extensions)), [[1, ser.arrayToHex(extensionBuffer.asUint8Array())]]);
          }
          return transaction_extensions;
        };
        ;
        Api2.prototype.deserializeTransactionExtensions = function(data) {
          var _this = this;
          var transaction = {};
          data.forEach(function(extensionData) {
            var transactionExtension = _this.transactionExtensions.find(function(extension) {
              return extension.id === extensionData[0];
            });
            if (transactionExtension === void 0) {
              throw new Error("Transaction Extension could not be determined: " + extensionData);
            }
            var types = ser.getTypesFromAbi(ser.createTransactionExtensionTypes());
            var extensionBuffer = new ser.SerialBuffer({ textEncoder: _this.textEncoder, textDecoder: _this.textDecoder });
            extensionBuffer.pushArray(ser.hexToUint8Array(extensionData[1]));
            var deserializedObj = types.get(transactionExtension.type).deserialize(extensionBuffer);
            if (extensionData[0] === 1) {
              deserializedObj.max_net_bytes = Number(deserializedObj.max_net_bytes);
              deserializedObj.max_cpu_us = Number(deserializedObj.max_cpu_us);
              deserializedObj.max_memory_bytes = Number(deserializedObj.max_memory_bytes);
              transaction.resource_payer = deserializedObj;
            }
          });
          return transaction;
        };
        ;
        Api2.prototype.deleteTransactionExtensionObjects = function(transaction) {
          delete transaction.resource_payer;
          return transaction;
        };
        Api2.prototype.serializeActions = function(actions) {
          return __awaiter(this, void 0, void 0, function() {
            var _this = this;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, Promise.all(actions.map(function(action) {
                    return __awaiter(_this, void 0, void 0, function() {
                      var account, name, authorization, data, contract;
                      return __generator(this, function(_a2) {
                        switch (_a2.label) {
                          case 0:
                            account = action.account, name = action.name, authorization = action.authorization, data = action.data;
                            return [4, this.getContract(account)];
                          case 1:
                            contract = _a2.sent();
                            if (typeof data !== "object") {
                              return [2, action];
                            }
                            return [2, ser.serializeAction(contract, account, name, authorization, data, this.textEncoder, this.textDecoder)];
                        }
                      });
                    });
                  }))];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        Api2.prototype.deserializeActions = function(actions) {
          return __awaiter(this, void 0, void 0, function() {
            var _this = this;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, Promise.all(actions.map(function(_a2) {
                    var account = _a2.account, name = _a2.name, authorization = _a2.authorization, data = _a2.data;
                    return __awaiter(_this, void 0, void 0, function() {
                      var contract;
                      return __generator(this, function(_b) {
                        switch (_b.label) {
                          case 0:
                            return [4, this.getContract(account)];
                          case 1:
                            contract = _b.sent();
                            return [2, ser.deserializeAction(contract, account, name, authorization, data, this.textEncoder, this.textDecoder)];
                        }
                      });
                    });
                  }))];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        Api2.prototype.deserializeTransactionWithActions = function(transaction) {
          return __awaiter(this, void 0, void 0, function() {
            var deserializedTransaction, deserializedCFActions, deserializedActions;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  if (typeof transaction === "string") {
                    transaction = ser.hexToUint8Array(transaction);
                  }
                  deserializedTransaction = this.deserializeTransaction(transaction);
                  return [4, this.deserializeActions(deserializedTransaction.context_free_actions)];
                case 1:
                  deserializedCFActions = _a.sent();
                  return [4, this.deserializeActions(deserializedTransaction.actions)];
                case 2:
                  deserializedActions = _a.sent();
                  return [2, __assign(__assign({}, deserializedTransaction), { context_free_actions: deserializedCFActions, actions: deserializedActions })];
              }
            });
          });
        };
        Api2.prototype.deflateSerializedArray = function(serializedArray) {
          return pako_1.deflate(serializedArray, { level: 9 });
        };
        Api2.prototype.inflateSerializedArray = function(compressedSerializedArray) {
          return pako_1.inflate(compressedSerializedArray);
        };
        Api2.prototype.transact = function(transaction, _a) {
          var _b = _a === void 0 ? {} : _a, _c = _b.broadcast, broadcast = _c === void 0 ? true : _c, _d = _b.sign, sign = _d === void 0 ? true : _d, readOnlyTrx = _b.readOnlyTrx, returnFailureTraces = _b.returnFailureTraces, requiredKeys = _b.requiredKeys, compression = _b.compression, blocksBehind = _b.blocksBehind, useLastIrreversible = _b.useLastIrreversible, expireSeconds = _b.expireSeconds;
          return __awaiter(this, void 0, void 0, function() {
            var info, abis, _e, serializedTransaction, serializedContextFreeData, pushTransactionArgs, availableKeys;
            var _f;
            return __generator(this, function(_g) {
              switch (_g.label) {
                case 0:
                  if (typeof blocksBehind === "number" && useLastIrreversible) {
                    throw new Error("Use either blocksBehind or useLastIrreversible");
                  }
                  if (!!this.chainId)
                    return [3, 2];
                  return [4, this.rpc.get_info()];
                case 1:
                  info = _g.sent();
                  this.chainId = info.chain_id;
                  _g.label = 2;
                case 2:
                  if (!((typeof blocksBehind === "number" || useLastIrreversible) && expireSeconds))
                    return [3, 4];
                  return [4, this.generateTapos(info, transaction, blocksBehind, useLastIrreversible, expireSeconds)];
                case 3:
                  transaction = _g.sent();
                  _g.label = 4;
                case 4:
                  if (!this.hasRequiredTaposFields(transaction)) {
                    throw new Error("Required configuration or TAPOS fields are not present");
                  }
                  return [4, this.getTransactionAbis(transaction)];
                case 5:
                  abis = _g.sent();
                  _e = [__assign({}, transaction)];
                  _f = {};
                  return [4, this.serializeTransactionExtensions(transaction)];
                case 6:
                  _f.transaction_extensions = _g.sent();
                  return [4, this.serializeActions(transaction.context_free_actions || [])];
                case 7:
                  _f.context_free_actions = _g.sent();
                  return [4, this.serializeActions(transaction.actions)];
                case 8:
                  transaction = __assign.apply(void 0, _e.concat([(_f.actions = _g.sent(), _f)]));
                  transaction = this.deleteTransactionExtensionObjects(transaction);
                  serializedTransaction = this.serializeTransaction(transaction);
                  serializedContextFreeData = this.serializeContextFreeData(transaction.context_free_data);
                  pushTransactionArgs = {
                    serializedTransaction,
                    serializedContextFreeData,
                    signatures: []
                  };
                  if (!sign)
                    return [3, 13];
                  if (!!requiredKeys)
                    return [3, 11];
                  return [4, this.signatureProvider.getAvailableKeys()];
                case 9:
                  availableKeys = _g.sent();
                  return [4, this.authorityProvider.getRequiredKeys({ transaction, availableKeys })];
                case 10:
                  requiredKeys = _g.sent();
                  _g.label = 11;
                case 11:
                  return [4, this.signatureProvider.sign({
                    chainId: this.chainId,
                    requiredKeys,
                    serializedTransaction,
                    serializedContextFreeData,
                    abis
                  })];
                case 12:
                  pushTransactionArgs = _g.sent();
                  _g.label = 13;
                case 13:
                  if (broadcast) {
                    if (compression) {
                      return [2, this.pushCompressedSignedTransaction(pushTransactionArgs, readOnlyTrx, returnFailureTraces)];
                    }
                    return [2, this.pushSignedTransaction(pushTransactionArgs, readOnlyTrx, returnFailureTraces)];
                  }
                  return [2, pushTransactionArgs];
              }
            });
          });
        };
        Api2.prototype.query = function(account, short, query, _a) {
          var sign = _a.sign, requiredKeys = _a.requiredKeys, _b = _a.authorization, authorization = _b === void 0 ? [] : _b;
          return __awaiter(this, void 0, void 0, function() {
            var info, refBlock, queryBuffer, transaction, serializedTransaction, signatures, abis, availableKeys, signResponse, response, returnBuffer;
            return __generator(this, function(_c) {
              switch (_c.label) {
                case 0:
                  return [4, this.rpc.get_info()];
                case 1:
                  info = _c.sent();
                  return [4, this.tryRefBlockFromGetInfo(info)];
                case 2:
                  refBlock = _c.sent();
                  queryBuffer = new ser.SerialBuffer({ textEncoder: this.textEncoder, textDecoder: this.textDecoder });
                  ser.serializeQuery(queryBuffer, query);
                  transaction = __assign(__assign({}, ser.transactionHeader(refBlock, 60 * 30)), { context_free_actions: [], actions: [{
                    account,
                    name: "queryit",
                    authorization,
                    data: ser.arrayToHex(queryBuffer.asUint8Array())
                  }] });
                  serializedTransaction = this.serializeTransaction(transaction);
                  signatures = [];
                  if (!sign)
                    return [3, 8];
                  return [4, this.getTransactionAbis(transaction)];
                case 3:
                  abis = _c.sent();
                  if (!!requiredKeys)
                    return [3, 6];
                  return [4, this.signatureProvider.getAvailableKeys()];
                case 4:
                  availableKeys = _c.sent();
                  return [4, this.authorityProvider.getRequiredKeys({ transaction, availableKeys })];
                case 5:
                  requiredKeys = _c.sent();
                  _c.label = 6;
                case 6:
                  return [4, this.signatureProvider.sign({
                    chainId: this.chainId,
                    requiredKeys,
                    serializedTransaction,
                    serializedContextFreeData: null,
                    abis
                  })];
                case 7:
                  signResponse = _c.sent();
                  signatures = signResponse.signatures;
                  _c.label = 8;
                case 8:
                  return [4, this.rpc.send_transaction({
                    signatures,
                    compression: 0,
                    serializedTransaction
                  })];
                case 9:
                  response = _c.sent();
                  returnBuffer = new ser.SerialBuffer({
                    textEncoder: this.textEncoder,
                    textDecoder: this.textDecoder,
                    array: ser.hexToUint8Array(response.processed.action_traces[0][1].return_value)
                  });
                  if (short) {
                    return [2, ser.deserializeAnyvarShort(returnBuffer)];
                  } else {
                    return [2, ser.deserializeAnyvar(returnBuffer)];
                  }
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        Api2.prototype.pushSignedTransaction = function(_a, readOnlyTrx, returnFailureTraces) {
          var signatures = _a.signatures, serializedTransaction = _a.serializedTransaction, serializedContextFreeData = _a.serializedContextFreeData;
          if (readOnlyTrx === void 0) {
            readOnlyTrx = false;
          }
          if (returnFailureTraces === void 0) {
            returnFailureTraces = false;
          }
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_b) {
              if (readOnlyTrx) {
                return [2, this.rpc.push_ro_transaction({
                  signatures,
                  serializedTransaction,
                  serializedContextFreeData
                }, returnFailureTraces)];
              }
              return [2, this.rpc.push_transaction({
                signatures,
                serializedTransaction,
                serializedContextFreeData
              })];
            });
          });
        };
        Api2.prototype.pushCompressedSignedTransaction = function(_a, readOnlyTrx, returnFailureTraces) {
          var signatures = _a.signatures, serializedTransaction = _a.serializedTransaction, serializedContextFreeData = _a.serializedContextFreeData;
          if (readOnlyTrx === void 0) {
            readOnlyTrx = false;
          }
          if (returnFailureTraces === void 0) {
            returnFailureTraces = false;
          }
          return __awaiter(this, void 0, void 0, function() {
            var compressedSerializedTransaction, compressedSerializedContextFreeData;
            return __generator(this, function(_b) {
              compressedSerializedTransaction = this.deflateSerializedArray(serializedTransaction);
              compressedSerializedContextFreeData = this.deflateSerializedArray(serializedContextFreeData || new Uint8Array(0));
              if (readOnlyTrx) {
                return [2, this.rpc.push_ro_transaction({
                  signatures,
                  compression: 1,
                  serializedTransaction: compressedSerializedTransaction,
                  serializedContextFreeData: compressedSerializedContextFreeData
                }, returnFailureTraces)];
              }
              return [2, this.rpc.push_transaction({
                signatures,
                compression: 1,
                serializedTransaction: compressedSerializedTransaction,
                serializedContextFreeData: compressedSerializedContextFreeData
              })];
            });
          });
        };
        Api2.prototype.generateTapos = function(info, transaction, blocksBehind, useLastIrreversible, expireSeconds) {
          return __awaiter(this, void 0, void 0, function() {
            var block, taposBlockNumber, refBlock, _a;
            return __generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  if (!!info)
                    return [3, 2];
                  return [4, this.rpc.get_info()];
                case 1:
                  info = _b.sent();
                  _b.label = 2;
                case 2:
                  if (!useLastIrreversible)
                    return [3, 4];
                  return [4, this.tryRefBlockFromGetInfo(info)];
                case 3:
                  block = _b.sent();
                  return [2, __assign(__assign({}, ser.transactionHeader(block, expireSeconds)), transaction)];
                case 4:
                  taposBlockNumber = info.head_block_num - blocksBehind;
                  if (!(taposBlockNumber <= info.last_irreversible_block_num))
                    return [3, 6];
                  return [4, this.tryGetBlockInfo(taposBlockNumber)];
                case 5:
                  _a = _b.sent();
                  return [3, 8];
                case 6:
                  return [4, this.tryGetBlockHeaderState(taposBlockNumber)];
                case 7:
                  _a = _b.sent();
                  _b.label = 8;
                case 8:
                  refBlock = _a;
                  return [2, __assign(__assign({}, ser.transactionHeader(refBlock, expireSeconds)), transaction)];
              }
            });
          });
        };
        Api2.prototype.hasRequiredTaposFields = function(_a) {
          var expiration = _a.expiration, ref_block_num = _a.ref_block_num, ref_block_prefix = _a.ref_block_prefix;
          return !!(expiration && typeof ref_block_num === "number" && typeof ref_block_prefix === "number");
        };
        Api2.prototype.tryGetBlockHeaderState = function(taposBlockNumber) {
          return __awaiter(this, void 0, void 0, function() {
            var error_1;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  _a.trys.push([0, 2, , 4]);
                  return [4, this.rpc.get_block_header_state(taposBlockNumber)];
                case 1:
                  return [2, _a.sent()];
                case 2:
                  error_1 = _a.sent();
                  return [4, this.tryGetBlockInfo(taposBlockNumber)];
                case 3:
                  return [2, _a.sent()];
                case 4:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        Api2.prototype.tryGetBlockInfo = function(blockNumber) {
          return __awaiter(this, void 0, void 0, function() {
            var error_2;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  _a.trys.push([0, 2, , 4]);
                  return [4, this.rpc.get_block_info(blockNumber)];
                case 1:
                  return [2, _a.sent()];
                case 2:
                  error_2 = _a.sent();
                  return [4, this.rpc.get_block(blockNumber)];
                case 3:
                  return [2, _a.sent()];
                case 4:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        Api2.prototype.tryRefBlockFromGetInfo = function(info) {
          return __awaiter(this, void 0, void 0, function() {
            var block;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  if (!(info.hasOwnProperty("last_irreversible_block_id") && info.hasOwnProperty("last_irreversible_block_num") && info.hasOwnProperty("last_irreversible_block_time")))
                    return [3, 1];
                  return [2, {
                    block_num: info.last_irreversible_block_num,
                    id: info.last_irreversible_block_id,
                    timestamp: info.last_irreversible_block_time
                  }];
                case 1:
                  return [4, this.tryGetBlockInfo(info.last_irreversible_block_num)];
                case 2:
                  block = _a.sent();
                  return [2, {
                    block_num: block.block_num,
                    id: block.id,
                    timestamp: block.timestamp
                  }];
              }
            });
          });
        };
        Api2.prototype.with = function(accountName) {
          return new ActionBuilder(this, accountName);
        };
        Api2.prototype.buildTransaction = function(cb) {
          var tx = new TransactionBuilder(this);
          if (cb) {
            return cb(tx);
          }
          return tx;
        };
        return Api2;
      }()
    );
    exports.Api = Api;
    var TransactionBuilder = (
      /** @class */
      function() {
        function TransactionBuilder2(api) {
          this.actions = [];
          this.contextFreeGroups = [];
          this.api = api;
        }
        TransactionBuilder2.prototype.with = function(accountName) {
          var actionBuilder = new ActionBuilder(this.api, accountName);
          this.actions.push(actionBuilder);
          return actionBuilder;
        };
        TransactionBuilder2.prototype.associateContextFree = function(contextFreeGroup) {
          this.contextFreeGroups.push(contextFreeGroup);
          return this;
        };
        TransactionBuilder2.prototype.send = function(config) {
          return __awaiter(this, void 0, void 0, function() {
            var contextFreeDataSet, contextFreeActions, actions;
            var _this = this;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  contextFreeDataSet = [];
                  contextFreeActions = [];
                  actions = this.actions.map(function(actionBuilder) {
                    return actionBuilder.serializedData;
                  });
                  return [4, Promise.all(this.contextFreeGroups.map(function(contextFreeCallback) {
                    return __awaiter(_this, void 0, void 0, function() {
                      var _a2, action, contextFreeAction, contextFreeData;
                      return __generator(this, function(_b) {
                        _a2 = contextFreeCallback({
                          cfd: contextFreeDataSet.length,
                          cfa: contextFreeActions.length
                        }), action = _a2.action, contextFreeAction = _a2.contextFreeAction, contextFreeData = _a2.contextFreeData;
                        if (action) {
                          actions.push(action);
                        }
                        if (contextFreeAction) {
                          contextFreeActions.push(contextFreeAction);
                        }
                        if (contextFreeData) {
                          contextFreeDataSet.push(contextFreeData);
                        }
                        return [
                          2
                          /*return*/
                        ];
                      });
                    });
                  }))];
                case 1:
                  _a.sent();
                  this.contextFreeGroups = [];
                  this.actions = [];
                  return [4, this.api.transact({
                    context_free_data: contextFreeDataSet,
                    context_free_actions: contextFreeActions,
                    actions
                  }, config)];
                case 2:
                  return [2, _a.sent()];
              }
            });
          });
        };
        return TransactionBuilder2;
      }()
    );
    exports.TransactionBuilder = TransactionBuilder;
    var ActionBuilder = (
      /** @class */
      function() {
        function ActionBuilder2(api, accountName) {
          this.api = api;
          this.accountName = accountName;
        }
        ActionBuilder2.prototype.as = function(actorName) {
          if (actorName === void 0) {
            actorName = [];
          }
          var authorization = [];
          if (actorName && typeof actorName === "string") {
            authorization = [{ actor: actorName, permission: "active" }];
          } else {
            authorization = actorName;
          }
          return new ActionSerializer(this, this.api, this.accountName, authorization);
        };
        return ActionBuilder2;
      }()
    );
    exports.ActionBuilder = ActionBuilder;
    var ActionSerializer = (
      /** @class */
      function() {
        function ActionSerializer2(parent, api, accountName, authorization) {
          var e_4, _a;
          var _this = this;
          var jsonAbi = api.cachedAbis.get(accountName);
          if (!jsonAbi) {
            throw new Error("ABI must be cached before using ActionBuilder, run api.getAbi()");
          }
          var types = ser.getTypesFromAbi(ser.createInitialTypes(), jsonAbi.abi);
          var actions = /* @__PURE__ */ new Map();
          try {
            for (var _b = __values(jsonAbi.abi.actions), _c = _b.next(); !_c.done; _c = _b.next()) {
              var _d = _c.value, name_2 = _d.name, type = _d.type;
              actions.set(name_2, ser.getType(types, type));
            }
          } catch (e_4_1) {
            e_4 = { error: e_4_1 };
          } finally {
            try {
              if (_c && !_c.done && (_a = _b.return))
                _a.call(_b);
            } finally {
              if (e_4)
                throw e_4.error;
            }
          }
          actions.forEach(function(type2, name) {
            var _a2;
            Object.assign(_this, (_a2 = {}, _a2[name] = function() {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
              }
              var data = {};
              args.forEach(function(arg, index) {
                var field = type2.fields[index];
                data[field.name] = arg;
              });
              var serializedData = ser.serializeAction({ types, actions }, accountName, name, authorization, data, api.textEncoder, api.textDecoder);
              parent.serializedData = serializedData;
              return serializedData;
            }, _a2));
          });
        }
        return ActionSerializer2;
      }()
    );
  }
});

// node_modules/eosjs/dist/eosjs-api-interfaces.js
var require_eosjs_api_interfaces = __commonJS({
  "node_modules/eosjs/dist/eosjs-api-interfaces.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/eosjs/dist/eosjs-rpcerror.js
var require_eosjs_rpcerror = __commonJS({
  "node_modules/eosjs/dist/eosjs-rpcerror.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RpcError = void 0;
    var RpcError = (
      /** @class */
      function(_super) {
        __extends(RpcError2, _super);
        function RpcError2(json) {
          var _this = this;
          if (json.error && json.error.details && json.error.details.length && json.error.details[0].message) {
            _this = _super.call(this, json.error.details[0].message) || this;
            _this.details = json.error.details;
          } else if (json.processed && json.processed.except && json.processed.except.message) {
            _this = _super.call(this, json.processed.except.message) || this;
            _this.details = json.processed.except;
          } else if (json.result && json.result.except && json.result.except.message) {
            _this = _super.call(this, json.result.except.message) || this;
            _this.details = json.result.except;
          } else {
            _this = _super.call(this, json.message) || this;
          }
          Object.setPrototypeOf(_this, RpcError2.prototype);
          _this.json = json;
          return _this;
        }
        return RpcError2;
      }(Error)
    );
    exports.RpcError = RpcError;
  }
});

// node_modules/eosjs/dist/eosjs-jsonrpc.js
var require_eosjs_jsonrpc = __commonJS({
  "node_modules/eosjs/dist/eosjs-jsonrpc.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __values = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JsonRpc = void 0;
    var eosjs_numeric_1 = require_eosjs_numeric();
    var eosjs_rpcerror_1 = require_eosjs_rpcerror();
    var arrayToHex = function(data) {
      var e_1, _a;
      var result = "";
      try {
        for (var data_1 = __values(data), data_1_1 = data_1.next(); !data_1_1.done; data_1_1 = data_1.next()) {
          var x = data_1_1.value;
          result += ("00" + x.toString(16)).slice(-2);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (data_1_1 && !data_1_1.done && (_a = data_1.return))
            _a.call(data_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return result;
    };
    var JsonRpc = (
      /** @class */
      function() {
        function JsonRpc2(endpoint, args) {
          if (args === void 0) {
            args = {};
          }
          this.endpoint = endpoint.replace(/\/$/, "");
          if (args.fetch) {
            this.fetchBuiltin = args.fetch;
          } else {
            this.fetchBuiltin = global.fetch;
          }
        }
        JsonRpc2.prototype.fetch = function(path, body) {
          return __awaiter(this, void 0, void 0, function() {
            var response, json, f, e_2;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  _a.trys.push([0, 3, , 4]);
                  f = this.fetchBuiltin;
                  return [4, f(this.endpoint + path, {
                    body: JSON.stringify(body),
                    method: "POST"
                  })];
                case 1:
                  response = _a.sent();
                  return [4, response.json()];
                case 2:
                  json = _a.sent();
                  if (json.processed && json.processed.except) {
                    throw new eosjs_rpcerror_1.RpcError(json);
                  } else if (json.result && json.result.except) {
                    throw new eosjs_rpcerror_1.RpcError(json);
                  }
                  return [3, 4];
                case 3:
                  e_2 = _a.sent();
                  e_2.isFetchError = true;
                  throw e_2;
                case 4:
                  if (!response.ok) {
                    throw new eosjs_rpcerror_1.RpcError(json);
                  }
                  return [2, json];
              }
            });
          });
        };
        JsonRpc2.prototype.abi_bin_to_json = function(code, action, binargs) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/abi_bin_to_json", { code, action, binargs })];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.abi_json_to_bin = function(code, action, args) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/abi_json_to_bin", { code, action, args })];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.get_abi = function(accountName) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/get_abi", { account_name: accountName })];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.get_account = function(accountName) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/get_account", { account_name: accountName })];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.get_accounts_by_authorizers = function(accounts, keys) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/get_accounts_by_authorizers", { accounts, keys })];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.get_activated_protocol_features = function(_a) {
          var _b = _a.limit, limit = _b === void 0 ? 10 : _b, _c = _a.search_by_block_num, search_by_block_num = _c === void 0 ? false : _c, _d = _a.reverse, reverse = _d === void 0 ? false : _d, _e = _a.lower_bound, lower_bound = _e === void 0 ? null : _e, _f = _a.upper_bound, upper_bound = _f === void 0 ? null : _f;
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_g) {
              switch (_g.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/get_activated_protocol_features", { lower_bound, upper_bound, limit, search_by_block_num, reverse })];
                case 1:
                  return [2, _g.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.get_block_header_state = function(blockNumOrId) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/get_block_header_state", { block_num_or_id: blockNumOrId })];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.get_block_info = function(blockNum) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/get_block_info", { block_num: blockNum })];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.get_block = function(blockNumOrId) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/get_block", { block_num_or_id: blockNumOrId })];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.get_code = function(accountName) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/get_code", {
                    account_name: accountName,
                    code_as_wasm: true
                  })];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.get_code_hash = function(accountName) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/get_code_hash", { account_name: accountName })];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.get_currency_balance = function(code, account, symbol) {
          if (symbol === void 0) {
            symbol = null;
          }
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/get_currency_balance", { code, account, symbol })];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.get_currency_stats = function(code, symbol) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/get_currency_stats", { code, symbol })];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.get_info = function() {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/get_info", {})];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.get_producer_schedule = function() {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/get_producer_schedule", {})];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.get_producers = function(json, lowerBound, limit) {
          if (json === void 0) {
            json = true;
          }
          if (lowerBound === void 0) {
            lowerBound = "";
          }
          if (limit === void 0) {
            limit = 50;
          }
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/get_producers", { json, lower_bound: lowerBound, limit })];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.get_raw_code_and_abi = function(accountName) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/get_raw_code_and_abi", { account_name: accountName })];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.getRawAbi = function(accountName) {
          return __awaiter(this, void 0, void 0, function() {
            var rawAbi, abi;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.get_raw_abi(accountName)];
                case 1:
                  rawAbi = _a.sent();
                  abi = eosjs_numeric_1.base64ToBinary(rawAbi.abi);
                  return [2, { accountName: rawAbi.account_name, abi }];
              }
            });
          });
        };
        JsonRpc2.prototype.get_raw_abi = function(accountName) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/get_raw_abi", { account_name: accountName })];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.get_scheduled_transactions = function(json, lowerBound, limit) {
          if (json === void 0) {
            json = true;
          }
          if (lowerBound === void 0) {
            lowerBound = "";
          }
          if (limit === void 0) {
            limit = 50;
          }
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/get_scheduled_transactions", { json, lower_bound: lowerBound, limit })];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.get_table_rows = function(_a) {
          var _b = _a.json, json = _b === void 0 ? true : _b, code = _a.code, scope = _a.scope, table = _a.table, _c = _a.lower_bound, lower_bound = _c === void 0 ? "" : _c, _d = _a.upper_bound, upper_bound = _d === void 0 ? "" : _d, _e = _a.index_position, index_position = _e === void 0 ? 1 : _e, _f = _a.key_type, key_type = _f === void 0 ? "" : _f, _g = _a.limit, limit = _g === void 0 ? 10 : _g, _h = _a.reverse, reverse = _h === void 0 ? false : _h, _j = _a.show_payer, show_payer = _j === void 0 ? false : _j;
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_k) {
              switch (_k.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/get_table_rows", {
                    json,
                    code,
                    scope,
                    table,
                    lower_bound,
                    upper_bound,
                    index_position,
                    key_type,
                    limit,
                    reverse,
                    show_payer
                  })];
                case 1:
                  return [2, _k.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.get_kv_table_rows = function(_a) {
          var _b = _a.json, json = _b === void 0 ? true : _b, code = _a.code, table = _a.table, index_name = _a.index_name, _c = _a.encode_type, encode_type = _c === void 0 ? "bytes" : _c, index_value = _a.index_value, lower_bound = _a.lower_bound, upper_bound = _a.upper_bound, _d = _a.limit, limit = _d === void 0 ? 10 : _d, _e = _a.reverse, reverse = _e === void 0 ? false : _e, _f = _a.show_payer, show_payer = _f === void 0 ? false : _f;
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_g) {
              switch (_g.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/get_kv_table_rows", {
                    json,
                    code,
                    table,
                    index_name,
                    encode_type,
                    index_value,
                    lower_bound,
                    upper_bound,
                    limit,
                    reverse,
                    show_payer
                  })];
                case 1:
                  return [2, _g.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.get_table_by_scope = function(_a) {
          var code = _a.code, table = _a.table, _b = _a.lower_bound, lower_bound = _b === void 0 ? "" : _b, _c = _a.upper_bound, upper_bound = _c === void 0 ? "" : _c, _d = _a.limit, limit = _d === void 0 ? 10 : _d;
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_e) {
              switch (_e.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/get_table_by_scope", {
                    code,
                    table,
                    lower_bound,
                    upper_bound,
                    limit
                  })];
                case 1:
                  return [2, _e.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.getRequiredKeys = function(args) {
          return __awaiter(this, void 0, void 0, function() {
            var _a;
            return __generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  _a = eosjs_numeric_1.convertLegacyPublicKeys;
                  return [4, this.fetch("/v1/chain/get_required_keys", {
                    transaction: args.transaction,
                    available_keys: args.availableKeys
                  })];
                case 1:
                  return [2, _a.apply(void 0, [_b.sent().required_keys])];
              }
            });
          });
        };
        JsonRpc2.prototype.push_transaction = function(_a) {
          var signatures = _a.signatures, _b = _a.compression, compression = _b === void 0 ? 0 : _b, serializedTransaction = _a.serializedTransaction, serializedContextFreeData = _a.serializedContextFreeData;
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_c) {
              switch (_c.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/push_transaction", {
                    signatures,
                    compression,
                    packed_context_free_data: arrayToHex(serializedContextFreeData || new Uint8Array(0)),
                    packed_trx: arrayToHex(serializedTransaction)
                  })];
                case 1:
                  return [2, _c.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.push_ro_transaction = function(_a, returnFailureTraces) {
          var signatures = _a.signatures, _b = _a.compression, compression = _b === void 0 ? 0 : _b, serializedTransaction = _a.serializedTransaction;
          if (returnFailureTraces === void 0) {
            returnFailureTraces = false;
          }
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_c) {
              switch (_c.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/push_ro_transaction", {
                    transaction: {
                      signatures,
                      compression,
                      packed_context_free_data: arrayToHex(new Uint8Array(0)),
                      packed_trx: arrayToHex(serializedTransaction)
                    },
                    return_failure_traces: returnFailureTraces
                  })];
                case 1:
                  return [2, _c.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.push_transactions = function(transactions) {
          return __awaiter(this, void 0, void 0, function() {
            var packedTrxs;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  packedTrxs = transactions.map(function(_a2) {
                    var signatures = _a2.signatures, _b = _a2.compression, compression = _b === void 0 ? 0 : _b, serializedTransaction = _a2.serializedTransaction, serializedContextFreeData = _a2.serializedContextFreeData;
                    return {
                      signatures,
                      compression,
                      packed_context_free_data: arrayToHex(serializedContextFreeData || new Uint8Array(0)),
                      packed_trx: arrayToHex(serializedTransaction)
                    };
                  });
                  return [4, this.fetch("/v1/chain/push_transactions", packedTrxs)];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.send_transaction = function(_a) {
          var signatures = _a.signatures, _b = _a.compression, compression = _b === void 0 ? 0 : _b, serializedTransaction = _a.serializedTransaction, serializedContextFreeData = _a.serializedContextFreeData;
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_c) {
              switch (_c.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/send_transaction", {
                    signatures,
                    compression,
                    packed_context_free_data: arrayToHex(serializedContextFreeData || new Uint8Array(0)),
                    packed_trx: arrayToHex(serializedTransaction)
                  })];
                case 1:
                  return [2, _c.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.db_size_get = function() {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.fetch("/v1/db_size/get", {})];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.trace_get_block = function(block_num) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.fetch("/v1/trace_api/get_block", { block_num })];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.history_get_actions = function(accountName, pos, offset) {
          if (pos === void 0) {
            pos = null;
          }
          if (offset === void 0) {
            offset = null;
          }
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.fetch("/v1/history/get_actions", { account_name: accountName, pos, offset })];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.history_get_transaction = function(id, blockNumHint) {
          if (blockNumHint === void 0) {
            blockNumHint = null;
          }
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.fetch("/v1/history/get_transaction", { id, block_num_hint: blockNumHint })];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.history_get_key_accounts = function(publicKey) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.fetch("/v1/history/get_key_accounts", { public_key: publicKey })];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.history_get_controlled_accounts = function(controllingAccount) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.fetch("/v1/history/get_controlled_accounts", { controlling_account: controllingAccount })];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        return JsonRpc2;
      }()
    );
    exports.JsonRpc = JsonRpc;
  }
});

// node_modules/eosjs/dist/eosjs-rpc-interfaces.js
var require_eosjs_rpc_interfaces = __commonJS({
  "node_modules/eosjs/dist/eosjs-rpc-interfaces.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/eosjs/dist/index.js
var require_dist = __commonJS({
  "node_modules/eosjs/dist/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Serialize = exports.RpcError = exports.RpcInterfaces = exports.Numeric = exports.JsonRpc = exports.ApiInterfaces = exports.Api = void 0;
    var eosjs_api_1 = require_eosjs_api();
    Object.defineProperty(exports, "Api", { enumerable: true, get: function() {
      return eosjs_api_1.Api;
    } });
    var ApiInterfaces = require_eosjs_api_interfaces();
    exports.ApiInterfaces = ApiInterfaces;
    var eosjs_jsonrpc_1 = require_eosjs_jsonrpc();
    Object.defineProperty(exports, "JsonRpc", { enumerable: true, get: function() {
      return eosjs_jsonrpc_1.JsonRpc;
    } });
    var Numeric = require_eosjs_numeric();
    exports.Numeric = Numeric;
    var RpcInterfaces = require_eosjs_rpc_interfaces();
    exports.RpcInterfaces = RpcInterfaces;
    var eosjs_rpcerror_1 = require_eosjs_rpcerror();
    Object.defineProperty(exports, "RpcError", { enumerable: true, get: function() {
      return eosjs_rpcerror_1.RpcError;
    } });
    var Serialize = require_eosjs_serialize();
    exports.Serialize = Serialize;
  }
});

export {
  require_eosjs_numeric,
  require_dist
};
//# sourceMappingURL=chunk-PH6WZYTG.js.map
